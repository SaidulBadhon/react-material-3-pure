/* ========== /_filled-text-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-text-field' show theme;


/* ========== /_outlined-text-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/outlined-text-field' show theme;


// ========== /filled-text-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../field/filled-field.js';

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';
import {literal} from 'lit/static-html.js';

import {styles as filledStyles} from './internal/filled-styles.js';
import {FilledTextField} from './internal/filled-text-field.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

export {type TextFieldType} from './internal/text-field.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-text-field': MdFilledTextField;
  }
}

/**
 * TODO(b/228525797): Add docs
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-text-field')
export class MdFilledTextField extends FilledTextField {
  static override styles: CSSResultOrNative[] = [sharedStyles, filledStyles];

  protected override readonly fieldTag = literal`md-filled-field`;
}


// ========== /filled-text-field_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdFilledTextField} from './filled-text-field.js';

describe('<md-filled-field>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledTextField.styles);
  });
});


// ========== /harness_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)
import './filled-text-field.js';

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {Harness} from '../testing/harness.js';

import {TextFieldHarness} from './harness.js';

describe('TextFieldHarness', () => {
  const env = new Environment();

  async function setupTest() {
    const root = env.render(
      html`<md-filled-text-field></md-filled-text-field>`,
    );
    const instance = root.querySelector('md-filled-text-field');
    if (!instance) {
      throw new Error('Failed to query md-filled-text-field.');
    }

    await env.waitForStability();
    return new TextFieldHarness(instance);
  }

  describe('inputValue()', () => {
    it('should emit key events for each character typed', async () => {
      // Setup.
      const harness = await setupTest();
      const keydownHandler = jasmine.createSpy('keydownHandler');
      harness.element.addEventListener('keydown', keydownHandler);
      // Test case.
      await harness.inputValue('abc');
      // Assertion.
      expect(keydownHandler).toHaveBeenCalledTimes(3);
      expect(keydownHandler).toHaveBeenCalledWith(jasmine.any(KeyboardEvent));
      expect(keydownHandler.calls.allArgs()).toEqual([
        [jasmine.objectContaining({key: 'a'})],
        [jasmine.objectContaining({key: 'b'})],
        [jasmine.objectContaining({key: 'c'})],
      ]);
    });

    it('should emit input events for each character typed', async () => {
      // Setup.
      const harness = await setupTest();
      const inputHandler = jasmine.createSpy('inputHandler');
      harness.element.addEventListener('input', inputHandler);
      // Test case.
      await harness.inputValue('abc');
      // Assertion.
      expect(inputHandler).toHaveBeenCalledTimes(3);
      expect(inputHandler).toHaveBeenCalledWith(jasmine.any(InputEvent));
    });
  });

  describe('deleteValue()', () => {
    it('should press the Backspace key', async () => {
      // Setup.
      const harness = await setupTest();
      const keydownHandler = jasmine.createSpy('keydownHandler');
      harness.element.addEventListener('keydown', keydownHandler);
      harness.element.value = 'Value';
      // Test case.
      await harness.deleteValue();
      // Assertion.
      expect(keydownHandler).toHaveBeenCalledTimes(1);
      expect(keydownHandler).toHaveBeenCalledWith(jasmine.any(KeyboardEvent));
      expect(keydownHandler).toHaveBeenCalledWith(
        jasmine.objectContaining({
          key: 'Backspace',
        }),
      );
    });

    it('should delete the entire value by default', async () => {
      // Setup.
      const harness = await setupTest();
      harness.element.value = 'Value';
      // Test case.
      await harness.deleteValue();
      // Assertion.
      expect(harness.element.value).toBe('');
    });

    it('should allow deleting part of the value', async () => {
      // Setup.
      const harness = await setupTest();
      harness.element.value = 'Value';
      // Test case.
      await harness.deleteValue(1, 4);
      // Assertion.
      expect(harness.element.value).toBe('Ve');
    });
  });

  describe('reset()', () => {
    it('should set the value to an empty string', async () => {
      // Setup.
      const harness = await setupTest();
      harness.element.value = 'Value';
      // Test case.
      await harness.reset();
      // Assertion.
      expect(harness.element.value).toBe('');
    });

    it('should call super.reset()', async () => {
      // Setup.
      const harness = await setupTest();
      spyOn(Harness.prototype, 'reset');
      // Test case.
      await harness.reset();
      // Assertion.
      expect(Harness.prototype.reset).toHaveBeenCalledTimes(1);
    });
  });

  describe('simulating change events', () => {
    it('should dispatch change if value changes after focus and blur', async () => {
      // Setup.
      const harness = await setupTest();
      const changeHandler = jasmine.createSpy('changeHandler');
      harness.element.addEventListener('change', changeHandler);
      // Test case.
      await harness.focusWithKeyboard();
      await harness.inputValue('value');
      await harness.blur();
      // Assertion.
      expect(changeHandler).toHaveBeenCalledTimes(1);
    });

    it('should not dispatch change if value does not change', async () => {
      // Setup.
      const harness = await setupTest();
      const changeHandler = jasmine.createSpy('changeHandler');
      harness.element.value = 'value';
      harness.element.addEventListener('change', changeHandler);
      // Test case.
      await harness.focusWithKeyboard();
      await harness.blur();
      // Assertion.
      expect(changeHandler).not.toHaveBeenCalled();
    });

    it('should not dispatch change if reset', async () => {
      // Setup.
      const harness = await setupTest();
      const changeHandler = jasmine.createSpy('changeHandler');
      await harness.focusWithKeyboard();
      await harness.inputValue('value');
      harness.element.addEventListener('change', changeHandler);
      // Test case.
      await harness.reset();
      await harness.blur();
      // Assertion.
      expect(changeHandler).not.toHaveBeenCalled();
    });
  });
});


/* ========== /internal/_filled-text-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
// go/keep-sorted end
// go/keep-sorted start
@use '../../field/filled-field';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filled-text-field-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $token == 'container-shape' and meta.type-of($value) == 'list' {
      @error 'Filled text field `container-shape` may not be specified as a list. Use logical (`*-start-start`) tokens instead.';
    }

    @if $value {
      --md-filled-text-field-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-text-field-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    @include filled-field.theme(
      (
        // go/keep-sorted start
        'active-indicator-color': var(--_active-indicator-color),
        'active-indicator-height': var(--_active-indicator-height),
        'bottom-space': var(--_bottom-space),
        'container-color': var(--_container-color),
        'container-shape-end-end': var(--_container-shape-end-end),
        'container-shape-end-start': var(--_container-shape-end-start),
        'container-shape-start-end': var(--_container-shape-start-end),
        'container-shape-start-start': var(--_container-shape-start-start),
        'content-color': var(--_input-text-color),
        'content-font': var(--_input-text-font),
        'content-line-height': var(--_input-text-line-height),
        'content-size': var(--_input-text-size),
        'content-space': var(--_icon-input-space),
        'content-weight': var(--_input-text-weight),
        'disabled-active-indicator-color':
          var(--_disabled-active-indicator-color),
        'disabled-active-indicator-height':
          var(--_disabled-active-indicator-height),
        'disabled-active-indicator-opacity':
          var(--_disabled-active-indicator-opacity),
        'disabled-container-color': var(--_disabled-container-color),
        'disabled-container-opacity': var(--_disabled-container-opacity),
        'disabled-content-color': var(--_disabled-input-text-color),
        'disabled-content-opacity': var(--_disabled-input-text-opacity),
        'disabled-label-text-color': var(--_disabled-label-text-color),
        'disabled-label-text-opacity': var(--_disabled-label-text-opacity),
        'disabled-leading-content-color': var(--_disabled-leading-icon-color),
        'disabled-leading-content-opacity':
          var(--_disabled-leading-icon-opacity),
        'disabled-supporting-text-color': var(--_disabled-supporting-text-color),
        'disabled-supporting-text-opacity':
          var(--_disabled-supporting-text-opacity),
        'disabled-trailing-content-color': var(--_disabled-trailing-icon-color),
        'disabled-trailing-content-opacity':
          var(--_disabled-trailing-icon-opacity),
        'error-active-indicator-color': var(--_error-active-indicator-color),
        'error-content-color': var(--_error-input-text-color),
        'error-focus-active-indicator-color':
          var(--_error-focus-active-indicator-color),
        'error-focus-content-color': var(--_error-focus-input-text-color),
        'error-focus-label-text-color': var(--_error-focus-label-text-color),
        'error-focus-leading-content-color':
          var(--_error-focus-leading-icon-color),
        'error-focus-supporting-text-color':
          var(--_error-focus-supporting-text-color),
        'error-focus-trailing-content-color':
          var(--_error-focus-trailing-icon-color),
        'error-hover-active-indicator-color':
          var(--_error-hover-active-indicator-color),
        'error-hover-content-color': var(--_error-hover-input-text-color),
        'error-hover-label-text-color': var(--_error-hover-label-text-color),
        'error-hover-leading-content-color':
          var(--_error-hover-leading-icon-color),
        'error-hover-state-layer-color': var(--_error-hover-state-layer-color),
        'error-hover-state-layer-opacity':
          var(--_error-hover-state-layer-opacity),
        'error-hover-supporting-text-color':
          var(--_error-hover-supporting-text-color),
        'error-hover-trailing-content-color':
          var(--_error-hover-trailing-icon-color),
        'error-label-text-color': var(--_error-label-text-color),
        'error-leading-content-color': var(--_error-leading-icon-color),
        'error-supporting-text-color': var(--_error-supporting-text-color),
        'error-trailing-content-color': var(--_error-trailing-icon-color),
        'focus-active-indicator-color': var(--_focus-active-indicator-color),
        'focus-active-indicator-height': var(--_focus-active-indicator-height),
        'focus-content-color': var(--_focus-input-text-color),
        'focus-label-text-color': var(--_focus-label-text-color),
        'focus-leading-content-color': var(--_focus-leading-icon-color),
        'focus-supporting-text-color': var(--_focus-supporting-text-color),
        'focus-trailing-content-color': var(--_focus-trailing-icon-color),
        'hover-active-indicator-color': var(--_hover-active-indicator-color),
        'hover-active-indicator-height': var(--_hover-active-indicator-height),
        'hover-content-color': var(--_hover-input-text-color),
        'hover-label-text-color': var(--_hover-label-text-color),
        'hover-leading-content-color': var(--_hover-leading-icon-color),
        'hover-state-layer-color': var(--_hover-state-layer-color),
        'hover-state-layer-opacity': var(--_hover-state-layer-opacity),
        'hover-supporting-text-color': var(--_hover-supporting-text-color),
        'hover-trailing-content-color': var(--_hover-trailing-icon-color),
        'label-text-color': var(--_label-text-color),
        'label-text-font': var(--_label-text-font),
        'label-text-line-height': var(--_label-text-line-height),
        'label-text-populated-line-height':
          var(--_label-text-populated-line-height),
        'label-text-populated-size': var(--_label-text-populated-size),
        'label-text-size': var(--_label-text-size),
        'label-text-weight': var(--_label-text-weight),
        'leading-content-color': var(--_leading-icon-color),
        'leading-space': var(--_leading-space),
        'supporting-text-color': var(--_supporting-text-color),
        'supporting-text-font': var(--_supporting-text-font),
        'supporting-text-line-height': var(--_supporting-text-line-height),
        'supporting-text-size': var(--_supporting-text-size),
        'supporting-text-weight': var(--_supporting-text-weight),
        'top-space': var(--_top-space),
        'trailing-content-color': var(--_trailing-icon-color),
        'trailing-space': var(--_trailing-space),
        'with-label-bottom-space': var(--_with-label-bottom-space),
        'with-label-top-space': var(--_with-label-top-space),
        'with-leading-content-leading-space':
          var(--_with-leading-icon-leading-space),
        'with-trailing-content-trailing-space':
          var(--_with-trailing-icon-trailing-space),
        // go/keep-sorted end
      )
    );
  }
}


/* ========== /internal/_icon.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles() {
  .icon {
    color: currentColor;
    display: flex;
    align-items: center;
    justify-content: center;
    fill: currentColor;
    position: relative;
  }

  .icon ::slotted(*) {
    // Remove excess whitespace below inline elements
    display: flex;
    // Absolutely position the icons within their `icon-size` container. This
    // supports icon buttons whose actual width and height is greater than the
    // 24px `icon-size` due to their 40px ripple.
    position: absolute;
  }

  [has-start] .icon.leading {
    font-size: var(--_leading-icon-size);
    height: var(--_leading-icon-size);
    width: var(--_leading-icon-size);
  }

  [has-end] .icon.trailing {
    font-size: var(--_trailing-icon-size);
    height: var(--_trailing-icon-size);
    width: var(--_trailing-icon-size);
  }
}


/* ========== /internal/_input.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles() {
  .input-wrapper {
    display: flex;
  }

  .input-wrapper > * {
    // Inherit field CSS set on the input wrapper, like font, but not margin or
    // padding. This wrapper is needed since text fields may have prefix and
    // suffix text next to an <input>
    all: inherit;
    padding: 0;
  }

  .input {
    caret-color: var(--_caret-color);
    // remove extra height added by horizontal scrollbars
    overflow-x: hidden;
    text-align: inherit;

    &::placeholder {
      color: currentColor;
      opacity: 1;
    }

    // Remove built-in datepicker icon on Chrome
    &::-webkit-calendar-picker-indicator {
      display: none;
    }

    // Remove built-in search icons on Chrome when type='search'
    &::-webkit-search-decoration,
    &::-webkit-search-cancel-button {
      display: none;
    }

    @media (forced-colors: active) {
      background: none; // Remove background in Firefox HCM
    }
  }

  // Optionally remove number input's spinner
  .no-spinner .input {
    &::-webkit-inner-spin-button,
    &::-webkit-outer-spin-button {
      display: none;
    }

    &[type='number'] {
      -moz-appearance: textfield;
    }
  }

  :focus-within .input {
    caret-color: var(--_focus-caret-color);
  }

  .error:focus-within .input {
    caret-color: var(--_error-focus-caret-color);
  }

  .text-field:not(.disabled) .prefix {
    color: var(--_input-text-prefix-color);
  }

  .text-field:not(.disabled) .suffix {
    color: var(--_input-text-suffix-color);
  }

  .text-field:not(.disabled) .input::placeholder {
    color: var(--_input-text-placeholder-color);
  }

  .prefix,
  .suffix {
    text-wrap: nowrap;
    width: min-content;
  }

  .prefix {
    padding-inline-end: var(--_input-text-prefix-trailing-space);
  }

  .suffix {
    padding-inline-start: var(--_input-text-suffix-leading-space);
  }
}


/* ========== /internal/_outlined-text-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../field/outlined-field';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-outlined-text-field-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-text-field-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-text-field-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    @include outlined-field.theme(
      (
        // go/keep-sorted start
        'bottom-space': var(--_bottom-space),
        'container-shape-end-end': var(--_container-shape-end-end),
        'container-shape-end-start': var(--_container-shape-end-start),
        'container-shape-start-end': var(--_container-shape-start-end),
        'container-shape-start-start': var(--_container-shape-start-start),
        'content-color': var(--_input-text-color),
        'content-font': var(--_input-text-font),
        'content-line-height': var(--_input-text-line-height),
        'content-size': var(--_input-text-size),
        'content-space': var(--_icon-input-space),
        'content-weight': var(--_input-text-weight),
        'disabled-content-color': var(--_disabled-input-text-color),
        'disabled-content-opacity': var(--_disabled-input-text-opacity),
        'disabled-label-text-color': var(--_disabled-label-text-color),
        'disabled-label-text-opacity': var(--_disabled-label-text-opacity),
        'disabled-leading-content-color': var(--_disabled-leading-icon-color),
        'disabled-leading-content-opacity':
          var(--_disabled-leading-icon-opacity),
        'disabled-outline-color': var(--_disabled-outline-color),
        'disabled-outline-opacity': var(--_disabled-outline-opacity),
        'disabled-outline-width': var(--_disabled-outline-width),
        'disabled-supporting-text-color': var(--_disabled-supporting-text-color),
        'disabled-supporting-text-opacity':
          var(--_disabled-supporting-text-opacity),
        'disabled-trailing-content-color': var(--_disabled-trailing-icon-color),
        'disabled-trailing-content-opacity':
          var(--_disabled-trailing-icon-opacity),
        'error-content-color': var(--_error-input-text-color),
        'error-focus-content-color': var(--_error-focus-input-text-color),
        'error-focus-label-text-color': var(--_error-focus-label-text-color),
        'error-focus-leading-content-color':
          var(--_error-focus-leading-icon-color),
        'error-focus-outline-color': var(--_error-focus-outline-color),
        'error-focus-supporting-text-color':
          var(--_error-focus-supporting-text-color),
        'error-focus-trailing-content-color':
          var(--_error-focus-trailing-icon-color),
        'error-hover-content-color': var(--_error-hover-input-text-color),
        'error-hover-label-text-color': var(--_error-hover-label-text-color),
        'error-hover-leading-content-color':
          var(--_error-hover-leading-icon-color),
        'error-hover-outline-color': var(--_error-hover-outline-color),
        'error-hover-supporting-text-color':
          var(--_error-hover-supporting-text-color),
        'error-hover-trailing-content-color':
          var(--_error-hover-trailing-icon-color),
        'error-label-text-color': var(--_error-label-text-color),
        'error-leading-content-color': var(--_error-leading-icon-color),
        'error-outline-color': var(--_error-outline-color),
        'error-supporting-text-color': var(--_error-supporting-text-color),
        'error-trailing-content-color': var(--_error-trailing-icon-color),
        'focus-content-color': var(--_focus-input-text-color),
        'focus-label-text-color': var(--_focus-label-text-color),
        'focus-leading-content-color': var(--_focus-leading-icon-color),
        'focus-outline-color': var(--_focus-outline-color),
        'focus-outline-width': var(--_focus-outline-width),
        'focus-supporting-text-color': var(--_focus-supporting-text-color),
        'focus-trailing-content-color': var(--_focus-trailing-icon-color),
        'hover-content-color': var(--_hover-input-text-color),
        'hover-label-text-color': var(--_hover-label-text-color),
        'hover-leading-content-color': var(--_hover-leading-icon-color),
        'hover-outline-color': var(--_hover-outline-color),
        'hover-outline-width': var(--_hover-outline-width),
        'hover-supporting-text-color': var(--_hover-supporting-text-color),
        'hover-trailing-content-color': var(--_hover-trailing-icon-color),
        'label-text-color': var(--_label-text-color),
        'label-text-font': var(--_label-text-font),
        'label-text-line-height': var(--_label-text-line-height),
        'label-text-populated-line-height':
          var(--_label-text-populated-line-height),
        'label-text-populated-size': var(--_label-text-populated-size),
        'label-text-size': var(--_label-text-size),
        'label-text-weight': var(--_label-text-weight),
        'leading-content-color': var(--_leading-icon-color),
        'leading-space': var(--_leading-space),
        'outline-color': var(--_outline-color),
        'outline-width': var(--_outline-width),
        'supporting-text-color': var(--_supporting-text-color),
        'supporting-text-font': var(--_supporting-text-font),
        'supporting-text-line-height': var(--_supporting-text-line-height),
        'supporting-text-size': var(--_supporting-text-size),
        'supporting-text-weight': var(--_supporting-text-weight),
        'top-space': var(--_top-space),
        'trailing-content-color': var(--_trailing-icon-color),
        'trailing-space': var(--_trailing-space),
        'with-leading-content-leading-space':
          var(--_with-leading-icon-leading-space),
        'with-trailing-content-trailing-space':
          var(--_with-trailing-icon-trailing-space),
        // go/keep-sorted end
      )
    );
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use './icon';
@use './input';
// go/keep-sorted end

@mixin styles() {
  :host {
    display: inline-flex;
    outline: none;
    resize: both;
    // Match default text-align of `<input>` instead of `inherit`.
    text-align: start;
    -webkit-tap-highlight-color: transparent;
  }

  .text-field,
  .field {
    width: 100%;
  }

  .text-field {
    display: inline-flex;
  }

  .field {
    cursor: text;
  }

  .disabled .field {
    cursor: default;
  }

  .text-field,
  .textarea .field {
    // Note: only inherit default `resize: both` to the field when textarea.
    resize: inherit;
  }

  slot[name='container'] {
    border-radius: inherit;
  }

  @include icon.styles;
  @include input.styles;
}


/* ========== /internal/filled-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filled-text-field';
// go/keep-sorted end

@include filled-text-field.styles;


// ========== /internal/filled-text-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../field/filled-field.js';

import {literal} from 'lit/static-html.js';

import {TextField} from './text-field.js';

/**
 * A filled text field component.
 */
export class FilledTextField extends TextField {
  protected readonly fieldTag = literal`md-filled-field`;
}


/* ========== /internal/outlined-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-text-field';
// go/keep-sorted end

@include outlined-text-field.styles;


// ========== /internal/outlined-text-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../field/outlined-field.js';

import {literal} from 'lit/static-html.js';

import {TextField} from './text-field.js';

/**
 * An outlined text field component
 */
export class OutlinedTextField extends TextField {
  protected readonly fieldTag = literal`md-outlined-field`;
}


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /internal/text-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement, PropertyValues, html, nothing} from 'lit';
import {property, query, queryAssignedElements, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';
import {live} from 'lit/directives/live.js';
import {StyleInfo, styleMap} from 'lit/directives/style-map.js';
import {StaticValue, html as staticHtml} from 'lit/static-html.js';

import {Field} from '../../field/internal/field.js';
import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {stringConverter} from '../../internal/controller/string-converter.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';
import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from '../../labs/behaviors/constraint-validation.js';
import {mixinElementInternals} from '../../labs/behaviors/element-internals.js';
import {
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {
  mixinOnReportValidity,
  onReportValidity,
} from '../../labs/behaviors/on-report-validity.js';
import {TextFieldValidator} from '../../labs/behaviors/validators/text-field-validator.js';
import {Validator} from '../../labs/behaviors/validators/validator.js';

/**
 * Input types that are compatible with the text field.
 */
export type TextFieldType =
  | 'email'
  | 'number'
  | 'password'
  | 'search'
  | 'tel'
  | 'text'
  | 'url'
  | 'textarea';

/**
 * Input types that are not fully supported for the text field.
 */
export type UnsupportedTextFieldType =
  | 'color'
  | 'date'
  | 'datetime-local'
  | 'file'
  | 'month'
  | 'time'
  | 'week';

/**
 * Input types that are incompatible with the text field.
 */
export type InvalidTextFieldType =
  | 'button'
  | 'checkbox'
  | 'hidden'
  | 'image'
  | 'radio'
  | 'range'
  | 'reset'
  | 'submit';

// Separate variable needed for closure.
const textFieldBaseClass = mixinDelegatesAria(
  mixinOnReportValidity(
    mixinConstraintValidation(
      mixinFormAssociated(mixinElementInternals(LitElement)),
    ),
  ),
);

/**
 * A text field component.
 *
 * @fires select {Event} The native `select` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select_event)
 * --bubbles
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 */
export abstract class TextField extends textFieldBaseClass {
  /** @nocollapse */
  static override shadowRootOptions: ShadowRootInit = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Gets or sets whether or not the text field is in a visually invalid state.
   *
   * This error state overrides the error state controlled by
   * `reportValidity()`.
   */
  @property({type: Boolean, reflect: true}) error = false;

  /**
   * The error message that replaces supporting text when `error` is true. If
   * `errorText` is an empty string, then the supporting text will continue to
   * show.
   *
   * This error message overrides the error message displayed by
   * `reportValidity()`.
   */
  @property({attribute: 'error-text'}) errorText = '';

  /**
   * The floating Material label of the textfield component. It informs the user
   * about what information is requested for a text field. It is aligned with
   * the input text, is always visible, and it floats when focused or when text
   * is entered into the textfield. This label also sets accessibilty labels,
   * but the accessible label is overriden by `aria-label`.
   *
   * Learn more about floating labels from the Material Design guidelines:
   * https://m3.material.io/components/text-fields/guidelines
   */
  @property() label = '';

  /**
   * Disables the asterisk on the floating label, when the text field is
   * required.
   */
  @property({type: Boolean, attribute: 'no-asterisk'}) noAsterisk = false;

  /**
   * Indicates that the user must specify a value for the input before the
   * owning form can be submitted and will render an error state when
   * `reportValidity()` is invoked when value is empty. Additionally the
   * floating label will render an asterisk `"*"` when true.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required
   */
  @property({type: Boolean, reflect: true}) required = false;

  /**
   * The current value of the text field. It is always a string.
   */
  @property() value = '';

  /**
   * An optional prefix to display before the input value.
   */
  @property({attribute: 'prefix-text'}) prefixText = '';

  /**
   * An optional suffix to display after the input value.
   */
  @property({attribute: 'suffix-text'}) suffixText = '';

  /**
   * Whether or not the text field has a leading icon. Used for SSR.
   */
  @property({type: Boolean, attribute: 'has-leading-icon'})
  hasLeadingIcon = false;

  /**
   * Whether or not the text field has a trailing icon. Used for SSR.
   */
  @property({type: Boolean, attribute: 'has-trailing-icon'})
  hasTrailingIcon = false;

  /**
   * Conveys additional information below the text field, such as how it should
   * be used.
   */
  @property({attribute: 'supporting-text'}) supportingText = '';

  /**
   * Override the input text CSS `direction`. Useful for RTL languages that use
   * LTR notation for fractions.
   */
  @property({attribute: 'text-direction'}) textDirection = '';

  /**
   * The number of rows to display for a `type="textarea"` text field.
   * Defaults to 2.
   */
  @property({type: Number}) rows = 2;

  /**
   * The number of cols to display for a `type="textarea"` text field.
   * Defaults to 20.
   */
  @property({type: Number}) cols = 20;

  // <input> properties
  @property({reflect: true}) override inputMode = '';

  /**
   * Defines the greatest value in the range of permitted values.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#max
   */
  @property() max = '';

  /**
   * The maximum number of characters a user can enter into the text field. Set
   * to -1 for none.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#maxlength
   */
  @property({type: Number}) maxLength = -1;

  /**
   * Defines the most negative value in the range of permitted values.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#min
   */
  @property() min = '';

  /**
   * The minimum number of characters a user can enter into the text field. Set
   * to -1 for none.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#minlength
   */
  @property({type: Number}) minLength = -1;

  /**
   * When true, hide the spinner for `type="number"` text fields.
   */
  @property({type: Boolean, attribute: 'no-spinner'}) noSpinner = false;

  /**
   * A regular expression that the text field's value must match to pass
   * constraint validation.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#pattern
   */
  @property() pattern = '';

  /**
   * Defines the text displayed in the textfield when it has no value. Provides
   * a brief hint to the user as to the expected type of data that should be
   * entered into the control. Unlike `label`, the placeholder is not visible
   * and does not float when the textfield has a value.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/placeholder
   */
  @property({reflect: true, converter: stringConverter}) placeholder = '';

  /**
   * Indicates whether or not a user should be able to edit the text field's
   * value.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#readonly
   */
  @property({type: Boolean, reflect: true}) readOnly = false;

  /**
   * Indicates that input accepts multiple email addresses.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#multiple
   */
  @property({type: Boolean, reflect: true}) multiple = false;

  /**
   * Gets or sets the direction in which selection occurred.
   */
  get selectionDirection() {
    return this.getInputOrTextarea().selectionDirection;
  }
  set selectionDirection(value: 'forward' | 'backward' | 'none' | null) {
    this.getInputOrTextarea().selectionDirection = value;
  }

  /**
   * Gets or sets the end position or offset of a text selection.
   */
  get selectionEnd() {
    return this.getInputOrTextarea().selectionEnd;
  }
  set selectionEnd(value: number | null) {
    this.getInputOrTextarea().selectionEnd = value;
  }

  /**
   * Gets or sets the starting position or offset of a text selection.
   */
  get selectionStart() {
    return this.getInputOrTextarea().selectionStart;
  }
  set selectionStart(value: number | null) {
    this.getInputOrTextarea().selectionStart = value;
  }

  /**
   * Returns or sets the element's step attribute, which works with min and max
   * to limit the increments at which a numeric or date-time value can be set.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step
   */
  @property() step = '';

  /**
   * The `<input>` type to use, defaults to "text". The type greatly changes how
   * the text field behaves.
   *
   * Text fields support a limited number of `<input>` types:
   *
   * - text
   * - textarea
   * - email
   * - number
   * - password
   * - search
   * - tel
   * - url
   *
   * See
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types
   * for more details on each input type.
   */
  @property({reflect: true})
  type: TextFieldType | UnsupportedTextFieldType = 'text';

  /**
   * Describes what, if any, type of autocomplete functionality the input
   * should provide.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete
   */
  @property({reflect: true}) autocomplete = '';

  /**
   * The text field's value as a number.
   */
  get valueAsNumber() {
    const input = this.getInput();
    if (!input) {
      return NaN;
    }

    return input.valueAsNumber;
  }
  set valueAsNumber(value: number) {
    const input = this.getInput();
    if (!input) {
      return;
    }

    input.valueAsNumber = value;
    this.value = input.value;
  }

  /**
   * The text field's value as a Date.
   */
  get valueAsDate() {
    const input = this.getInput();
    if (!input) {
      return null;
    }

    return input.valueAsDate;
  }
  set valueAsDate(value: Date | null) {
    const input = this.getInput();
    if (!input) {
      return;
    }

    input.valueAsDate = value;
    this.value = input.value;
  }

  protected abstract readonly fieldTag: StaticValue;

  /**
   * Returns true when the text field has been interacted with. Native
   * validation errors only display in response to user interactions.
   */
  @state() private dirty = false;
  @state() private focused = false;
  /**
   * Whether or not a native error has been reported via `reportValidity()`.
   */
  @state() private nativeError = false;
  /**
   * The validation message displayed from a native error via
   * `reportValidity()`.
   */
  @state() private nativeErrorText = '';

  private get hasError() {
    return this.error || this.nativeError;
  }

  @query('.input')
  private readonly inputOrTextarea!:
    | HTMLInputElement
    | HTMLTextAreaElement
    | null;
  @query('.field') private readonly field!: Field | null;
  @queryAssignedElements({slot: 'leading-icon'})
  private readonly leadingIcons!: Element[];
  @queryAssignedElements({slot: 'trailing-icon'})
  private readonly trailingIcons!: Element[];

  /**
   * Selects all the text in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select
   */
  select() {
    this.getInputOrTextarea().select();
  }

  /**
   * Replaces a range of text with a new string.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setRangeText
   */
  setRangeText(replacement: string): void;
  setRangeText(
    replacement: string,
    start: number,
    end: number,
    selectionMode?: SelectionMode,
  ): void;
  setRangeText(...args: unknown[]) {
    // Calling setRangeText with 1 vs 3-4 arguments has different behavior.
    // Use spread syntax and type casting to ensure correct usage.
    this.getInputOrTextarea().setRangeText(
      ...(args as Parameters<HTMLInputElement['setRangeText']>),
    );
    this.value = this.getInputOrTextarea().value;
  }

  /**
   * Sets the start and end positions of a selection in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
   *
   * @param start The offset into the text field for the start of the selection.
   * @param end The offset into the text field for the end of the selection.
   * @param direction The direction in which the selection is performed.
   */
  setSelectionRange(
    start: number | null,
    end: number | null,
    direction?: 'forward' | 'backward' | 'none',
  ) {
    this.getInputOrTextarea().setSelectionRange(start, end, direction);
  }

  /**
   * Shows the browser picker for an input element of type "date", "time", etc.
   *
   * For a full list of supported types, see:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/showPicker#browser_compatibility
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/showPicker
   */
  showPicker() {
    const input = this.getInput();
    if (!input) {
      return;
    }

    input.showPicker();
  }

  /**
   * Decrements the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepDown
   *
   * @param stepDecrement The number of steps to decrement, defaults to 1.
   */
  stepDown(stepDecrement?: number) {
    const input = this.getInput();
    if (!input) {
      return;
    }

    input.stepDown(stepDecrement);
    this.value = input.value;
  }

  /**
   * Increments the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepUp
   *
   * @param stepIncrement The number of steps to increment, defaults to 1.
   */
  stepUp(stepIncrement?: number) {
    const input = this.getInput();
    if (!input) {
      return;
    }

    input.stepUp(stepIncrement);
    this.value = input.value;
  }

  /**
   * Reset the text field to its default value.
   */
  reset() {
    this.dirty = false;
    this.value = this.getAttribute('value') ?? '';
    this.nativeError = false;
    this.nativeErrorText = '';
  }

  override attributeChangedCallback(
    attribute: string,
    newValue: string | null,
    oldValue: string | null,
  ) {
    if (attribute === 'value' && this.dirty) {
      // After user input, changing the value attribute no longer updates the
      // text field's value (until reset). This matches native <input> behavior.
      return;
    }

    super.attributeChangedCallback(attribute, newValue, oldValue);
  }

  protected override render() {
    const classes = {
      'disabled': this.disabled,
      'error': !this.disabled && this.hasError,
      'textarea': this.type === 'textarea',
      'no-spinner': this.noSpinner,
    };

    return html`
      <span class="text-field ${classMap(classes)}">
        ${this.renderField()}
      </span>
    `;
  }

  protected override updated(changedProperties: PropertyValues) {
    // Keep changedProperties arg so that subclasses may call it

    // If a property such as `type` changes and causes the internal <input>
    // value to change without dispatching an event, re-sync it.
    const value = this.getInputOrTextarea().value;
    if (this.value !== value) {
      // Note this is typically inefficient in updated() since it schedules
      // another update. However, it is needed for the <input> to fully render
      // before checking its value.
      this.value = value;
    }
  }

  private renderField() {
    return staticHtml`<${this.fieldTag}
      class="field"
      count=${this.value.length}
      ?disabled=${this.disabled}
      ?error=${this.hasError}
      error-text=${this.getErrorText()}
      ?focused=${this.focused}
      ?has-end=${this.hasTrailingIcon}
      ?has-start=${this.hasLeadingIcon}
      label=${this.label}
      ?no-asterisk=${this.noAsterisk}
      max=${this.maxLength}
      ?populated=${!!this.value}
      ?required=${this.required}
      ?resizable=${this.type === 'textarea'}
      supporting-text=${this.supportingText}
    >
      ${this.renderLeadingIcon()}
      ${this.renderInputOrTextarea()}
      ${this.renderTrailingIcon()}
      <div id="description" slot="aria-describedby"></div>
      <slot name="container" slot="container"></slot>
    </${this.fieldTag}>`;
  }

  private renderLeadingIcon() {
    return html`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }

  private renderTrailingIcon() {
    return html`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }

  private renderInputOrTextarea() {
    const style: StyleInfo = {'direction': this.textDirection};
    const ariaLabel =
      (this as ARIAMixinStrict).ariaLabel || this.label || nothing;
    // lit-anaylzer `autocomplete` types are too strict
    // tslint:disable-next-line:no-any
    const autocomplete = this.autocomplete as any;

    // These properties may be set to null if the attribute is removed, and
    // `null > -1` is incorrectly `true`.
    const hasMaxLength = (this.maxLength ?? -1) > -1;
    const hasMinLength = (this.minLength ?? -1) > -1;
    if (this.type === 'textarea') {
      return html`
        <textarea
          class="input"
          style=${styleMap(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || nothing}
          name=${this.name || nothing}
          ?disabled=${this.disabled}
          maxlength=${hasMaxLength ? this.maxLength : nothing}
          minlength=${hasMinLength ? this.minLength : nothing}
          placeholder=${this.placeholder || nothing}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          rows=${this.rows}
          cols=${this.cols}
          .value=${live(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent}></textarea>
      `;
    }

    const prefix = this.renderPrefix();
    const suffix = this.renderSuffix();

    // TODO(b/243805848): remove `as unknown as number` and `as any` once lit
    // analyzer is fixed
    // tslint:disable-next-line:no-any
    const inputMode = this.inputMode as any;
    return html`
      <div class="input-wrapper">
        ${prefix}
        <input
          class="input"
          style=${styleMap(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || nothing}
          name=${this.name || nothing}
          ?disabled=${this.disabled}
          inputmode=${inputMode || nothing}
          max=${(this.max || nothing) as unknown as number}
          maxlength=${hasMaxLength ? this.maxLength : nothing}
          min=${(this.min || nothing) as unknown as number}
          minlength=${hasMinLength ? this.minLength : nothing}
          pattern=${this.pattern || nothing}
          placeholder=${this.placeholder || nothing}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          ?multiple=${this.multiple}
          step=${(this.step || nothing) as unknown as number}
          type=${this.type}
          .value=${live(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent} />
        ${suffix}
      </div>
    `;
  }

  private renderPrefix() {
    return this.renderAffix(this.prefixText, /* isSuffix */ false);
  }

  private renderSuffix() {
    return this.renderAffix(this.suffixText, /* isSuffix */ true);
  }

  private renderAffix(text: string, isSuffix: boolean) {
    if (!text) {
      return nothing;
    }

    const classes = {
      'suffix': isSuffix,
      'prefix': !isSuffix,
    };

    return html`<span class="${classMap(classes)}">${text}</span>`;
  }

  private getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }

  private handleFocusChange() {
    // When calling focus() or reportValidity() during change, it's possible
    // for blur to be called after the new focus event. Rather than set
    // `this.focused` to true/false on focus/blur, we always set it to whether
    // or not the input itself is focused.
    this.focused = this.inputOrTextarea?.matches(':focus') ?? false;
  }

  private handleInput(event: InputEvent) {
    this.dirty = true;
    this.value = (event.target as HTMLInputElement).value;
  }

  private redispatchEvent(event: Event) {
    redispatchEvent(this, event);
  }

  private getInputOrTextarea() {
    if (!this.inputOrTextarea) {
      // If the input is not yet defined, synchronously render.
      // e.g.
      // const textField = document.createElement('md-outlined-text-field');
      // document.body.appendChild(textField);
      // textField.focus(); // synchronously render
      this.connectedCallback();
      this.scheduleUpdate();
    }

    if (this.isUpdatePending) {
      // If there are pending updates, synchronously perform them. This ensures
      // that constraint validation properties (like `required`) are synced
      // before interacting with input APIs that depend on them.
      this.scheduleUpdate();
    }

    return this.inputOrTextarea!;
  }

  private getInput() {
    if (this.type === 'textarea') {
      return null;
    }

    return this.getInputOrTextarea() as HTMLInputElement;
  }

  private handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
    this.hasTrailingIcon = this.trailingIcons.length > 0;
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    return this.value;
  }

  override formResetCallback() {
    this.reset();
  }

  override formStateRestoreCallback(state: string) {
    this.value = state;
  }

  override focus() {
    // Required for the case that the user slots a focusable element into the
    // leading icon slot such as an iconbutton due to how delegatesFocus works.
    this.getInputOrTextarea().focus();
  }

  override [createValidator](): Validator<unknown> {
    return new TextFieldValidator(() => ({
      state: this,
      renderedControl: this.inputOrTextarea,
    }));
  }

  override [getValidityAnchor](): HTMLElement | null {
    return this.inputOrTextarea;
  }

  override [onReportValidity](invalidEvent: Event | null) {
    // Prevent default pop-up behavior.
    invalidEvent?.preventDefault();

    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;

    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }
}


// ========== /internal/text-field_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)
import '../../field/filled-field.js';

import {html, render} from 'lit';
import {customElement} from 'lit/decorators.js';
import {literal} from 'lit/static-html.js';

import {Environment} from '../../testing/environment.js';
import {createFormTests} from '../../testing/forms.js';
import {Harness} from '../../testing/harness.js';
import {TextFieldHarness} from '../harness.js';

import {TextField} from './text-field.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-test-text-field': TestTextField;
  }
}

@customElement('md-test-text-field')
class TestTextField extends TextField {
  protected override readonly fieldTag = literal`md-filled-field`;

  async getHasError() {
    await this.updateComplete;
    return (
      this.renderRoot.querySelector('input')?.getAttribute('aria-invalid') ===
      'true'
    );
  }

  async getErrorTextValue() {
    await this.updateComplete;
    return this.renderRoot.querySelector('md-filled-field')?.errorText || '';
  }
}

describe('TextField', () => {
  const env = new Environment();

  async function setupTest(
    template = html`<md-test-text-field></md-test-text-field>`,
  ) {
    // Variant type does not matter for shared tests
    const element = env.render(template).querySelector('md-test-text-field');
    if (!element) {
      throw new Error('Could not query rendered <md-test-text-field>.');
    }

    await env.waitForStability();
    const input = element.renderRoot.querySelector('input');
    if (!input) {
      throw new Error('Could not query rendered <input>.');
    }

    return {
      input,
      testElement: element,
      harness: new TextFieldHarness(element),
    };
  }

  describe('focusing the input', () => {
    it('should call focus the input on click', async () => {
      const {harness, input} = await setupTest();

      await harness.clickWithMouse();

      expect(input.matches(':focus')).withContext('is input:focus').toBeTrue();
    });

    it('should NOT focus the input when elements inside text field are clicked', async () => {
      const {harness, input} = await setupTest();
      // Add a trailing icon button to click on
      render(html`<button slot="trailing-icon">X</button>`, harness.element);
      const button = harness.element.querySelector('button');

      expect(button).toBeDefined();
      const buttonHarness = new Harness(button!);
      await buttonHarness.clickWithMouse();

      expect(input.matches(':focus')).withContext('is input:focus').toBeFalse();
    });

    it('should not focus the input when disabled', async () => {
      const {harness, input} = await setupTest();
      harness.element.disabled = true;
      await env.waitForStability();

      harness.element.focus();

      expect(input.matches(':focus'))
        .withContext('not input:focus')
        .toBeFalse();
    });

    it('focus() should focus input', async () => {
      const {harness, input} = await setupTest();

      harness.element.focus();

      expect(input.matches(':focus')).withContext('is input:focus').toBeTrue();
    });

    it('blur() should blur input', async () => {
      const {harness, input} = await setupTest();

      harness.element.focus();
      harness.element.blur();

      expect(input.matches(':focus'))
        .withContext('not input:focus')
        .toBeFalse();
    });
  });

  describe('input events', () => {
    it('should update the text field value', async () => {
      const {harness} = await setupTest();

      await harness.inputValue('Value');

      expect(harness.element.value).toEqual('Value');
    });

    it('should redispatch input events', async () => {
      const {harness, input} = await setupTest();
      const inputHandler = jasmine.createSpy('inputHandler');
      harness.element.addEventListener('input', inputHandler);

      const event = new InputEvent('input', {
        composed: true,
        bubbles: true,
      });
      input.dispatchEvent(event);

      expect(inputHandler).toHaveBeenCalledWith(event);
    });
  });

  describe('resetting the input', () => {
    it('should set value back to default value', async () => {
      const {harness} = await setupTest();
      harness.element.setAttribute('value', 'Default');
      await env.waitForStability();

      expect(harness.element.value).toBe('Default');
      await harness.deleteValue();
      await harness.inputValue('Value');
      expect(harness.element.value).toBe('Value');
      harness.element.reset();

      expect(harness.element.value).toBe('Default');
    });

    it('should set value to empty string if there is no default', async () => {
      const {harness} = await setupTest();

      await harness.inputValue('Value');
      harness.element.reset();

      expect(harness.element.value).toBe('');
    });
  });

  describe('default value', () => {
    it('should update `value` before user input', async () => {
      const {harness} = await setupTest();

      harness.element.setAttribute('value', 'Default');
      await env.waitForStability();

      expect(harness.element.value).toBe('Default');
    });

    it('should update `value` multiple times', async () => {
      const {harness} = await setupTest();

      harness.element.setAttribute('value', 'First default');
      await env.waitForStability();
      harness.element.setAttribute('value', 'Second default');
      await env.waitForStability();

      expect(harness.element.value).toBe('Second default');
    });

    it('should NOT update `value` after user input', async () => {
      const {harness} = await setupTest();

      harness.element.setAttribute('value', 'First default');
      await env.waitForStability();
      await harness.deleteValue();
      await harness.inputValue('Value');

      harness.element.setAttribute('value', 'Second default');
      await env.waitForStability();

      expect(harness.element.value).toBe('Value');
    });

    it('should render `value` instead of default value attribute when `value` changes', async () => {
      const {harness, input} = await setupTest();

      harness.element.setAttribute('value', 'Default');
      await env.waitForStability();
      expect(input.value).toBe('Default');

      harness.element.value = 'Value';
      await env.waitForStability();
      expect(input.value).toBe('Value');

      harness.element.value = '';
      await env.waitForStability();
      expect(input.value).toBe('');
      expect(harness.element.getAttribute('value')).toBe('Default');
    });
  });

  describe('valueAsDate', () => {
    it('should get input.valueAsDate', async () => {
      const {testElement, input} = await setupTest();
      const spy = spyOnProperty(input, 'valueAsDate', 'get').and.callThrough();

      expect(testElement.valueAsDate).toBe(null);

      expect(spy).toHaveBeenCalled();
    });

    it('should set input.valueAsDate', async () => {
      const {testElement, input} = await setupTest();
      testElement.type = 'date';
      await env.waitForStability();
      const spy = spyOnProperty(input, 'valueAsDate', 'set').and.callThrough();

      const value = new Date();
      testElement.valueAsDate = value;

      expect(spy).toHaveBeenCalledWith(value);
    });

    it('should set value to string version of date', async () => {
      const {testElement} = await setupTest();
      testElement.type = 'date';
      await env.waitForStability();

      const expectedValue = '2022-01-01';
      testElement.valueAsDate = new Date(expectedValue);

      expect(testElement.value).toBe(expectedValue);
    });
  });

  describe('valueAsNumber', () => {
    it('should get input.valueAsNumber', async () => {
      const {testElement, input} = await setupTest();
      const spy = spyOnProperty(
        input,
        'valueAsNumber',
        'get',
      ).and.callThrough();

      expect(testElement.valueAsNumber).toEqual(NaN);

      expect(spy).toHaveBeenCalled();
    });

    it('should set input.valueAsNumber', async () => {
      const {testElement, input} = await setupTest();
      testElement.type = 'number';
      await env.waitForStability();
      const spy = spyOnProperty(
        input,
        'valueAsNumber',
        'set',
      ).and.callThrough();

      testElement.valueAsNumber = 100;

      expect(spy).toHaveBeenCalledWith(100);
    });

    it('should set value to string version of number', async () => {
      const {testElement} = await setupTest();
      testElement.type = 'number';
      await env.waitForStability();

      testElement.valueAsNumber = 100;

      expect(testElement.value).toBe('100');
    });
  });

  describe('native validation', () => {
    describe('checkValidity()', () => {
      it('should return true if the text field is valid', async () => {
        const {testElement} = await setupTest();

        expect(testElement.checkValidity()).toBeTrue();
      });

      it('should return false if the text field is invalid', async () => {
        const {testElement} = await setupTest();
        testElement.required = true;

        expect(testElement.checkValidity()).toBeFalse();
      });

      it('should not dispatch an invalid event when valid', async () => {
        const {testElement} = await setupTest();
        const invalidHandler = jasmine.createSpy('invalidHandler');
        testElement.addEventListener('invalid', invalidHandler);

        testElement.checkValidity();

        expect(invalidHandler).not.toHaveBeenCalled();
      });

      it('should dispatch an invalid event when invalid', async () => {
        const {testElement} = await setupTest();
        const invalidHandler = jasmine.createSpy('invalidHandler');
        testElement.addEventListener('invalid', invalidHandler);
        testElement.required = true;

        testElement.checkValidity();

        expect(invalidHandler).toHaveBeenCalled();
      });

      it('should return validity during input event', async () => {
        const {testElement, harness} = await setupTest();

        testElement.required = true;
        await harness.inputValue('Value');

        let isValidDuringInput = true;
        testElement.addEventListener('input', () => {
          isValidDuringInput = testElement.validity.valid;
        });

        await harness.deleteValue();

        expect(isValidDuringInput)
          .withContext('validity.valid result during input event')
          .toBeFalse();
      });

      it('should return validity during change event', async () => {
        const {testElement, harness} = await setupTest();
        testElement.required = true;

        await harness.inputValue('Value');
        await harness.blur();

        let isValidDuringChange = true;
        testElement.addEventListener(
          'change',
          () => {
            isValidDuringChange = testElement.validity.valid;
          },
          {once: true},
        );

        await harness.deleteValue();
        await harness.blur();

        expect(isValidDuringChange)
          .withContext('validity.valid result during change event')
          .toBeFalse();
      });
    });

    describe('reportValidity()', () => {
      it('should return true when valid and set error to false', async () => {
        const {testElement} = await setupTest();

        const valid = testElement.reportValidity();

        expect(valid).withContext('valid').toBeTrue();
        expect(await testElement.getHasError())
          .withContext('testElement.getHasError()')
          .toBeFalse();
      });

      it('should return false when invalid and set error to true', async () => {
        const {testElement} = await setupTest();
        testElement.required = true;

        const valid = testElement.reportValidity();

        expect(valid).withContext('valid').toBeFalse();
        expect(await testElement.getHasError())
          .withContext('testElement.getHasError()')
          .toBeTrue();
      });

      it('should update error text to validationMessage', async () => {
        const {testElement} = await setupTest();
        const errorMessage = 'Error message';
        testElement.setCustomValidity(errorMessage);

        testElement.reportValidity();

        expect(testElement.validationMessage).toEqual(errorMessage);
        expect(await testElement.getErrorTextValue()).toEqual(errorMessage);
      });

      it('should not update error or error text if invalid event is canceled', async () => {
        const {testElement} = await setupTest();
        testElement.addEventListener('invalid', (e) => {
          e.preventDefault();
        });
        const errorMessage = 'Error message';
        testElement.setCustomValidity(errorMessage);

        const valid = testElement.reportValidity();

        expect(valid).withContext('valid').toBeFalse();
        expect(await testElement.getHasError())
          .withContext('testElement.getHasError()')
          .toBeFalse();
        expect(await testElement.getErrorTextValue()).toEqual('');
      });

      it('should be overridden by error and errorText', async () => {
        const {testElement} = await setupTest();
        testElement.error = true;
        const errorMessage = 'Error message';
        testElement.errorText = errorMessage;

        const valid = testElement.reportValidity();
        expect(valid).withContext('native validity should be valid').toBeTrue();
        expect(await testElement.getHasError())
          .withContext('testElement.getHasError()')
          .toBeTrue();
        expect(await testElement.getErrorTextValue()).toEqual(errorMessage);
      });
    });

    describe('setCustomValidity()', () => {
      it('should set a custom validationMessage', async () => {
        const {testElement} = await setupTest();

        const errorMessage = 'Error message';
        testElement.setCustomValidity(errorMessage);
        expect(testElement.validationMessage)
          .withContext('validationMessage')
          .toEqual(errorMessage);
      });
    });

    describe('minLength and maxLength', () => {
      it('should set attribute on input', async () => {
        const {testElement, input} = await setupTest();
        testElement.minLength = 2;
        testElement.maxLength = 5;
        await env.waitForStability();

        expect(input.getAttribute('minLength'))
          .withContext('minLength')
          .toEqual('2');
        expect(input.getAttribute('maxLength'))
          .withContext('maxLength')
          .toEqual('5');
      });

      it('should not set attribute if value is -1', async () => {
        const {testElement, input} = await setupTest();
        testElement.minLength = 2;
        testElement.maxLength = 5;
        await env.waitForStability();

        expect(input.hasAttribute('minlength'))
          .withContext('should have minlength')
          .toBeTrue();
        expect(input.hasAttribute('maxlength'))
          .withContext('should have maxlength')
          .toBeTrue();

        testElement.minLength = -1;
        testElement.maxLength = -1;
        await env.waitForStability();

        expect(input.hasAttribute('minlength'))
          .withContext('should not have minlength')
          .toBeFalse();
        expect(input.hasAttribute('maxlength'))
          .withContext('should not have maxlength')
          .toBeFalse();
      });
    });

    describe('min, max, and step', () => {
      it('should set attribute on input', async () => {
        const {testElement, input} = await setupTest();
        testElement.type = 'number';
        testElement.min = '2';
        testElement.max = '5';
        testElement.step = '1';
        await env.waitForStability();

        expect(input.getAttribute('min')).withContext('min').toEqual('2');
        expect(input.getAttribute('max')).withContext('max').toEqual('5');
        expect(input.getAttribute('step')).withContext('step').toEqual('1');
      });

      it('should not set attribute if value is empty', async () => {
        const {testElement, input} = await setupTest();
        testElement.type = 'number';
        testElement.min = '2';
        testElement.max = '5';
        testElement.step = '1';
        await env.waitForStability();

        expect(input.hasAttribute('min'))
          .withContext('should have min')
          .toBeTrue();
        expect(input.hasAttribute('max'))
          .withContext('should have max')
          .toBeTrue();
        expect(input.hasAttribute('step'))
          .withContext('should have step')
          .toBeTrue();

        testElement.min = '';
        testElement.max = '';
        testElement.step = '';
        await env.waitForStability();

        expect(input.hasAttribute('min'))
          .withContext('should not have min')
          .toBeFalse();
        expect(input.hasAttribute('max'))
          .withContext('should not have max')
          .toBeFalse();
        expect(input.hasAttribute('step'))
          .withContext('should not have step')
          .toBeFalse();
      });
    });

    describe('pattern', () => {
      it('should set attribute on input', async () => {
        const {testElement, input} = await setupTest();
        testElement.pattern = 'foo';
        await env.waitForStability();

        expect(input.getAttribute('pattern'))
          .withContext('pattern')
          .toEqual('foo');
      });

      it('should not set attribute if value is empty', async () => {
        const {testElement, input} = await setupTest();
        testElement.pattern = 'foo';
        await env.waitForStability();

        expect(input.hasAttribute('pattern'))
          .withContext('should have pattern')
          .toBeTrue();

        testElement.pattern = '';
        await env.waitForStability();

        expect(input.hasAttribute('pattern'))
          .withContext('should not have pattern')
          .toBeFalse();
      });
    });
  });

  describe('stepUp()', () => {
    it('should increment the value by `step`', async () => {
      const {testElement} = await setupTest();
      testElement.type = 'number';
      testElement.valueAsNumber = 10;
      testElement.step = '5';

      testElement.stepUp();

      expect(testElement.valueAsNumber).toEqual(15);
    });
  });

  describe('stepDown()', () => {
    it('should decrement the value by `step`', async () => {
      const {testElement} = await setupTest();
      testElement.type = 'number';
      testElement.valueAsNumber = 10;
      testElement.step = '5';

      testElement.stepDown();

      expect(testElement.valueAsNumber).toEqual(5);
    });
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-test-text-field'),
      valueTests: [
        {
          name: 'unnamed',
          render: () =>
            html`<md-test-text-field value="Value"></md-test-text-field>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'should add empty value',
          render: () =>
            html`<md-test-text-field name="input"></md-test-text-field>`,
          assertValue(formData) {
            expect(formData.get('input')).toBe('');
          },
        },
        {
          name: 'with value',
          render: () =>
            html`<md-test-text-field
              name="input"
              value="Value"></md-test-text-field>`,
          assertValue(formData) {
            expect(formData.get('input')).toBe('Value');
          },
        },
        {
          name: 'disabled',
          render: () =>
            html`<md-test-text-field
              name="input"
              value="Value"
              disabled></md-test-text-field>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset to empty value',
          render: () =>
            html`<md-test-text-field name="input"></md-test-text-field>`,
          change(textField) {
            textField.value = 'Value';
          },
          assertReset(textField) {
            expect(textField.value)
              .withContext('textField.value after reset')
              .toBe('');
          },
        },
        {
          name: 'reset value',
          render: () =>
            html`<md-test-text-field
              name="input"
              value="First"></md-test-text-field>`,
          change(textField) {
            textField.value = 'Second';
          },
          assertReset(textField) {
            expect(textField.value)
              .withContext('textField.value after reset')
              .toBe('First');
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore value',
          render: () =>
            html`<md-test-text-field
              name="input"
              value="Value"></md-test-text-field>`,
          assertRestored(textField) {
            expect(textField.value)
              .withContext('textField.value after restore')
              .toBe('Value');
          },
        },
      ],
    });
  });
});


// ========== /outlined-text-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../field/outlined-field.js';

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';
import {literal} from 'lit/static-html.js';

import {styles as outlinedStyles} from './internal/outlined-styles.js';
import {OutlinedTextField} from './internal/outlined-text-field.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

export {type TextFieldType} from './internal/text-field.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-text-field': MdOutlinedTextField;
  }
}

/**
 * TODO(b/228525797): Add docs
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-text-field')
export class MdOutlinedTextField extends OutlinedTextField {
  static override styles: CSSResultOrNative[] = [sharedStyles, outlinedStyles];

  protected override readonly fieldTag = literal`md-outlined-field`;
}


// ========== /outlined-text-field_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdOutlinedTextField} from './outlined-text-field.js';

describe('<md-outlined-field>', () => {
  describe('.styles', () => {
    createTokenTests(MdOutlinedTextField.styles);
  });
});