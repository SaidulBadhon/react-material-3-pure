/* ========== /_dialog.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/dialog' show theme;


// ========== /dialog.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Dialog} from './internal/dialog.js';
import {styles} from './internal/dialog-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-dialog': MdDialog;
  }
}

/**
 * @summary Dialogs can require an action, communicate information, or help
 * users accomplish a task. There are two types of dialogs: basic and
 * full-screen.
 *
 * @description
 * A dialog is a modal window that appears in front of app content to provide
 * critical information or ask for a decision. Dialogs disable all app
 * functionality when they appear, and remain on screen until confirmed,
 * dismissed, or a required action has been taken.
 *
 * Dialogs are purposefully interruptive, so they should be used sparingly.
 * A less disruptive alternative is to use a menu, which provides options
 * without interrupting a userâ€™s experience.
 *
 * On mobile devices only, complex dialogs should be displayed fullscreen.
 *
 * __Example usages:__
 * - Common use cases for basic dialogs include alerts, quick selection, and
 * confirmation.
 * - More complex dialogs may contain actions that require a series of tasks
 * to complete. One example is creating a calendar entry with the event title,
 * date, location, and time.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-dialog')
export class MdDialog extends Dialog {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /dialog_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createTokenTests} from '../testing/tokens.js';

import {MdDialog} from './dialog.js';
import {DialogHarness} from './harness.js';

describe('<md-dialog>', () => {
  const env = new Environment();

  async function setupTest() {
    const root = env.render(html`
      <md-dialog>
        <form id="form" method="dialog" slot="content">
          Content
          <input autofocus />
        </form>
        <div slot="actions">
          <button form="form" value="button">Close</button>
        </div>
      </md-dialog>
    `);

    await env.waitForStability();
    const dialog = root.querySelector('md-dialog');
    if (!dialog) {
      throw new Error('Failed to query rendered <md-dialog>');
    }

    disableDialogAnimations(dialog);
    const harness = new DialogHarness(dialog);
    const dialogElement = dialog.shadowRoot?.querySelector('dialog');
    if (!dialogElement) {
      throw new Error('Failed to query rendered <dialog>');
    }

    const contentElement = root.querySelector<HTMLElement>('[slot=content]');
    if (!contentElement) {
      throw new Error('Failed to query rendered content.');
    }

    const focusElement = root.querySelector<HTMLElement>('[autofocus]');
    if (!focusElement) {
      throw new Error('Failed to query rendered autofocus element.');
    }

    return {harness, root, dialogElement, contentElement, focusElement};
  }

  describe('.styles', () => {
    createTokenTests(MdDialog.styles);
  });

  describe('basic', () => {
    it('open property calls show() and close()', async () => {
      const {harness} = await setupTest();
      spyOn(harness.element, 'show');
      spyOn(harness.element, 'close');

      harness.element.open = true;
      await env.waitForStability();
      expect(harness.element.show).toHaveBeenCalled();

      harness.element.open = false;
      await env.waitForStability();
      expect(harness.element.close).toHaveBeenCalled();
    });

    it('renders open state by calling show()/close()', async () => {
      const {harness, dialogElement} = await setupTest();
      await harness.element.show();
      expect(dialogElement.open).toBeTrue();
      await harness.element.close();
      expect(dialogElement.open).toBeFalse();
    });

    it('fires open/close events', async () => {
      const {harness} = await setupTest();
      const openHandler = jasmine.createSpy('openHandler');
      const openedHandler = jasmine.createSpy('openedHandler');
      const closeHandler = jasmine.createSpy('closeHandler');
      const closedHandler = jasmine.createSpy('closedHandler');
      harness.element.addEventListener('open', openHandler);
      harness.element.addEventListener('opened', openedHandler);
      harness.element.addEventListener('close', closeHandler);
      harness.element.addEventListener('closed', closedHandler);
      await harness.element.show();
      expect(openHandler).toHaveBeenCalledTimes(1);
      expect(openedHandler).toHaveBeenCalledTimes(1);
      expect(closeHandler).toHaveBeenCalledTimes(0);
      expect(closedHandler).toHaveBeenCalledTimes(0);
      await harness.element.close('testing');
      expect(openHandler).toHaveBeenCalledTimes(1);
      expect(openedHandler).toHaveBeenCalledTimes(1);
      expect(closeHandler).toHaveBeenCalledTimes(1);
      expect(closedHandler).toHaveBeenCalledTimes(1);
      expect(harness.element.returnValue).toBe('testing');
    });

    it('closes when element with action is clicked', async () => {
      const {harness} = await setupTest();
      await harness.element.show();
      const closedPromise = new Promise<void>((resolve) => {
        harness.element.addEventListener(
          'closed',
          () => {
            resolve();
          },
          {once: true},
        );
      });

      harness.element
        .querySelector<HTMLButtonElement>('[value="button"]')!
        .click();
      await closedPromise;
      expect(harness.element.open).toBeFalse();
      expect(harness.element.returnValue).toBe('button');
    });

    it('closes with click outside dialog', async () => {
      const {harness, dialogElement, contentElement} = await setupTest();
      const isClosing = jasmine.createSpy('isClosing');
      harness.element.addEventListener('close', isClosing);
      await harness.element.show();
      contentElement.click();
      expect(isClosing).not.toHaveBeenCalled();
      dialogElement.click();
      await env.waitForStability();
      expect(isClosing).toHaveBeenCalled();
    });

    it('focuses element with autofocus when shown and previously focused element when closed', async () => {
      const {harness, focusElement} = await setupTest();
      const button = document.createElement('button');
      document.body.append(button);
      button.focus();
      expect(document.activeElement).toBe(button);
      await harness.element.show();
      expect(document.activeElement).toBe(focusElement);
      await harness.element.close();
      expect(document.activeElement).toBe(button);
      button.remove();
    });
  });

  it('should set returnValue during the close event', async () => {
    const {harness} = await setupTest();

    let returnValueDuringClose = '';
    harness.element.addEventListener('close', () => {
      returnValueDuringClose = harness.element.returnValue;
    });

    await harness.element.show();
    const returnValue = 'foo';
    await harness.element.close(returnValue);
    expect(returnValueDuringClose)
      .withContext('dialog.returnValue during close event')
      .toBe(returnValue);
  });

  it('should not change returnValue if close event is canceled', async () => {
    const {harness} = await setupTest();

    harness.element.addEventListener('close', (event) => {
      event.preventDefault();
    });

    await harness.element.show();
    const prevReturnValue = harness.element.returnValue;
    await harness.element.close('new return value');
    expect(harness.element.returnValue)
      .withContext('dialog.returnValue after close event canceled')
      .toBe(prevReturnValue);
  });

  it('should open on connected if opened before connected to DOM', async () => {
    const openListener = jasmine.createSpy('openListener');
    const dialog = document.createElement('md-dialog');
    disableDialogAnimations(dialog);
    dialog.addEventListener('open', openListener);
    dialog.open = true;
    expect(openListener)
      .withContext('should not trigger open before connected')
      .not.toHaveBeenCalled();

    const root = env.render(html``);
    root.appendChild(dialog);
    await env.waitForStability();
    expect(openListener)
      .withContext('opens after connecting')
      .toHaveBeenCalled();
  });

  it('should not open on connected if opened, but closed before connected to DOM', async () => {
    const openListener = jasmine.createSpy('openListener');
    const dialog = document.createElement('md-dialog');
    disableDialogAnimations(dialog);
    dialog.addEventListener('open', openListener);
    dialog.open = true;
    await env.waitForStability();
    dialog.open = false;
    const root = env.render(html``);
    root.appendChild(dialog);
    await env.waitForStability();
    expect(openListener)
      .withContext('should not open on connected since close was called')
      .not.toHaveBeenCalled();
  });

  it('should not open on connected if opened before connection but closed after', async () => {
    const openListener = jasmine.createSpy('openListener');
    const dialog = document.createElement('md-dialog');
    disableDialogAnimations(dialog);
    dialog.addEventListener('open', openListener);
    dialog.open = true;
    const root = env.render(html``);
    root.appendChild(dialog);
    dialog.open = false;
    await env.waitForStability();
    expect(openListener)
      .withContext(
        'should not open on connected since close was called before open could complete',
      )
      .not.toHaveBeenCalled();
  });

  it('should not dispatch close if closed while disconnected', async () => {
    const {harness, root} = await setupTest();
    await harness.element.show();

    const closeListener = jasmine.createSpy('closeListener');
    harness.element.addEventListener('close', closeListener);
    harness.element.remove();
    await env.waitForStability();

    expect(closeListener)
      .withContext('should not trigger close when disconnected')
      .not.toHaveBeenCalled();

    await harness.element.close();
    expect(closeListener)
      .withContext('should not trigger close when disconnected')
      .not.toHaveBeenCalled();

    root.appendChild(harness.element);
    await env.waitForStability();
    expect(closeListener)
      .withContext('should not trigger close when disconnected')
      .not.toHaveBeenCalled();
  });
});

function disableDialogAnimations(dialog: MdDialog) {
  dialog.getOpenAnimation = () => {
    return {};
  };
  dialog.getCloseAnimation = () => {
    return {};
  };
}


/* ========== /internal/_dialog.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-dialog-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-dialog-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $md-sys-color: tokens.md-sys-color-values-light();
  $md-sys-motion: tokens.md-sys-motion-values();
  $tokens: tokens.md-comp-dialog-values();

  :host {
    border-start-start-radius: map.get($tokens, 'container-shape-start-start');
    border-start-end-radius: map.get($tokens, 'container-shape-start-end');
    border-end-end-radius: map.get($tokens, 'container-shape-end-end');
    border-end-start-radius: map.get($tokens, 'container-shape-end-start');
    display: contents;
    margin: auto;
    max-height: min(560px, calc(100% - 48px));
    max-width: min(560px, calc(100% - 48px));
    min-height: 140px;
    min-width: 280px;
    position: fixed;
    height: fit-content;
    width: fit-content;
  }

  dialog {
    background: transparent;
    border: none;
    border-radius: inherit;
    flex-direction: column;
    height: inherit;
    margin: inherit;
    max-height: inherit;
    max-width: inherit;
    min-height: inherit;
    min-width: inherit;
    outline: none;
    overflow: visible;
    padding: 0;
    width: inherit;
  }

  dialog[open] {
    display: flex;
  }

  ::backdrop {
    // Can't use ::backdrop since Firefox does not allow animations on it.
    background: none;
  }

  .scrim {
    background: map.get($md-sys-color, 'scrim');
    display: none;
    inset: 0;
    opacity: 32%;
    pointer-events: none;
    position: fixed;
    z-index: 1;
  }

  :host([open]) .scrim {
    display: flex;
  }

  h2 {
    all: unset;
    align-self: stretch;
  }

  .headline {
    align-items: center;
    color: map.get($tokens, 'headline-color');
    display: flex;
    flex-direction: column;
    font-family: map.get($tokens, 'headline-font');
    font-size: map.get($tokens, 'headline-size');
    line-height: map.get($tokens, 'headline-line-height');
    font-weight: map.get($tokens, 'headline-weight');
    position: relative;
  }

  slot[name='headline']::slotted(*) {
    align-items: center;
    align-self: stretch;
    box-sizing: border-box;
    display: flex;
    gap: 8px;
    padding: 24px 24px 0;
  }

  .icon {
    display: flex;
  }

  slot[name='icon']::slotted(*) {
    color: map.get($tokens, 'icon-color');
    fill: currentColor;
    font-size: map.get($tokens, 'icon-size');
    margin-top: 24px;
    height: map.get($tokens, 'icon-size');
    width: map.get($tokens, 'icon-size');
  }

  .has-icon slot[name='headline']::slotted(*) {
    justify-content: center;
    padding-top: 16px;
  }

  .scrollable slot[name='headline']::slotted(*) {
    padding-bottom: 16px;
  }

  .scrollable.has-headline slot[name='content']::slotted(*) {
    padding-top: 8px;
  }

  .container {
    border-radius: inherit;
    display: flex;
    flex-direction: column;
    // Safari won't show content with "flex: 1", but container needs to grow if
    // height is set on the dialog, so use flex-grow instead.
    flex-grow: 1;
    overflow: hidden;
    position: relative;
    transform-origin: top;
  }

  .container::before {
    background: map.get($tokens, 'container-color');
    border-radius: inherit;
    content: '';
    inset: 0;
    position: absolute;
  }

  .scroller {
    display: flex;
    flex: 1;
    flex-direction: column;
    overflow: hidden;
    // needed to display scrollbars on Chrome linux. Also needs to be > 0 so
    // that content that is position: fixed in the content can render above the
    // actions bar. e.g. <md-select positioning="menu-fixed">
    z-index: 1;
  }

  .scrollable .scroller {
    // Only add scrollbars if the content is overflowing. This prevents extra
    // space from appearing on platforms that reserve scrollbar space.
    // Note: we only scroll vertically. Horizontal scrolling should be handled
    // by the content.
    overflow-y: scroll;
  }

  .content {
    color: map.get($tokens, 'supporting-text-color');
    font-family: map.get($tokens, 'supporting-text-font');
    font-size: map.get($tokens, 'supporting-text-size');
    line-height: map.get($tokens, 'supporting-text-line-height');
    flex: 1;
    font-weight: map.get($tokens, 'supporting-text-weight');
    height: min-content; // Needed for Safari
    position: relative;
  }

  slot[name='content']::slotted(*) {
    box-sizing: border-box;
    padding: 24px;
  }

  // Anchors are used with an IntersectionObserver to determine when the content
  // has scrolled.
  .anchor {
    position: absolute;
  }

  .top.anchor {
    top: 0;
  }

  .bottom.anchor {
    bottom: 0;
  }

  .actions {
    position: relative;
  }

  slot[name='actions']::slotted(*) {
    box-sizing: border-box;
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    padding: 16px 24px 24px;
  }

  .has-actions slot[name='content']::slotted(*) {
    padding-bottom: 8px;
  }

  md-divider {
    display: none;
    position: absolute;
  }

  .has-headline.show-top-divider .headline md-divider,
  .has-actions.show-bottom-divider .actions md-divider {
    display: flex;
  }

  .headline md-divider {
    bottom: 0;
  }

  .actions md-divider {
    top: 0;
  }

  @media (forced-colors: active) {
    dialog {
      outline: 2px solid WindowText;
    }
  }
}


// ========== /internal/animations.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {EASING} from '../../internal/motion/animation.js';

/**
 * A dialog animation's arguments. See `Element.prototype.animate`.
 */
export type DialogAnimationArgs = Parameters<Element['animate']>;

/**
 * A collection of dialog animations. Each element of a dialog may have multiple
 * animations.
 */
export interface DialogAnimation {
  /**
   * Animations for the dialog itself.
   */
  dialog?: DialogAnimationArgs[];

  /**
   * Animations for the scrim backdrop.
   */
  scrim?: DialogAnimationArgs[];

  /**
   * Animations for the container of the dialog.
   */
  container?: DialogAnimationArgs[];

  /**
   * Animations for the headline section.
   */
  headline?: DialogAnimationArgs[];

  /**
   * Animations for the contents section.
   */
  content?: DialogAnimationArgs[];
  /**
   * Animations for the actions section.
   */
  actions?: DialogAnimationArgs[];
}

/**
 * The default dialog open animation.
 */
export const DIALOG_DEFAULT_OPEN_ANIMATION: DialogAnimation = {
  dialog: [
    [
      // Dialog slide down
      [{'transform': 'translateY(-50px)'}, {'transform': 'translateY(0)'}],
      {duration: 500, easing: EASING.EMPHASIZED},
    ],
  ],
  scrim: [
    [
      // Scrim fade in
      [{'opacity': 0}, {'opacity': 0.32}],
      {duration: 500, easing: 'linear'},
    ],
  ],
  container: [
    [
      // Container fade in
      [{'opacity': 0}, {'opacity': 1}],
      {duration: 50, easing: 'linear', pseudoElement: '::before'},
    ],
    [
      // Container grow
      // Note: current spec says to grow from 0dp->100% and shrink from
      // 100%->35%. We change this to 35%->100% to simplify the animation that
      // is supposed to clip content as it grows. From 0dp it's possible to see
      // text/actions appear before the container has fully grown.
      [{'height': '35%'}, {'height': '100%'}],
      {duration: 500, easing: EASING.EMPHASIZED, pseudoElement: '::before'},
    ],
  ],
  headline: [
    [
      // Headline fade in
      [{'opacity': 0}, {'opacity': 0, offset: 0.2}, {'opacity': 1}],
      {duration: 250, easing: 'linear', fill: 'forwards'},
    ],
  ],
  content: [
    [
      // Content fade in
      [{'opacity': 0}, {'opacity': 0, offset: 0.2}, {'opacity': 1}],
      {duration: 250, easing: 'linear', fill: 'forwards'},
    ],
  ],
  actions: [
    [
      // Actions fade in
      [{'opacity': 0}, {'opacity': 0, offset: 0.5}, {'opacity': 1}],
      {duration: 300, easing: 'linear', fill: 'forwards'},
    ],
  ],
};

/**
 * The default dialog close animation.
 */
export const DIALOG_DEFAULT_CLOSE_ANIMATION: DialogAnimation = {
  dialog: [
    [
      // Dialog slide up
      [{'transform': 'translateY(0)'}, {'transform': 'translateY(-50px)'}],
      {duration: 150, easing: EASING.EMPHASIZED_ACCELERATE},
    ],
  ],
  scrim: [
    [
      // Scrim fade out
      [{'opacity': 0.32}, {'opacity': 0}],
      {duration: 150, easing: 'linear'},
    ],
  ],
  container: [
    [
      // Container shrink
      [{'height': '100%'}, {'height': '35%'}],
      {
        duration: 150,
        easing: EASING.EMPHASIZED_ACCELERATE,
        pseudoElement: '::before',
      },
    ],
    [
      // Container fade out
      [{'opacity': '1'}, {'opacity': '0'}],
      {delay: 100, duration: 50, easing: 'linear', pseudoElement: '::before'},
    ],
  ],
  headline: [
    [
      // Headline fade out
      [{'opacity': 1}, {'opacity': 0}],
      {duration: 100, easing: 'linear', fill: 'forwards'},
    ],
  ],
  content: [
    [
      // Content fade out
      [{'opacity': 1}, {'opacity': 0}],
      {duration: 100, easing: 'linear', fill: 'forwards'},
    ],
  ],
  actions: [
    [
      // Actions fade out
      [{'opacity': 1}, {'opacity': 0}],
      {duration: 100, easing: 'linear', fill: 'forwards'},
    ],
  ],
};


/* ========== /internal/dialog-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './dialog';
// go/keep-sorted end

@include dialog.styles;


// ========== /internal/dialog.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../divider/divider.js';

import {html, isServer, LitElement, nothing} from 'lit';
import {property, query, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';

import {
  DIALOG_DEFAULT_CLOSE_ANIMATION,
  DIALOG_DEFAULT_OPEN_ANIMATION,
  DialogAnimation,
  DialogAnimationArgs,
} from './animations.js';

// Separate variable needed for closure.
const dialogBaseClass = mixinDelegatesAria(LitElement);

/**
 * A dialog component.
 *
 * @fires open {Event} Dispatched when the dialog is opening before any animations.
 * @fires opened {Event} Dispatched when the dialog has opened after any animations.
 * @fires close {Event} Dispatched when the dialog is closing before any animations.
 * @fires closed {Event} Dispatched when the dialog has closed after any animations.
 * @fires cancel {Event} Dispatched when the dialog has been canceled by clicking
 * on the scrim or pressing Escape.
 */
export class Dialog extends dialogBaseClass {
  // We do not use `delegatesFocus: true` due to a Chromium bug with
  // selecting text.
  // See https://bugs.chromium.org/p/chromium/issues/detail?id=950357

  /**
   * Opens the dialog when set to `true` and closes it when set to `false`.
   */
  @property({type: Boolean})
  get open() {
    return this.isOpen;
  }

  set open(open: boolean) {
    if (open === this.isOpen) {
      return;
    }

    this.isOpen = open;
    if (open) {
      this.setAttribute('open', '');
      this.show();
    } else {
      this.removeAttribute('open');
      this.close();
    }
  }

  /**
   * Skips the opening and closing animations.
   */
  @property({type: Boolean}) quick = false;

  /**
   * Gets or sets the dialog's return value, usually to indicate which button
   * a user pressed to close it.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/returnValue
   */
  @property({attribute: false}) returnValue = '';

  /**
   * The type of dialog for accessibility. Set this to `alert` to announce a
   * dialog as an alert dialog.
   */
  @property() type?: 'alert';

  /**
   * Disables focus trapping, which by default keeps keyboard Tab navigation
   * within the dialog.
   *
   * When disabled, after focusing the last element of a dialog, pressing Tab
   * again will release focus from the window back to the browser (such as the
   * URL bar).
   *
   * Focus trapping is recommended for accessibility, and should not typically
   * be disabled. Only turn this off if the use case of a dialog is more
   * accessible without focus trapping.
   */
  @property({type: Boolean, attribute: 'no-focus-trap'})
  noFocusTrap = false;

  /**
   * Gets the opening animation for a dialog. Set to a new function to customize
   * the animation.
   */
  getOpenAnimation = () => DIALOG_DEFAULT_OPEN_ANIMATION;

  /**
   * Gets the closing animation for a dialog. Set to a new function to customize
   * the animation.
   */
  getCloseAnimation = () => DIALOG_DEFAULT_CLOSE_ANIMATION;

  private isOpen = false;
  private isOpening = false;
  // getIsConnectedPromise() immediately sets the resolve property.
  private isConnectedPromiseResolve!: () => void;
  private isConnectedPromise = this.getIsConnectedPromise();
  @query('dialog') private readonly dialog!: HTMLDialogElement | null;
  @query('.scrim') private readonly scrim!: HTMLDialogElement | null;
  @query('.container') private readonly container!: HTMLDialogElement | null;
  @query('.headline') private readonly headline!: HTMLDialogElement | null;
  @query('.content') private readonly content!: HTMLDialogElement | null;
  @query('.actions') private readonly actions!: HTMLDialogElement | null;
  @state() private isAtScrollTop = false;
  @state() private isAtScrollBottom = false;
  @query('.scroller') private readonly scroller!: HTMLElement | null;
  @query('.top.anchor') private readonly topAnchor!: HTMLElement | null;
  @query('.bottom.anchor') private readonly bottomAnchor!: HTMLElement | null;
  @query('.focus-trap')
  private readonly firstFocusTrap!: HTMLElement | null;
  private nextClickIsFromContent = false;
  private intersectionObserver?: IntersectionObserver;
  // Dialogs should not be SSR'd while open, so we can just use runtime checks.
  @state() private hasHeadline = false;
  @state() private hasActions = false;
  @state() private hasIcon = false;
  private cancelAnimations?: AbortController;

  // See https://bugs.chromium.org/p/chromium/issues/detail?id=1512224
  // Chrome v120 has a bug where escape keys do not trigger cancels. If we get
  // a dialog "close" event that is triggered without a "cancel" after an escape
  // keydown, then we need to manually trigger our closing logic.
  //
  // This bug occurs when pressing escape to close a dialog without first
  // interacting with the dialog's content.
  //
  // Cleanup tracking:
  // https://github.com/material-components/material-web/issues/5330
  // This can be removed when full CloseWatcher support added and the above bug
  // in Chromium is fixed to fire 'cancel' with one escape press and close with
  // multiple.
  private escapePressedWithoutCancel = false;
  // This TreeWalker is used to walk through a dialog's children to find
  // focusable elements. TreeWalker is faster than `querySelectorAll('*')`.
  // We check for isServer because there isn't a "document" during an SSR
  // run.
  private readonly treewalker = isServer
    ? null
    : document.createTreeWalker(this, NodeFilter.SHOW_ELEMENT);

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('submit', this.handleSubmit);
    }
  }

  /**
   * Opens the dialog and fires a cancelable `open` event. After a dialog's
   * animation, an `opened` event is fired.
   *
   * Add an `autofocus` attribute to a child of the dialog that should
   * receive focus after opening.
   *
   * @return A Promise that resolves after the animation is finished and the
   *     `opened` event was fired.
   */
  async show() {
    this.isOpening = true;
    // Dialogs can be opened before being attached to the DOM, so we need to
    // wait until we're connected before calling `showModal()`.
    await this.isConnectedPromise;
    await this.updateComplete;
    const dialog = this.dialog!;
    // Check if already opened or if `dialog.close()` was called while awaiting.
    if (dialog.open || !this.isOpening) {
      this.isOpening = false;
      return;
    }

    const preventOpen = !this.dispatchEvent(
      new Event('open', {cancelable: true}),
    );
    if (preventOpen) {
      this.open = false;
      this.isOpening = false;
      return;
    }

    // All Material dialogs are modal.
    dialog.showModal();
    this.open = true;
    // Reset scroll position if re-opening a dialog with the same content.
    if (this.scroller) {
      this.scroller.scrollTop = 0;
    }
    // Native modal dialogs ignore autofocus and instead force focus to the
    // first focusable child. Override this behavior if there is a child with
    // an autofocus attribute.
    this.querySelector<HTMLElement>('[autofocus]')?.focus();

    await this.animateDialog(this.getOpenAnimation());
    this.dispatchEvent(new Event('opened'));
    this.isOpening = false;
  }

  /**
   * Closes the dialog and fires a cancelable `close` event. After a dialog's
   * animation, a `closed` event is fired.
   *
   * @param returnValue A return value usually indicating which button was used
   *     to close a dialog. If a dialog is canceled by clicking the scrim or
   *     pressing Escape, it will not change the return value after closing.
   * @return A Promise that resolves after the animation is finished and the
   *     `closed` event was fired.
   */
  async close(returnValue = this.returnValue) {
    this.isOpening = false;
    if (!this.isConnected) {
      // Disconnected dialogs do not fire close events or animate.
      this.open = false;
      return;
    }

    await this.updateComplete;
    const dialog = this.dialog!;
    // Check if already closed or if `dialog.show()` was called while awaiting.
    if (!dialog.open || this.isOpening) {
      this.open = false;
      return;
    }

    const prevReturnValue = this.returnValue;
    this.returnValue = returnValue;
    const preventClose = !this.dispatchEvent(
      new Event('close', {cancelable: true}),
    );
    if (preventClose) {
      this.returnValue = prevReturnValue;
      return;
    }

    await this.animateDialog(this.getCloseAnimation());
    dialog.close(returnValue);
    this.open = false;
    this.dispatchEvent(new Event('closed'));
  }

  override connectedCallback() {
    super.connectedCallback();
    this.isConnectedPromiseResolve();
  }

  override disconnectedCallback() {
    super.disconnectedCallback();
    this.isConnectedPromise = this.getIsConnectedPromise();
  }

  protected override render() {
    const scrollable =
      this.open && !(this.isAtScrollTop && this.isAtScrollBottom);
    const classes = {
      'has-headline': this.hasHeadline,
      'has-actions': this.hasActions,
      'has-icon': this.hasIcon,
      'scrollable': scrollable,
      'show-top-divider': scrollable && !this.isAtScrollTop,
      'show-bottom-divider': scrollable && !this.isAtScrollBottom,
    };

    // The focus trap sentinels are only added after the dialog opens, since
    // dialog.showModal() will try to autofocus them, even with tabindex="-1".
    const showFocusTrap = this.open && !this.noFocusTrap;
    const focusTrap = html`
      <div
        class="focus-trap"
        tabindex="0"
        aria-hidden="true"
        @focus=${this.handleFocusTrapFocus}></div>
    `;

    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <div class="scrim"></div>
      <dialog
        class=${classMap(classes)}
        aria-label=${ariaLabel || nothing}
        aria-labelledby=${this.hasHeadline ? 'headline' : nothing}
        role=${this.type === 'alert' ? 'alertdialog' : nothing}
        @cancel=${this.handleCancel}
        @click=${this.handleDialogClick}
        @close=${this.handleClose}
        @keydown=${this.handleKeydown}
        .returnValue=${this.returnValue || nothing}>
        ${showFocusTrap ? focusTrap : nothing}
        <div class="container" @click=${this.handleContentClick}>
          <div class="headline">
            <div class="icon" aria-hidden="true">
              <slot name="icon" @slotchange=${this.handleIconChange}></slot>
            </div>
            <h2 id="headline" aria-hidden=${!this.hasHeadline || nothing}>
              <slot
                name="headline"
                @slotchange=${this.handleHeadlineChange}></slot>
            </h2>
            <md-divider></md-divider>
          </div>
          <div class="scroller">
            <div class="content">
              <div class="top anchor"></div>
              <slot name="content"></slot>
              <div class="bottom anchor"></div>
            </div>
          </div>
          <div class="actions">
            <md-divider></md-divider>
            <slot name="actions" @slotchange=${this.handleActionsChange}></slot>
          </div>
        </div>
        ${showFocusTrap ? focusTrap : nothing}
      </dialog>
    `;
  }

  protected override firstUpdated() {
    this.intersectionObserver = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          this.handleAnchorIntersection(entry);
        }
      },
      {root: this.scroller!},
    );

    this.intersectionObserver.observe(this.topAnchor!);
    this.intersectionObserver.observe(this.bottomAnchor!);
  }

  private handleDialogClick() {
    if (this.nextClickIsFromContent) {
      // Avoid doing a layout calculation below if we know the click came from
      // content.
      this.nextClickIsFromContent = false;
      return;
    }

    // Click originated on the backdrop. Native `<dialog>`s will not cancel,
    // but Material dialogs do.
    const preventDefault = !this.dispatchEvent(
      new Event('cancel', {cancelable: true}),
    );
    if (preventDefault) {
      return;
    }

    this.close();
  }

  private handleContentClick() {
    this.nextClickIsFromContent = true;
  }

  private handleSubmit(event: SubmitEvent) {
    const form = event.target as HTMLFormElement;
    const {submitter} = event;
    if (form.getAttribute('method') !== 'dialog' || !submitter) {
      return;
    }

    // Close reason is the submitter's value attribute, or the dialog's
    // `returnValue` if there is no attribute.
    this.close(submitter.getAttribute('value') ?? this.returnValue);
  }

  private handleCancel(event: Event) {
    if (event.target !== this.dialog) {
      // Ignore any cancel events dispatched by content.
      return;
    }

    this.escapePressedWithoutCancel = false;
    const preventDefault = !redispatchEvent(this, event);
    // We always prevent default on the original dialog event since we'll
    // animate closing it before it actually closes.
    event.preventDefault();
    if (preventDefault) {
      return;
    }

    this.close();
  }

  private handleClose() {
    if (!this.escapePressedWithoutCancel) {
      return;
    }

    this.escapePressedWithoutCancel = false;
    this.dialog?.dispatchEvent(new Event('cancel', {cancelable: true}));
  }

  private handleKeydown(event: KeyboardEvent) {
    if (event.key !== 'Escape') {
      return;
    }

    // An escape key was pressed. If a "close" event fires next without a
    // "cancel" event first, then we know we're in the Chrome v120 bug.
    this.escapePressedWithoutCancel = true;
    // Wait a full task for the cancel/close event listeners to fire, then
    // reset the flag.
    setTimeout(() => {
      this.escapePressedWithoutCancel = false;
    });
  }

  private async animateDialog(animation: DialogAnimation) {
    // Always cancel the previous animations. Animations can include `fill`
    // modes that need to be cleared when `quick` is toggled. If not, content
    // that faded out will remain hidden when a `quick` dialog re-opens after
    // previously opening and closing without `quick`.
    this.cancelAnimations?.abort();
    this.cancelAnimations = new AbortController();
    if (this.quick) {
      return;
    }

    const {dialog, scrim, container, headline, content, actions} = this;
    if (!dialog || !scrim || !container || !headline || !content || !actions) {
      return;
    }

    const {
      container: containerAnimate,
      dialog: dialogAnimate,
      scrim: scrimAnimate,
      headline: headlineAnimate,
      content: contentAnimate,
      actions: actionsAnimate,
    } = animation;

    const elementAndAnimation: Array<[Element, DialogAnimationArgs[]]> = [
      [dialog, dialogAnimate ?? []],
      [scrim, scrimAnimate ?? []],
      [container, containerAnimate ?? []],
      [headline, headlineAnimate ?? []],
      [content, contentAnimate ?? []],
      [actions, actionsAnimate ?? []],
    ];

    const animations: Animation[] = [];
    for (const [element, animation] of elementAndAnimation) {
      for (const animateArgs of animation) {
        const animation = element.animate(...animateArgs);
        this.cancelAnimations.signal.addEventListener('abort', () => {
          animation.cancel();
        });

        animations.push(animation);
      }
    }

    await Promise.all(
      animations.map((animation) =>
        animation.finished.catch(() => {
          // Ignore intentional AbortErrors when calling `animation.cancel()`.
        }),
      ),
    );
  }

  private handleHeadlineChange(event: Event) {
    const slot = event.target as HTMLSlotElement;
    this.hasHeadline = slot.assignedElements().length > 0;
  }

  private handleActionsChange(event: Event) {
    const slot = event.target as HTMLSlotElement;
    this.hasActions = slot.assignedElements().length > 0;
  }

  private handleIconChange(event: Event) {
    const slot = event.target as HTMLSlotElement;
    this.hasIcon = slot.assignedElements().length > 0;
  }

  private handleAnchorIntersection(entry: IntersectionObserverEntry) {
    const {target, isIntersecting} = entry;
    if (target === this.topAnchor) {
      this.isAtScrollTop = isIntersecting;
    }

    if (target === this.bottomAnchor) {
      this.isAtScrollBottom = isIntersecting;
    }
  }

  private getIsConnectedPromise() {
    return new Promise<void>((resolve) => {
      this.isConnectedPromiseResolve = resolve;
    });
  }

  private handleFocusTrapFocus(event: FocusEvent) {
    const [firstFocusableChild, lastFocusableChild] =
      this.getFirstAndLastFocusableChildren();
    if (!firstFocusableChild || !lastFocusableChild) {
      // When a dialog does not have focusable children, the dialog itself
      // receives focus.
      this.dialog?.focus();
      return;
    }

    // To determine which child to focus, we need to know which focus trap
    // received focus...
    const isFirstFocusTrap = event.target === this.firstFocusTrap;
    const isLastFocusTrap = !isFirstFocusTrap;
    // ...and where the focus came from (what was previously focused).
    const focusCameFromFirstChild = event.relatedTarget === firstFocusableChild;
    const focusCameFromLastChild = event.relatedTarget === lastFocusableChild;
    // Although this is a focus trap, focus can come from outside the trap.
    // This can happen when elements are programmatically `focus()`'d. It also
    // happens when focus leaves and returns to the window, such as clicking on
    // the browser's URL bar and pressing Tab, or switching focus between
    // iframes.
    const focusCameFromOutsideDialog =
      !focusCameFromFirstChild && !focusCameFromLastChild;

    // Focus the dialog's first child when we reach the end of the dialog and
    // focus is moving forward. Or, when focus is moving forwards into the
    // dialog from outside of the window.
    const shouldFocusFirstChild =
      (isLastFocusTrap && focusCameFromLastChild) ||
      (isFirstFocusTrap && focusCameFromOutsideDialog);
    if (shouldFocusFirstChild) {
      firstFocusableChild.focus();
      return;
    }

    // Focus the dialog's last child when we reach the beginning of the dialog
    // and focus is moving backward. Or, when focus is moving backwards into the
    // dialog from outside of the window.
    const shouldFocusLastChild =
      (isFirstFocusTrap && focusCameFromFirstChild) ||
      (isLastFocusTrap && focusCameFromOutsideDialog);
    if (shouldFocusLastChild) {
      lastFocusableChild.focus();
      return;
    }

    // The booleans above are verbose for readability, but code executation
    // won't actually reach here.
  }

  private getFirstAndLastFocusableChildren():
    | [HTMLElement, HTMLElement]
    | [null, null] {
    if (!this.treewalker) {
      return [null, null];
    }

    let firstFocusableChild: HTMLElement | null = null;
    let lastFocusableChild: HTMLElement | null = null;

    // Reset the current node back to the root host element.
    this.treewalker.currentNode = this.treewalker.root;
    while (this.treewalker.nextNode()) {
      // Cast as Element since the TreeWalker filter only accepts Elements.
      const nextChild = this.treewalker.currentNode as Element;
      if (!isFocusable(nextChild)) {
        continue;
      }

      if (!firstFocusableChild) {
        firstFocusableChild = nextChild;
      }

      lastFocusableChild = nextChild;
    }

    // We set lastFocusableChild immediately after finding a
    // firstFocusableChild, which means the pair is either both null or both
    // non-null. Cast since TypeScript does not recognize this.
    return [firstFocusableChild, lastFocusableChild] as
      | [HTMLElement, HTMLElement]
      | [null, null];
  }
}

function isFocusable(element: Element): element is HTMLElement {
  // Check if the element is a known built-in focusable element:
  // - <a> and <area> with `href` attributes.
  // - Form controls that are not disabled.
  // - `contenteditable` elements.
  // - Anything with a non-negative `tabindex`.
  const knownFocusableElements =
    ':is(button,input,select,textarea,object,:is(a,area)[href],[tabindex],[contenteditable=true])';
  const notDisabled = ':not(:disabled,[disabled])';
  const notNegativeTabIndex = ':not([tabindex^="-"])';
  if (
    element.matches(knownFocusableElements + notDisabled + notNegativeTabIndex)
  ) {
    return true;
  }

  const isCustomElement = element.localName.includes('-');
  if (!isCustomElement) {
    return false;
  }

  // If a custom element does not have a tabindex, it may still be focusable
  // if it delegates focus with a shadow root. We also need to check again if
  // the custom element is a disabled form control.
  if (!element.matches(notDisabled)) {
    return false;
  }

  return element.shadowRoot?.delegatesFocus ?? false;
}