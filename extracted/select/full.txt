/* ========== /_filled-select.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-select' show theme;


/* ========== /_outlined-select.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/outlined-select' show theme;


// ========== /filled-select.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {FilledSelect} from './internal/filled-select.js';
import {styles} from './internal/filled-select-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-select': MdFilledSelect;
  }
}

/**
 * @summary
 * Select menus display a list of choices on temporary surfaces and display the
 * currently selected menu item above the menu.
 *
 * @description
 * The select component allows users to choose a value from a fixed list of
 * available options. Composed of an interactive anchor button and a menu, it is
 * analogous to the native HTML `<select>` element. This is the "filled"
 * variant.
 *
 * @example
 * ```html
 * <md-filled-select label="fruits">
 *   <!-- An empty selected option will give select an "un-filled" state -->
 *   <md-select-option selected></md-select-option>
 *   <md-select-option value="apple" headline="Apple"></md-select-option>
 *   <md-select-option value="banana" headline="Banana"></md-select-option>
 *   <md-select-option value="kiwi" headline="Kiwi"></md-select-option>
 *   <md-select-option value="orange" headline="Orange"></md-select-option>
 *   <md-select-option value="tomato" headline="Tomato"></md-select-option>
 * </md-filled-select>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-select')
export class MdFilledSelect extends FilledSelect {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];
}


/* ========== /internal/_filled-select.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
// go/keep-sorted end
// go/keep-sorted start
@use '../../field/filled-field';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filled-select-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $token ==
      'text-field-container-shape' and
      meta.type-of($value) ==
      'list'
    {
      @error 'Filled select `text-field-container-shape` may not be specified as a list. Use logical (`*-start-start`) tokens instead.';
    }

    @if $value {
      --md-filled-select-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-select-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'text-field-container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    @include filled-field.theme(
      (
        // go/keep-sorted start
        'active-indicator-color': var(--_text-field-active-indicator-color),
        'active-indicator-height': var(--_text-field-active-indicator-height),
        'container-color': var(--_text-field-container-color),
        'container-shape-end-end': var(--_text-field-container-shape-end-end),
        'container-shape-end-start':
          var(--_text-field-container-shape-end-start),
        'container-shape-start-end':
          var(--_text-field-container-shape-start-end),
        'container-shape-start-start':
          var(--_text-field-container-shape-start-start),
        'content-color': var(--_text-field-input-text-color),
        'content-font': var(--_text-field-input-text-font),
        'content-line-height': var(--_text-field-input-text-line-height),
        'content-size': var(--_text-field-input-text-size),
        'content-weight': var(--_text-field-input-text-weight),
        'disabled-active-indicator-color':
          var(--_text-field-disabled-active-indicator-color),
        'disabled-active-indicator-height':
          var(--_text-field-disabled-active-indicator-height),
        'disabled-active-indicator-opacity':
          var(--_text-field-disabled-active-indicator-opacity),
        'disabled-container-color': var(--_text-field-disabled-container-color),
        'disabled-container-opacity':
          var(--_text-field-disabled-container-opacity),
        'disabled-content-color': var(--_text-field-disabled-input-text-color),
        'disabled-content-opacity':
          var(--_text-field-disabled-input-text-opacity),
        'disabled-label-text-color':
          var(--_text-field-disabled-label-text-color),
        'disabled-label-text-opacity':
          var(--_text-field-disabled-label-text-opacity),
        'disabled-leading-content-color':
          var(--_text-field-disabled-leading-icon-color),
        'disabled-leading-content-opacity':
          var(--_text-field-disabled-leading-icon-opacity),
        'disabled-supporting-text-color':
          var(--_text-field-disabled-supporting-text-color),
        'disabled-supporting-text-opacity':
          var(--_text-field-disabled-supporting-text-opacity),
        'disabled-trailing-content-color':
          var(--_text-field-disabled-trailing-icon-color),
        'disabled-trailing-content-opacity':
          var(--_text-field-disabled-trailing-icon-opacity),
        'error-active-indicator-color':
          var(--_text-field-error-active-indicator-color),
        'error-content-color': var(--_text-field-error-input-text-color),
        'error-focus-active-indicator-color':
          var(--_text-field-error-focus-active-indicator-color),
        'error-focus-content-color':
          var(--_text-field-error-focus-input-text-color),
        'error-focus-label-text-color':
          var(--_text-field-error-focus-label-text-color),
        'error-focus-leading-content-color':
          var(--_text-field-error-focus-leading-icon-color),
        'error-focus-supporting-text-color':
          var(--_text-field-error-focus-supporting-text-color),
        'error-focus-trailing-content-color':
          var(--_text-field-error-focus-trailing-icon-color),
        'error-hover-active-indicator-color':
          var(--_text-field-error-hover-active-indicator-color),
        'error-hover-content-color':
          var(--_text-field-error-hover-input-text-color),
        'error-hover-label-text-color':
          var(--_text-field-error-hover-label-text-color),
        'error-hover-leading-content-color':
          var(--_text-field-error-hover-leading-icon-color),
        'error-hover-state-layer-color':
          var(--_text-field-error-hover-state-layer-color),
        'error-hover-state-layer-opacity':
          var(--_text-field-error-hover-state-layer-opacity),
        'error-hover-supporting-text-color':
          var(--_text-field-error-hover-supporting-text-color),
        'error-hover-trailing-content-color':
          var(--_text-field-error-hover-trailing-icon-color),
        'error-label-text-color': var(--_text-field-error-label-text-color),
        'error-leading-content-color':
          var(--_text-field-error-leading-icon-color),
        'error-supporting-text-color':
          var(--_text-field-error-supporting-text-color),
        'error-trailing-content-color':
          var(--_text-field-error-trailing-icon-color),
        'focus-active-indicator-color':
          var(--_text-field-focus-active-indicator-color),
        'focus-active-indicator-height':
          var(--_text-field-focus-active-indicator-height),
        'focus-content-color': var(--_text-field-focus-input-text-color),
        'focus-label-text-color': var(--_text-field-focus-label-text-color),
        'focus-leading-content-color':
          var(--_text-field-focus-leading-icon-color),
        'focus-supporting-text-color':
          var(--_text-field-focus-supporting-text-color),
        'focus-trailing-content-color':
          var(--_text-field-focus-trailing-icon-color),
        'hover-active-indicator-color':
          var(--_text-field-hover-active-indicator-color),
        'hover-active-indicator-height':
          var(--_text-field-hover-active-indicator-height),
        'hover-content-color': var(--_text-field-hover-input-text-color),
        'hover-label-text-color': var(--_text-field-hover-label-text-color),
        'hover-leading-content-color':
          var(--_text-field-hover-leading-icon-color),
        'hover-state-layer-color': var(--_text-field-hover-state-layer-color),
        'hover-state-layer-opacity':
          var(--_text-field-hover-state-layer-opacity),
        'hover-supporting-text-color':
          var(--_text-field-hover-supporting-text-color),
        'hover-trailing-content-color':
          var(--_text-field-hover-trailing-icon-color),
        'label-text-color': var(--_text-field-label-text-color),
        'label-text-font': var(--_text-field-label-text-font),
        'label-text-line-height': var(--_text-field-label-text-line-height),
        'label-text-populated-line-height':
          var(--_text-field-label-text-populated-line-height),
        'label-text-populated-size':
          var(--_text-field-label-text-populated-size),
        'label-text-size': var(--_text-field-label-text-size),
        'label-text-weight': var(--_text-field-label-text-weight),
        'leading-content-color': var(--_text-field-leading-icon-color),
        'supporting-text-color': var(--_text-field-supporting-text-color),
        'supporting-text-font': var(--_text-field-supporting-text-font),
        'supporting-text-line-height':
          var(--_text-field-supporting-text-line-height),
        'supporting-text-size': var(--_text-field-supporting-text-size),
        'supporting-text-weight': var(--_text-field-supporting-text-weight),
        'trailing-content-color': var(--_text-field-trailing-icon-color),
        // go/keep-sorted end
      )
    );
  }

  [has-start] .icon.leading {
    font-size: var(--_text-field-leading-icon-size);
    height: var(--_text-field-leading-icon-size);
    width: var(--_text-field-leading-icon-size);
  }

  .icon.trailing {
    font-size: var(--_text-field-trailing-icon-size);
    height: var(--_text-field-trailing-icon-size);
    width: var(--_text-field-trailing-icon-size);
  }
}


/* ========== /internal/_outlined-select.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
// go/keep-sorted end
// go/keep-sorted start
@use '../../field/outlined-field';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-outlined-select-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-select-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-select-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'text-field-container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    @include outlined-field.theme(
      (
        // go/keep-sorted start
        'container-shape-end-end': var(--_text-field-container-shape-end-end),
        'container-shape-end-start':
          var(--_text-field-container-shape-end-start),
        'container-shape-start-end':
          var(--_text-field-container-shape-start-end),
        'container-shape-start-start':
          var(--_text-field-container-shape-start-start),
        'content-color': var(--_text-field-input-text-color),
        'content-font': var(--_text-field-input-text-font),
        'content-line-height': var(--_text-field-input-text-line-height),
        'content-size': var(--_text-field-input-text-size),
        'content-weight': var(--_text-field-input-text-weight),
        'disabled-content-color': var(--_text-field-disabled-input-text-color),
        'disabled-content-opacity':
          var(--_text-field-disabled-input-text-opacity),
        'disabled-label-text-color':
          var(--_text-field-disabled-label-text-color),
        'disabled-label-text-opacity':
          var(--_text-field-disabled-label-text-opacity),
        'disabled-leading-content-color':
          var(--_text-field-disabled-leading-icon-color),
        'disabled-leading-content-opacity':
          var(--_text-field-disabled-leading-icon-opacity),
        'disabled-outline-color': var(--_text-field-disabled-outline-color),
        'disabled-outline-opacity': var(--_text-field-disabled-outline-opacity),
        'disabled-outline-width': var(--_text-field-disabled-outline-width),
        'disabled-supporting-text-color':
          var(--_text-field-disabled-supporting-text-color),
        'disabled-supporting-text-opacity':
          var(--_text-field-disabled-supporting-text-opacity),
        'disabled-trailing-content-color':
          var(--_text-field-disabled-trailing-icon-color),
        'disabled-trailing-content-opacity':
          var(--_text-field-disabled-trailing-icon-opacity),
        'error-content-color': var(--_text-field-error-input-text-color),
        'error-focus-content-color':
          var(--_text-field-error-focus-input-text-color),
        'error-focus-label-text-color':
          var(--_text-field-error-focus-label-text-color),
        'error-focus-leading-content-color':
          var(--_text-field-error-focus-leading-icon-color),
        'error-focus-outline-color':
          var(--_text-field-error-focus-outline-color),
        'error-focus-supporting-text-color':
          var(--_text-field-error-focus-supporting-text-color),
        'error-focus-trailing-content-color':
          var(--_text-field-error-focus-trailing-icon-color),
        'error-hover-content-color':
          var(--_text-field-error-hover-input-text-color),
        'error-hover-label-text-color':
          var(--_text-field-error-hover-label-text-color),
        'error-hover-leading-content-color':
          var(--_text-field-error-hover-leading-icon-color),
        'error-hover-outline-color':
          var(--_text-field-error-hover-outline-color),
        'error-hover-supporting-text-color':
          var(--_text-field-error-hover-supporting-text-color),
        'error-hover-trailing-content-color':
          var(--_text-field-error-hover-trailing-icon-color),
        'error-label-text-color': var(--_text-field-error-label-text-color),
        'error-leading-content-color':
          var(--_text-field-error-leading-icon-color),
        'error-outline-color': var(--_text-field-error-outline-color),
        'error-supporting-text-color':
          var(--_text-field-error-supporting-text-color),
        'error-trailing-content-color':
          var(--_text-field-error-trailing-icon-color),
        'focus-content-color': var(--_text-field-focus-input-text-color),
        'focus-label-text-color': var(--_text-field-focus-label-text-color),
        'focus-leading-content-color':
          var(--_text-field-focus-leading-icon-color),
        'focus-outline-color': var(--_text-field-focus-outline-color),
        'focus-outline-width': var(--_text-field-focus-outline-width),
        'focus-supporting-text-color':
          var(--_text-field-focus-supporting-text-color),
        'focus-trailing-content-color':
          var(--_text-field-focus-trailing-icon-color),
        'hover-content-color': var(--_text-field-hover-input-text-color),
        'hover-label-text-color': var(--_text-field-hover-label-text-color),
        'hover-leading-content-color':
          var(--_text-field-hover-leading-icon-color),
        'hover-outline-color': var(--_text-field-hover-outline-color),
        'hover-outline-width': var(--_text-field-hover-outline-width),
        'hover-supporting-text-color':
          var(--_text-field-hover-supporting-text-color),
        'hover-trailing-content-color':
          var(--_text-field-hover-trailing-icon-color),
        'label-text-color': var(--_text-field-label-text-color),
        'label-text-font': var(--_text-field-label-text-font),
        'label-text-line-height': var(--_text-field-label-text-line-height),
        'label-text-populated-line-height':
          var(--_text-field-label-text-populated-line-height),
        'label-text-populated-size':
          var(--_text-field-label-text-populated-size),
        'label-text-size': var(--_text-field-label-text-size),
        'label-text-weight': var(--_text-field-label-text-weight),
        'leading-content-color': var(--_text-field-leading-icon-color),
        'outline-color': var(--_text-field-outline-color),
        'outline-width': var(--_text-field-outline-width),
        'supporting-text-color': var(--_text-field-supporting-text-color),
        'supporting-text-font': var(--_text-field-supporting-text-font),
        'supporting-text-line-height':
          var(--_text-field-supporting-text-line-height),
        'supporting-text-size': var(--_text-field-supporting-text-size),
        'supporting-text-weight': var(--_text-field-supporting-text-weight),
        'trailing-content-color': var(--_text-field-trailing-icon-color),
        // go/keep-sorted end
      )
    );
  }

  [has-start] .icon.leading {
    font-size: var(--_text-field-leading-icon-size);
    height: var(--_text-field-leading-icon-size);
    width: var(--_text-field-leading-icon-size);
  }

  .icon.trailing {
    font-size: var(--_text-field-trailing-icon-size);
    height: var(--_text-field-trailing-icon-size);
    width: var(--_text-field-trailing-icon-size);
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/internal/elevation';
@use '../../tokens';
// go/keep-sorted end

@mixin styles() {
  :host {
    color: unset;
    min-width: 210px;
    display: flex;
  }

  .field {
    cursor: default;
    outline: none;
  }

  .select {
    position: relative;
    flex-direction: column;
  }

  .icon.trailing svg,
  .icon ::slotted(*) {
    fill: currentColor;
  }

  .icon ::slotted(*) {
    width: inherit;
    height: inherit;
    font-size: inherit;
  }

  .icon slot {
    display: flex;
    height: 100%;
    width: 100%;
    align-items: center;
    justify-content: center;
  }

  .icon.trailing :is(.up, .down) {
    opacity: 0;
    /* 75 ms is half of min(animate open duration, animate closed duration)*/
    transition: opacity 75ms linear 75ms;
  }

  .select:not(.open) .down,
  .select.open .up {
    opacity: 1;
  }

  .field,
  .select,
  md-menu {
    min-width: inherit;
    width: inherit;
    max-width: inherit;
    display: flex;
  }

  md-menu {
    // Not inherited because it is applied every time the menu opens
    min-width: var(--__menu-min-width);
    // Inherits from `.menu-wrapper` because it is applied only when
    // `clampMenuWidth` is true
    max-width: var(--__menu-max-width, inherit);
  }

  .menu-wrapper {
    width: 0px;
    height: 0px;
    max-width: inherit;
  }

  md-menu ::slotted(:not[disabled]) {
    cursor: pointer;
  }

  .field,
  .select {
    width: 100%;
  }

  :host {
    display: inline-flex;
  }

  :host([disabled]) {
    pointer-events: none;
  }
}


/* ========== /internal/filled-select-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filled-select';
// go/keep-sorted end

@include filled-select.styles();


// ========== /internal/filled-select.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../field/filled-field.js';

import {literal} from 'lit/static-html.js';

import {Select} from './select.js';

// tslint:disable-next-line:enforce-comments-on-exported-symbols
export abstract class FilledSelect extends Select {
  protected readonly fieldTag = literal`md-filled-field`;
}


/* ========== /internal/outlined-select-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-select';
// go/keep-sorted end

@include outlined-select.styles();


// ========== /internal/outlined-select.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../field/outlined-field.js';

import {literal} from 'lit/static-html.js';

import {Select} from './select.js';

// tslint:disable-next-line:enforce-comments-on-exported-symbols
export abstract class OutlinedSelect extends Select {
  protected readonly fieldTag = literal`md-outlined-field`;
}


// ========== /internal/select.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../menu/menu.js';

import {html, isServer, LitElement, nothing, PropertyValues} from 'lit';
import {property, query, queryAssignedElements, state} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';
import {html as staticHtml, StaticValue} from 'lit/static-html.js';

import {Field} from '../../field/internal/field.js';
import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';
import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from '../../labs/behaviors/constraint-validation.js';
import {mixinElementInternals} from '../../labs/behaviors/element-internals.js';
import {
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {
  mixinOnReportValidity,
  onReportValidity,
} from '../../labs/behaviors/on-report-validity.js';
import {SelectValidator} from '../../labs/behaviors/validators/select-validator.js';
import {getActiveItem} from '../../list/internal/list-navigation-helpers.js';
import {
  CloseMenuEvent,
  FocusState,
  isElementInSubtree,
  isSelectableKey,
} from '../../menu/internal/controllers/shared.js';
import {TYPEAHEAD_RECORD} from '../../menu/internal/controllers/typeaheadController.js';
import {DEFAULT_TYPEAHEAD_BUFFER_TIME, Menu} from '../../menu/internal/menu.js';
import {SelectOption} from './selectoption/select-option.js';
import {
  createRequestDeselectionEvent,
  createRequestSelectionEvent,
} from './selectoption/selectOptionController.js';
import {getSelectedItems, SelectOptionRecord} from './shared.js';

const VALUE = Symbol('value');

// Separate variable needed for closure.
const selectBaseClass = mixinDelegatesAria(
  mixinOnReportValidity(
    mixinConstraintValidation(
      mixinFormAssociated(mixinElementInternals(LitElement)),
    ),
  ),
);

/**
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 * @fires opening {Event} Fired when the select's menu is about to open.
 * @fires opened {Event} Fired when the select's menu has finished animations
 * and opened.
 * @fires closing {Event} Fired when the select's menu is about to close.
 * @fires closed {Event} Fired when the select's menu has finished animations
 * and closed.
 */
export abstract class Select extends selectBaseClass {
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Opens the menu synchronously with no animation.
   */
  @property({type: Boolean}) quick = false;

  /**
   * Whether or not the select is required.
   */
  @property({type: Boolean}) required = false;

  /**
   * The error message that replaces supporting text when `error` is true. If
   * `errorText` is an empty string, then the supporting text will continue to
   * show.
   *
   * This error message overrides the error message displayed by
   * `reportValidity()`.
   */
  @property({type: String, attribute: 'error-text'}) errorText = '';

  /**
   * The floating label for the field.
   */
  @property() label = '';

  /**
   * Disables the asterisk on the floating label, when the select is
   * required.
   */
  @property({type: Boolean, attribute: 'no-asterisk'}) noAsterisk = false;

  /**
   * Conveys additional information below the select, such as how it should
   * be used.
   */
  @property({type: String, attribute: 'supporting-text'}) supportingText = '';

  /**
   * Gets or sets whether or not the select is in a visually invalid state.
   *
   * This error state overrides the error state controlled by
   * `reportValidity()`.
   */
  @property({type: Boolean, reflect: true}) error = false;

  /**
   * Whether or not the underlying md-menu should be position: fixed to display
   * in a top-level manner, or position: absolute.
   *
   * position:fixed is useful for cases where select is inside of another
   * element with stacking context and hidden overflows such as `md-dialog`.
   */
  @property({attribute: 'menu-positioning'})
  menuPositioning: 'absolute' | 'fixed' | 'popover' = 'popover';

  /**
   * Clamps the menu-width to the width of the select.
   */
  @property({type: Boolean, attribute: 'clamp-menu-width'})
  clampMenuWidth = false;

  /**
   * The max time between the keystrokes of the typeahead select / menu behavior
   * before it clears the typeahead buffer.
   */
  @property({type: Number, attribute: 'typeahead-delay'})
  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;

  /**
   * Whether or not the text field has a leading icon. Used for SSR.
   */
  @property({type: Boolean, attribute: 'has-leading-icon'})
  hasLeadingIcon = false;

  /**
   * Text to display in the field. Only set for SSR.
   */
  @property({attribute: 'display-text'}) displayText = '';

  /**
   * Whether the menu should be aligned to the start or the end of the select's
   * textbox.
   */
  @property({attribute: 'menu-align'}) menuAlign: 'start' | 'end' = 'start';

  /**
   * The value of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `value` setting `value` will incur a DOM query.
   */
  @property()
  get value(): string {
    return this[VALUE];
  }

  set value(value: string) {
    if (isServer) return;
    this.lastUserSetValue = value;
    this.select(value);
  }

  [VALUE] = '';

  get options() {
    // NOTE: this does a DOM query.
    return (this.menu?.items ?? []) as SelectOption[];
  }

  /**
   * The index of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `selectedIndex` setting `selectedIndex` will incur a
   * DOM query.
   */
  @property({type: Number, attribute: 'selected-index'})
  get selectedIndex(): number {
    // tslint:disable-next-line:enforce-name-casing
    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];
    return index ?? -1;
  }

  set selectedIndex(index: number) {
    this.lastUserSetSelectedIndex = index;
    this.selectIndex(index);
  }

  /**
   * Returns an array of selected options.
   *
   * NOTE: md-select only supports single selection.
   */
  get selectedOptions() {
    return (this.getSelectedOptions() ?? []).map(([option]) => option);
  }

  protected abstract readonly fieldTag: StaticValue;

  /**
   * Used for initializing select when the user sets the `value` directly.
   */
  private lastUserSetValue: string | null = null;

  /**
   * Used for initializing select when the user sets the `selectedIndex`
   * directly.
   */
  private lastUserSetSelectedIndex: number | null = null;

  /**
   * Used for `input` and `change` event change detection.
   */
  private lastSelectedOption: SelectOption | null = null;

  // tslint:disable-next-line:enforce-name-casing
  private lastSelectedOptionRecords: SelectOptionRecord[] = [];

  /**
   * Whether or not a native error has been reported via `reportValidity()`.
   */
  @state() private nativeError = false;

  /**
   * The validation message displayed from a native error via
   * `reportValidity()`.
   */
  @state() private nativeErrorText = '';
  private get hasError() {
    return this.error || this.nativeError;
  }

  @state() private focused = false;
  @state() private open = false;
  @state() private defaultFocus: FocusState = FocusState.NONE;
  @query('.field') private readonly field!: Field | null;
  @query('md-menu') private readonly menu!: Menu | null;
  @query('#label') private readonly labelEl!: HTMLElement;
  @queryAssignedElements({slot: 'leading-icon', flatten: true})
  private readonly leadingIcons!: Element[];
  // Have to keep track of previous open because it's state and private and thus
  // cannot be tracked in PropertyValues<this> map.
  private prevOpen = this.open;
  private selectWidth = 0;

  constructor() {
    super();
    if (isServer) {
      return;
    }

    this.addEventListener('focus', this.handleFocus.bind(this));
    this.addEventListener('blur', this.handleBlur.bind(this));
  }

  /**
   * Selects an option given the value of the option, and updates MdSelect's
   * value.
   */
  select(value: string) {
    const optionToSelect = this.options.find(
      (option) => option.value === value,
    );
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }

  /**
   * Selects an option given the index of the option, and updates MdSelect's
   * value.
   */
  selectIndex(index: number) {
    const optionToSelect = this.options[index];
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }

  /**
   * Reset the select to its default value.
   */
  reset() {
    for (const option of this.options) {
      option.selected = option.hasAttribute('selected');
    }

    this.updateValueAndDisplayText();
    this.nativeError = false;
    this.nativeErrorText = '';
  }

  /** Shows the picker. If it's already open, this is a no-op. */
  showPicker() {
    this.open = true;
  }

  override [onReportValidity](invalidEvent: Event | null) {
    // Prevent default pop-up behavior.
    invalidEvent?.preventDefault();

    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;

    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }

  protected override update(changed: PropertyValues<Select>) {
    // In SSR the options will be ready to query, so try to figure out what
    // the value and display text should be.
    if (!this.hasUpdated) {
      this.initUserSelection();
    }

    // We have just opened the menu.
    // We are only able to check for the select's rect in `update()` instead of
    // having to wait for `updated()` because the menu can never be open on
    // first render since it is not settable and Lit SSR does not support click
    // events which would open the menu.
    if (this.prevOpen !== this.open && this.open) {
      const selectRect = this.getBoundingClientRect();
      this.selectWidth = selectRect.width;
    }

    this.prevOpen = this.open;
    super.update(changed);
  }

  protected override render() {
    return html`
      <span
        class="select ${classMap(this.getRenderClasses())}"
        @focusout=${this.handleFocusout}>
        ${this.renderField()} ${this.renderMenu()}
      </span>
    `;
  }

  protected override async firstUpdated(changed: PropertyValues<Select>) {
    await this.menu?.updateComplete;
    // If this has been handled on update already due to SSR, try again.
    if (!this.lastSelectedOptionRecords.length) {
      this.initUserSelection();
    }

    // Case for when the DOM is streaming, there are no children, and a child
    // has [selected] set on it, we need to wait for DOM to render something.
    if (
      !this.lastSelectedOptionRecords.length &&
      !isServer &&
      !this.options.length
    ) {
      setTimeout(() => {
        this.updateValueAndDisplayText();
      });
    }

    super.firstUpdated(changed);
  }

  private getRenderClasses(): ClassInfo {
    return {
      'disabled': this.disabled,
      'error': this.error,
      'open': this.open,
    };
  }

  private renderField() {
    const ariaLabel = (this as ARIAMixinStrict).ariaLabel || this.label;
    return staticHtml`
      <${this.fieldTag}
          aria-haspopup="listbox"
          role="combobox"
          part="field"
          id="field"
          tabindex=${this.disabled ? '-1' : '0'}
          aria-label=${ariaLabel || nothing}
          aria-describedby="description"
          aria-expanded=${this.open ? 'true' : 'false'}
          aria-controls="listbox"
          class="field"
          label=${this.label}
          ?no-asterisk=${this.noAsterisk}
          .focused=${this.focused || this.open}
          .populated=${!!this.displayText}
          .disabled=${this.disabled}
          .required=${this.required}
          .error=${this.hasError}
          ?has-start=${this.hasLeadingIcon}
          has-end
          supporting-text=${this.supportingText}
          error-text=${this.getErrorText()}
          @keydown=${this.handleKeydown}
          @click=${this.handleClick}>
         ${this.renderFieldContent()}
         <div id="description" slot="aria-describedby"></div>
      </${this.fieldTag}>`;
  }

  private renderFieldContent() {
    return [
      this.renderLeadingIcon(),
      this.renderLabel(),
      this.renderTrailingIcon(),
    ];
  }

  private renderLeadingIcon() {
    return html`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }

  private renderTrailingIcon() {
    return html`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}>
          <svg height="5" viewBox="7 10 10 5" focusable="false">
            <polygon
              class="down"
              stroke="none"
              fill-rule="evenodd"
              points="7 10 12 15 17 10"></polygon>
            <polygon
              class="up"
              stroke="none"
              fill-rule="evenodd"
              points="7 15 12 10 17 15"></polygon>
          </svg>
        </slot>
      </span>
    `;
  }

  private renderLabel() {
    // need to render &nbsp; so that line-height can apply and give it a
    // non-zero height
    return html`<div id="label">${this.displayText || html`&nbsp;`}</div>`;
  }

  private renderMenu() {
    const ariaLabel = this.label || (this as ARIAMixinStrict).ariaLabel;
    return html`<div class="menu-wrapper">
      <md-menu
        id="listbox"
        .defaultFocus=${this.defaultFocus}
        role="listbox"
        tabindex="-1"
        aria-label=${ariaLabel || nothing}
        stay-open-on-focusout
        part="menu"
        exportparts="focus-ring: menu-focus-ring"
        anchor="field"
        style=${styleMap({
          '--__menu-min-width': `${this.selectWidth}px`,
          '--__menu-max-width': this.clampMenuWidth
            ? `${this.selectWidth}px`
            : undefined,
        })}
        no-navigation-wrap
        .open=${this.open}
        .quick=${this.quick}
        .positioning=${this.menuPositioning}
        .typeaheadDelay=${this.typeaheadDelay}
        .anchorCorner=${this.menuAlign === 'start' ? 'end-start' : 'end-end'}
        .menuCorner=${this.menuAlign === 'start' ? 'start-start' : 'start-end'}
        @opening=${this.handleOpening}
        @opened=${this.redispatchEvent}
        @closing=${this.redispatchEvent}
        @closed=${this.handleClosed}
        @close-menu=${this.handleCloseMenu}
        @request-selection=${this.handleRequestSelection}
        @request-deselection=${this.handleRequestDeselection}>
        ${this.renderMenuContent()}
      </md-menu>
    </div>`;
  }

  private renderMenuContent() {
    return html`<slot></slot>`;
  }

  /**
   * Handles opening the select on keydown and typahead selection when the menu
   * is closed.
   */
  private handleKeydown(event: KeyboardEvent) {
    if (this.open || this.disabled || !this.menu) {
      return;
    }

    const typeaheadController = this.menu.typeaheadController;
    const isOpenKey =
      event.code === 'Space' ||
      event.code === 'ArrowDown' ||
      event.code === 'ArrowUp' ||
      event.code === 'End' ||
      event.code === 'Home' ||
      event.code === 'Enter';

    // Do not open if currently typing ahead because the user may be typing the
    // spacebar to match a word with a space
    if (!typeaheadController.isTypingAhead && isOpenKey) {
      event.preventDefault();
      this.open = true;

      // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/#kbd_label
      switch (event.code) {
        case 'Space':
        case 'ArrowDown':
        case 'Enter':
          // We will handle focusing last selected item in this.handleOpening()
          this.defaultFocus = FocusState.NONE;
          break;
        case 'End':
          this.defaultFocus = FocusState.LAST_ITEM;
          break;
        case 'ArrowUp':
        case 'Home':
          this.defaultFocus = FocusState.FIRST_ITEM;
          break;
        default:
          break;
      }
      return;
    }

    const isPrintableKey = event.key.length === 1;

    // Handles typing ahead when the menu is closed by delegating the event to
    // the underlying menu's typeaheadController
    if (isPrintableKey) {
      typeaheadController.onKeydown(event);
      event.preventDefault();

      const {lastActiveRecord} = typeaheadController;

      if (!lastActiveRecord) {
        return;
      }

      this.labelEl?.setAttribute?.('aria-live', 'polite');
      const hasChanged = this.selectItem(
        lastActiveRecord[TYPEAHEAD_RECORD.ITEM] as SelectOption,
      );

      if (hasChanged) {
        this.dispatchInteractionEvents();
      }
    }
  }

  private handleClick() {
    this.open = !this.open;
  }

  private handleFocus() {
    this.focused = true;
  }

  private handleBlur() {
    this.focused = false;
  }

  /**
   * Handles closing the menu when the focus leaves the select's subtree.
   */
  private handleFocusout(event: FocusEvent) {
    // Don't close the menu if we are switching focus between menu,
    // select-option, and field
    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {
      return;
    }

    this.open = false;
  }

  /**
   * Gets a list of all selected select options as a list item record array.
   *
   * @return An array of selected list option records.
   */
  private getSelectedOptions() {
    if (!this.menu) {
      this.lastSelectedOptionRecords = [];
      return null;
    }

    const items = this.menu.items as SelectOption[];
    this.lastSelectedOptionRecords = getSelectedItems(items);
    return this.lastSelectedOptionRecords;
  }

  override async getUpdateComplete() {
    await this.menu?.updateComplete;
    return super.getUpdateComplete();
  }

  /**
   * Gets the selected options from the DOM, and updates the value and display
   * text to the first selected option's value and headline respectively.
   *
   * @return Whether or not the selected option has changed since last update.
   */
  private updateValueAndDisplayText() {
    const selectedOptions = this.getSelectedOptions() ?? [];
    // Used to determine whether or not we need to fire an input / change event
    // which fire whenever the option element changes (value or selectedIndex)
    // on user interaction.
    let hasSelectedOptionChanged = false;

    if (selectedOptions.length) {
      const [firstSelectedOption] = selectedOptions[0];
      hasSelectedOptionChanged =
        this.lastSelectedOption !== firstSelectedOption;
      this.lastSelectedOption = firstSelectedOption;
      this[VALUE] = firstSelectedOption.value;
      this.displayText = firstSelectedOption.displayText;
    } else {
      hasSelectedOptionChanged = this.lastSelectedOption !== null;
      this.lastSelectedOption = null;
      this[VALUE] = '';
      this.displayText = '';
    }

    return hasSelectedOptionChanged;
  }

  /**
   * Focuses and activates the last selected item upon opening, and resets other
   * active items.
   */
  private async handleOpening(e: Event) {
    this.labelEl?.removeAttribute?.('aria-live');
    this.redispatchEvent(e);

    // FocusState.NONE means we want to handle focus ourselves and focus the
    // last selected item.
    if (this.defaultFocus !== FocusState.NONE) {
      return;
    }

    const items = this.menu!.items as SelectOption[];
    const activeItem = getActiveItem(items)?.item;
    let [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];

    // This is true if the user keys through the list but clicks out of the menu
    // thus no close-menu event is fired by an item and we can't clean up in
    // handleCloseMenu.
    if (activeItem && activeItem !== selectedItem) {
      activeItem.tabIndex = -1;
    }

    // in the case that nothing is selected, focus the first item
    selectedItem = selectedItem ?? items[0];

    if (selectedItem) {
      selectedItem.tabIndex = 0;
      selectedItem.focus();
    }
  }

  private redispatchEvent(e: Event) {
    redispatchEvent(this, e);
  }

  private handleClosed(e: Event) {
    this.open = false;
    this.redispatchEvent(e);
  }

  /**
   * Determines the reason for closing, and updates the UI accordingly.
   */
  private handleCloseMenu(event: CloseMenuEvent) {
    const reason = event.detail.reason;
    const item = event.detail.itemPath[0] as SelectOption;
    this.open = false;
    let hasChanged = false;

    if (reason.kind === 'click-selection') {
      hasChanged = this.selectItem(item);
    } else if (reason.kind === 'keydown' && isSelectableKey(reason.key)) {
      hasChanged = this.selectItem(item);
    } else {
      // This can happen on ESC being pressed
      item.tabIndex = -1;
      item.blur();
    }

    // Dispatch interaction events since selection has been made via keyboard
    // or mouse.
    if (hasChanged) {
      this.dispatchInteractionEvents();
    }
  }

  /**
   * Selects a given option, deselects other options, and updates the UI.
   *
   * @return Whether the last selected option has changed.
   */
  private selectItem(item: SelectOption) {
    const selectedOptions = this.getSelectedOptions() ?? [];
    selectedOptions.forEach(([option]) => {
      if (item !== option) {
        option.selected = false;
      }
    });
    item.selected = true;

    return this.updateValueAndDisplayText();
  }

  /**
   * Handles updating selection when an option element requests selection via
   * property / attribute change.
   */
  private handleRequestSelection(
    event: ReturnType<typeof createRequestSelectionEvent>,
  ) {
    const requestingOptionEl = event.target as SelectOption & HTMLElement;

    // No-op if this item is already selected.
    if (
      this.lastSelectedOptionRecords.some(
        ([option]) => option === requestingOptionEl,
      )
    ) {
      return;
    }

    this.selectItem(requestingOptionEl);
  }

  /**
   * Handles updating selection when an option element requests deselection via
   * property / attribute change.
   */
  private handleRequestDeselection(
    event: ReturnType<typeof createRequestDeselectionEvent>,
  ) {
    const requestingOptionEl = event.target as SelectOption & HTMLElement;

    // No-op if this item is not even in the list of tracked selected items.
    if (
      !this.lastSelectedOptionRecords.some(
        ([option]) => option === requestingOptionEl,
      )
    ) {
      return;
    }

    this.updateValueAndDisplayText();
  }

  /**
   * Attempts to initialize the selected option from user-settable values like
   * SSR, setting `value`, or `selectedIndex` at startup.
   */
  private initUserSelection() {
    // User has set `.value` directly, but internals have not yet booted up.
    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {
      this.select(this.lastUserSetValue);

      // User has set `.selectedIndex` directly, but internals have not yet
      // booted up.
    } else if (
      this.lastUserSetSelectedIndex !== null &&
      !this.lastSelectedOptionRecords.length
    ) {
      this.selectIndex(this.lastUserSetSelectedIndex);

      // Regular boot up!
    } else {
      this.updateValueAndDisplayText();
    }
  }

  private handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
  }

  /**
   * Dispatches the `input` and `change` events.
   */
  private dispatchInteractionEvents() {
    this.dispatchEvent(new Event('input', {bubbles: true, composed: true}));
    this.dispatchEvent(new Event('change', {bubbles: true}));
  }

  private getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    return this.value;
  }

  override formResetCallback() {
    this.reset();
  }

  override formStateRestoreCallback(state: string) {
    this.value = state;
  }

  override click() {
    this.field?.click();
  }

  override [createValidator]() {
    return new SelectValidator(() => this);
  }

  override [getValidityAnchor]() {
    return this.field;
  }
}


// ========== /internal/selectoption/select-option.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../focus/md-focus-ring.js';
import '../../../labs/item/item.js';
import '../../../ripple/ripple.js';

import {html, LitElement, nothing} from 'lit';
import {
  property,
  query,
  queryAssignedElements,
  queryAssignedNodes,
} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';
import {MenuItem} from '../../../menu/internal/controllers/menuItemController.js';

import {SelectOptionController} from './selectOptionController.js';

/**
 * The interface specific to a Select Option
 */
interface SelectOptionSelf {
  /**
   * The form value associated with the Select Option. (Note: the visual portion
   * of the SelectOption is the headline defined in ListItem)
   */
  value: string;
  /**
   * Whether or not the SelectOption is selected.
   */
  selected: boolean;
  /**
   * The text to display in the select when selected. Defaults to the
   * textContent of the Element slotted into the headline.
   */
  displayText: string;
}

/**
 * The interface to implement for a select option. Additionally, the element
 * must have `md-list-item` and `md-menu-item` attributes on the host.
 */
export type SelectOption = SelectOptionSelf & MenuItem;

// Separate variable needed for closure.
const selectOptionBaseClass = mixinDelegatesAria(LitElement);

/**
 * @fires close-menu {CustomEvent<{initiator: SelectOption, reason: Reason, itemPath: SelectOption[]}>}
 * Closes the encapsulating menu on closable interaction. --bubbles --composed
 * @fires request-selection {Event} Requests the parent md-select to select this
 * element (and deselect others if single-selection) when `selected` changed to
 * `true`. --bubbles --composed
 * @fires request-deselection {Event} Requests the parent md-select to deselect
 * this element when `selected` changed to `false`. --bubbles --composed
 */
export class SelectOptionEl
  extends selectOptionBaseClass
  implements SelectOption
{
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Disables the item and makes it non-selectable and non-interactive.
   */
  @property({type: Boolean, reflect: true}) disabled = false;

  /**
   * READONLY: self-identifies as a menu item and sets its identifying attribute
   */
  @property({type: Boolean, attribute: 'md-menu-item', reflect: true})
  isMenuItem = true;

  /**
   * Sets the item in the selected visual state when a submenu is opened.
   */
  @property({type: Boolean}) selected = false;
  /**
   * Form value of the option.
   */
  @property() value = '';

  @query('.list-item') protected readonly listItemRoot!: HTMLElement | null;

  @queryAssignedElements({slot: 'headline'})
  protected readonly headlineElements!: HTMLElement[];
  @queryAssignedElements({slot: 'supporting-text'})
  protected readonly supportingTextElements!: HTMLElement[];
  @queryAssignedNodes({slot: ''})
  protected readonly defaultElements!: Element[];

  type = 'option' as const;

  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.selectOptionController.typeaheadText;
  }

  @property({attribute: 'typeahead-text'})
  set typeaheadText(text: string) {
    this.selectOptionController.setTypeaheadText(text);
  }

  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot.
   */
  get displayText() {
    return this.selectOptionController.displayText;
  }

  @property({attribute: 'display-text'})
  set displayText(text: string) {
    this.selectOptionController.setDisplayText(text);
  }

  private readonly selectOptionController = new SelectOptionController(this, {
    getHeadlineElements: () => {
      return this.headlineElements;
    },
    getSupportingTextElements: () => {
      return this.supportingTextElements;
    },
    getDefaultElements: () => {
      return this.defaultElements;
    },
    getInteractiveElement: () => this.listItemRoot,
  });

  protected override render() {
    return this.renderListItem(html`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }

  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  protected renderListItem(content: unknown) {
    return html`
      <li
        id="item"
        tabindex=${this.disabled ? -1 : 0}
        role=${this.selectOptionController.role}
        aria-label=${(this as ARIAMixinStrict).ariaLabel || nothing}
        aria-selected=${(this as ARIAMixinStrict).ariaSelected || nothing}
        aria-checked=${(this as ARIAMixinStrict).ariaChecked || nothing}
        aria-expanded=${(this as ARIAMixinStrict).ariaExpanded || nothing}
        aria-haspopup=${(this as ARIAMixinStrict).ariaHasPopup || nothing}
        class="list-item ${classMap(this.getRenderClasses())}"
        @click=${this.selectOptionController.onClick}
        @keydown=${this.selectOptionController.onKeydown}
        >${content}</li
      >
    `;
  }

  /**
   * Handles rendering of the ripple element.
   */
  protected renderRipple() {
    return html` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }

  /**
   * Handles rendering of the focus ring.
   */
  protected renderFocusRing() {
    return html` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }

  /**
   * Classes applied to the list item root.
   */
  protected getRenderClasses(): ClassInfo {
    return {
      'disabled': this.disabled,
      'selected': this.selected,
    };
  }

  /**
   * Handles rendering the headline and supporting text.
   */
  protected renderBody() {
    return html`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }

  override focus() {
    // TODO(b/300334509): needed for some cases where delegatesFocus doesn't
    // work programmatically like in FF and select-option
    this.listItemRoot?.focus();
  }
}


// ========== /internal/selectoption/selectOptionController.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {ReactiveController, ReactiveControllerHost} from 'lit';

import {
  MenuItemController,
  MenuItemControllerConfig,
} from '../../../menu/internal/controllers/menuItemController.js';
import {SelectOption} from './select-option.js';

/**
 * Creates an event fired by a SelectOption to request selection from md-select.
 * Typically fired after `selected` changes from `false` to `true`.
 */
export function createRequestSelectionEvent() {
  return new Event('request-selection', {
    bubbles: true,
    composed: true,
  });
}

/**
 * Creates an event fired by a SelectOption to request deselection from
 * md-select. Typically fired after `selected` changes from `true` to `false`.
 */
export function createRequestDeselectionEvent() {
  return new Event('request-deselection', {
    bubbles: true,
    composed: true,
  });
}

/**
 * The options used to inialize SelectOptionController.
 */
export type SelectOptionConfig = MenuItemControllerConfig;

/**
 * A controller that provides most functionality and md-select compatibility for
 * an element that implements the SelectOption interface.
 */
export class SelectOptionController implements ReactiveController {
  private readonly menuItemController: MenuItemController;
  private internalDisplayText: string | null = null;
  private lastSelected: boolean;
  private firstUpdate = true;

  /**
   * The recommended role of the select option.
   */
  get role() {
    return this.menuItemController.role;
  }

  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }

  setTypeaheadText(text: string) {
    this.menuItemController.setTypeaheadText(text);
  }

  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot,
   * and if there are no slotted elements into headline, then it checks the
   * _default_ slot, and then the `"supporting-text"` slot if nothing is in
   * _default_.
   */
  get displayText() {
    if (this.internalDisplayText !== null) {
      return this.internalDisplayText;
    }

    return this.menuItemController.typeaheadText;
  }

  setDisplayText(text: string) {
    this.internalDisplayText = text;
  }

  /**
   * @param host The SelectOption in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(
    private readonly host: ReactiveControllerHost & SelectOption,
    config: SelectOptionConfig,
  ) {
    this.lastSelected = this.host.selected;
    this.menuItemController = new MenuItemController(host, config);
    host.addController(this);
  }

  hostUpdate() {
    if (this.lastSelected !== this.host.selected) {
      this.host.ariaSelected = this.host.selected ? 'true' : 'false';
    }
  }

  hostUpdated() {
    // Do not dispatch event on first update / boot-up.
    if (this.lastSelected !== this.host.selected && !this.firstUpdate) {
      // This section is really useful for when the user sets selected on the
      // option programmatically. Most other cases (click and keyboard) are
      // handled by md-select because it needs to coordinate the
      // single-selection behavior.
      if (this.host.selected) {
        this.host.dispatchEvent(createRequestSelectionEvent());
      } else {
        this.host.dispatchEvent(createRequestDeselectionEvent());
      }
    }

    this.lastSelected = this.host.selected;
    this.firstUpdate = false;
  }

  /**
   * Bind this click listener to the interactive element. Handles closing the
   * menu.
   */
  onClick = () => {
    this.menuItemController.onClick();
  };

  /**
   * Bind this click listener to the interactive element. Handles closing the
   * menu.
   */
  onKeydown = (e: KeyboardEvent) => {
    this.menuItemController.onKeydown(e);
  };
}


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles();


// ========== /internal/shared.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {SelectOption} from './selectoption/select-option.js';

/**
 * A type that describes a SelectOption and its index.
 */
export type SelectOptionRecord = [SelectOption, number];

/**
 * Given a list of select options, this function will return an array of
 * SelectOptionRecords that are selected.
 *
 * @return An array of SelectOptionRecords describing the options that are
 * selected.
 */
export function getSelectedItems(items: SelectOption[]) {
  const selectedItemRecords: SelectOptionRecord[] = [];

  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item.selected) {
      selectedItemRecords.push([item, i]);
    }
  }

  return selectedItemRecords;
}


// ========== /outlined-select.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {OutlinedSelect} from './internal/outlined-select.js';
import {styles} from './internal/outlined-select-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-select': MdOutlinedSelect;
  }
}

/**
 * @summary
 * Select menus display a list of choices on temporary surfaces and display the
 * currently selected menu item above the menu.
 *
 * @description
 * The select component allows users to choose a value from a fixed list of
 * available options. Composed of an interactive anchor button and a menu, it is
 * analogous to the native HTML `<select>` element. This is the "outlined"
 * variant.
 *
 * @example
 * ```html
 * <md-outlined-select label="fruits">
 *   <!-- An empty selected option will give select an "un-filled" state -->
 *   <md-select-option selected></md-select-option>
 *   <md-select-option value="apple" headline="Apple"></md-select-option>
 *   <md-select-option value="banana" headline="Banana"></md-select-option>
 *   <md-select-option value="kiwi" headline="Kiwi"></md-select-option>
 *   <md-select-option value="orange" headline="Orange"></md-select-option>
 *   <md-select-option value="tomato" headline="Tomato"></md-select-option>
 * </md-outlined-select>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-select')
export class MdOutlinedSelect extends OutlinedSelect {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];
}


// ========== /select-option.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles} from '../menu/internal/menuitem/menu-item-styles.js';

import {SelectOptionEl} from './internal/selectoption/select-option.js';

export {type SelectOption} from './internal/selectoption/select-option.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-select-option': MdSelectOption;
  }
}

/**
 * @summary
 * Select menus display a list of choices on temporary surfaces and display the
 * currently selected menu item above the menu.
 *
 * @description
 * The select component allows users to choose a value from a fixed list of
 * available options. Composed of an interactive anchor button and a menu, it is
 * analogous to the native HTML `<select>` element. This is the option that
 * can be placed inside of an md-select.
 *
 * This component is a subclass of `md-menu-item` and can accept the same slots,
 * properties, and events as `md-menu-item`.
 *
 * @example
 * ```html
 * <md-outlined-select label="fruits">
 *   <!-- An empty selected option will give select an "un-filled" state -->
 *   <md-select-option selected></md-select-option>
 *   <md-select-option value="apple" headline="Apple"></md-select-option>
 *   <md-select-option value="banana" headline="Banana"></md-select-option>
 *   <md-select-option value="kiwi" headline="Kiwi"></md-select-option>
 *   <md-select-option value="orange" headline="Orange"></md-select-option>
 *   <md-select-option value="tomato" headline="Tomato"></md-select-option>
 * </md-outlined-select>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-select-option')
export class MdSelectOption extends SelectOptionEl {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /select_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html, render} from 'lit';

import {createFormTests} from '../testing/forms.js';
import {createTokenTests} from '../testing/tokens.js';

import {MdFilledSelect} from './filled-select.js';
import {SelectHarness} from './harness.js';
import {MdOutlinedSelect} from './outlined-select.js';
import {MdSelectOption} from './select-option.js';

describe('<md-outlined-select>', () => {
  describe('.styles', () => {
    createTokenTests(MdOutlinedSelect.styles);
  });

  let root: HTMLDivElement;

  beforeEach(() => {
    root = document.createElement('div');
    document.body.appendChild(root);
  });

  afterEach(() => {
    root?.remove();
  });

  it('clicking on option triggers change', async () => {
    let changed = false;
    render(
      html` <md-outlined-select
        @change=${() => {
          changed = true;
        }}>
        <md-select-option selected></md-select-option>
        <md-select-option></md-select-option>
      </md-outlined-select>`,
      root,
    );
    const selectEl = root.querySelector('md-outlined-select')!;
    await selectEl.updateComplete;

    await new SelectHarness(selectEl).clickOption(1);

    expect(changed).toBeTrue();
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-outlined-select'),
      valueTests: [
        {
          name: 'unnamed',
          render: () => html`
            <md-outlined-select>
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two" selected></md-select-option>
            </md-outlined-select>
          `,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'unselected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two"></md-select-option>
            </md-outlined-select>
          `,
          assertValue(formData) {
            expect(formData.get('select')).toBe('');
          },
        },
        {
          name: 'selected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two" selected></md-select-option>
            </md-outlined-select>
          `,
          assertValue(formData) {
            expect(formData.get('select')).toBe('two');
          },
        },
        {
          name: 'disabled',
          render: () => html`
            <md-outlined-select name="select" disabled>
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two" selected></md-select-option>
            </md-outlined-select>
          `,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset to unselected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two"></md-select-option>
            </md-outlined-select>
          `,
          change(select) {
            select.value = 'one';
          },
          assertReset(select) {
            expect(select.value)
              .withContext('select.value after reset')
              .toBe('');
          },
        },
        {
          name: 'reset to selected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two" selected></md-select-option>
            </md-outlined-select>
          `,
          change(select) {
            select.value = 'one';
          },
          assertReset(select) {
            expect(select.value)
              .withContext('select.value after reset')
              .toBe('two');
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore unselected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two"></md-select-option>
            </md-outlined-select>
          `,
          assertRestored(select) {
            expect(select.value)
              .withContext('select.value after restore')
              .toBe('');
          },
        },
        {
          name: 'restore selected',
          render: () => html`
            <md-outlined-select name="select">
              <md-select-option value="one"></md-select-option>
              <md-select-option value="two" selected></md-select-option>
            </md-outlined-select>
          `,
          assertRestored(select) {
            expect(select.value)
              .withContext('select.value after restore')
              .toBe('two');
          },
        },
      ],
    });
  });
});

describe('<md-filled-select>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledSelect.styles);
  });
});

describe('<md-select-option>', () => {
  describe('.styles', () => {
    createTokenTests(MdSelectOption.styles);
  });
});


// ========== /test/assets.ts ==========
/** @license Googler-authored internal-only code. */

/**
 * User avatar as a dataurl.
 */
export const AVATAR_URL =
  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAAAAADH8yjkAAABsklEQVR4Ae3WBaLjMAxF0dn/np4hVEY3cQqOupNh/i4oVT76buAUEkmfzgOXgAS8QiABCUhAAg71dlsfhgJOc4vv2flpAICWGr/TS5IGQoV/qoIs0OX4r7wTBcZ40lgSqBGplgMoQ6SMxACPaF4MmCPaXAwoEa0UAyyiWTFAIZoSAwyiGTGgQLRCDJgh2kwMaBCtEQPIIpIluVnkEMkJDjuq8KSKJMd1eDLusiC70U45/ik/Se/kbqbwOzXrBrgqDtOfhJoeBrqLyLvl0nlKp2MCXi1Ap1Prndv59iQOdPVqkqu/J9FoWQcp4LguES1f7B8HaJPhStk6PASElcGN9CL0B9YKd6TWPYFjgTsrjn2ARuPudMMHdgqM1I4LtAqsVMsDyIKZJRawBLslC7BgZzlAQI8CA+gM2JmOAZy9AjPleY/pAswWZx5AFVhVxATOVIJRSfxZRAXurqA+07Qb4c5GXb99QAvc1YJ6bzSncTPtHtnJYYwbjcODV0WT40p5I3C21AUQr6iFDi8/M5HZM/OSp2O7HP+FmPGyHeD4Db5x261rfEjnewISkIAEJODDAV8A/z6x+ahJu3sAAAAASUVORK5CYII=';

/**
 * Example image as a dataurl.
 */
export const IMAGE_URL =
  'data:image/png;base64,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';

/**
 * One frame of the color blue in webm as a dataurl.
 *
 * Generated with
 * ffmpeg -f lavfi -i color=blue:s=1280x720 -vframes 1 ~/out.webm
 * cat ~/out.webm | base64 | tr -d '\n'
 */
export const VIDEO_URL =
  'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAJrEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHYTbuMU6uEElTDZ1OsggEgTbuMU6uEHFO7a1OsggJV7AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmsirXsYMPQkBNgI1MYXZmNTkuMjcuMTAwV0GNTGF2ZjU5LjI3LjEwMESJiEBEAAAAAAAAFlSua8OuAQAAAAAAADrXgQFzxYjFaDr5zFhASZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDgi7CCBQC6ggLQmoECElTDZ0CBc3OgY8CAZ8iaRaOHRU5DT0RFUkSHjUxhdmY1OS4yNy4xMDBzc9tjwItjxYjFaDr5zFhASWfIpUWjh0VOQ09ERVJEh5hMYXZjNTkuMzcuMTAwIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dUCo54EAo0CigQAAgIJJg0IAT/As9gA4JBwYShgAQGIMw/o6+kdo6+kAuaP9KgAAAAAcZw5Vl/m2cRY6ymCqlMFVJYKqSwVSleqUBBBCAAAAABxnDlWX+bZxFjrKYKqUwVUlgqpLBVKV6pQEEEIAAAAAHGcOVZf5tnEWOspgqpTBVSWCqksFUpXqlAQQQgBnDlWX+bZxFjrKYKqUwVUlgqpLBVKV6pQEEEIAHFO7a5G7j7OBALeK94EB8YIBp/CBAw==';