/* ========== /_radio.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/radio' show theme;


/* ========== /internal/_radio.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../internal/motion/animation';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-radio-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-radio-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-radio-values();

  @layer {
    :host {
      display: inline-flex;
      height: map.get($tokens, 'icon-size');
      outline: none;
      position: relative;
      vertical-align: top; // Fix extra space when placed inside display: block
      width: map.get($tokens, 'icon-size');
      // Remove highlight color for mobile Safari
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;

      @include ripple.theme(
        (
          hover-color: map.get($tokens, 'hover-state-layer-color'),
          hover-opacity: map.get($tokens, 'hover-state-layer-opacity'),
          pressed-color: map.get($tokens, 'pressed-state-layer-color'),
          pressed-opacity: map.get($tokens, 'pressed-state-layer-opacity'),
        )
      );
    }

    :host([disabled]) {
      cursor: default;
    }

    :host([touch-target='wrapper']) {
      margin: max(0px, ((48px - map.get($tokens, 'icon-size')) / 2));
    }

    .container {
      display: flex;
      height: 100%;
      place-content: center;
      place-items: center;
      width: 100%;
    }

    md-focus-ring {
      height: 44px;
      inset: unset;
      width: 44px;
    }

    .checked {
      @include ripple.theme(
        (
          hover-color: map.get($tokens, 'selected-hover-state-layer-color'),
          hover-opacity: map.get($tokens, 'selected-hover-state-layer-opacity'),
          pressed-color: map.get($tokens, 'selected-pressed-state-layer-color'),
          pressed-opacity:
            map.get($tokens, 'selected-pressed-state-layer-opacity'),
        )
      );
    }

    .touch-target {
      height: 48px;
      position: absolute;
      width: 48px;
    }

    :host([touch-target='none']) .touch-target {
      display: none;
    }

    md-ripple {
      border-radius: 50%;
      height: map.get($tokens, 'state-layer-size');
      inset: unset;
      width: map.get($tokens, 'state-layer-size');
    }

    .icon {
      fill: map.get($tokens, 'icon-color');
      inset: 0;
      position: absolute;
    }

    .outer.circle {
      // Outline color enter/exit transition
      transition: fill 50ms linear;
    }

    .inner.circle {
      opacity: 0;
      transform-origin: center;
      transition: opacity 50ms linear;
    }

    .checked .icon {
      fill: map.get($tokens, 'selected-icon-color');
    }

    .checked .inner.circle {
      animation: inner-circle-grow 300ms
        map.get($_md-sys-motion, easing-emphasized-decelerate);
      opacity: 1;
    }

    @keyframes inner-circle-grow {
      from {
        transform: scale(0);
      }
      to {
        transform: scale(1);
      }
    }

    // Don't animate when disabled
    :host([disabled]) .circle {
      animation-duration: 0s;
      transition-duration: 0s;
    }

    :host(:hover) .icon {
      fill: map.get($tokens, 'hover-icon-color');
    }

    :host(:focus-within) .icon {
      fill: map.get($tokens, 'focus-icon-color');
    }

    :host(:active) .icon {
      fill: map.get($tokens, 'pressed-icon-color');
    }

    :host([disabled]) .icon {
      fill: map.get($tokens, 'disabled-unselected-icon-color');
      opacity: map.get($tokens, 'disabled-unselected-icon-opacity');
    }

    :host(:hover) .checked .icon {
      fill: map.get($tokens, 'selected-hover-icon-color');
    }

    :host(:focus-within) .checked .icon {
      fill: map.get($tokens, 'selected-focus-icon-color');
    }

    :host(:active) .checked .icon {
      fill: map.get($tokens, 'selected-pressed-icon-color');
    }

    :host([disabled]) .checked .icon {
      fill: map.get($tokens, 'disabled-selected-icon-color');
      opacity: map.get($tokens, 'disabled-selected-icon-opacity');
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .icon {
        fill: CanvasText;
      }

      :host([disabled]) .icon {
        fill: GrayText;
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/radio-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './radio';
// go/keep-sorted end

@include radio.styles;


// ========== /internal/radio.ts ==========
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement} from 'lit';
import {property, query} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {isActivationClick} from '../../internal/events/form-label-activation.js';
import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from '../../labs/behaviors/constraint-validation.js';
import {
  internals,
  mixinElementInternals,
} from '../../labs/behaviors/element-internals.js';
import {mixinFocusable} from '../../labs/behaviors/focusable.js';
import {
  getFormState,
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {RadioValidator} from '../../labs/behaviors/validators/radio-validator.js';

import {SingleSelectionController} from './single-selection-controller.js';

const CHECKED = Symbol('checked');
let maskId = 0;

// Separate variable needed for closure.
const radioBaseClass = mixinConstraintValidation(
  mixinFormAssociated(mixinElementInternals(mixinFocusable(LitElement))),
);

/**
 * A radio component.
 *
 * @fires input {InputEvent} Dispatched when the value changes from user
 * interaction. --bubbles
 * @fires change {Event} Dispatched when the value changes from user
 * interaction. --bubbles --composed
 */
export class Radio extends radioBaseClass {
  // Unique maskId is required because of a Safari bug that fail to persist
  // reference to the mask. This should be removed once the bug is fixed.
  private readonly maskId = `cutout${++maskId}`;

  /**
   * Whether or not the radio is selected.
   */
  @property({type: Boolean})
  get checked() {
    return this[CHECKED];
  }
  set checked(checked: boolean) {
    const wasChecked = this.checked;
    if (wasChecked === checked) {
      return;
    }

    this[CHECKED] = checked;
    this.requestUpdate('checked', wasChecked);
    this.selectionController.handleCheckedChange();
  }

  [CHECKED] = false;

  /**
   * Whether or not the radio is required. If any radio is required in a group,
   * all radios are implicitly required.
   */
  @property({type: Boolean}) required = false;

  /**
   * The element value to use in form submission when checked.
   */
  @property() value = 'on';

  @query('.container') private readonly container!: HTMLElement;
  private readonly selectionController = new SingleSelectionController(this);

  constructor() {
    super();
    this.addController(this.selectionController);
    if (!isServer) {
      this[internals].role = 'radio';
      this.addEventListener('click', this.handleClick.bind(this));
      this.addEventListener('keydown', this.handleKeydown.bind(this));
    }
  }

  protected override render() {
    const classes = {'checked': this.checked};
    return html`
      <div class="container ${classMap(classes)}" aria-hidden="true">
        <md-ripple
          part="ripple"
          .control=${this}
          ?disabled=${this.disabled}></md-ripple>
        <md-focus-ring part="focus-ring" .control=${this}></md-focus-ring>
        <svg class="icon" viewBox="0 0 20 20">
          <mask id="${this.maskId}">
            <rect width="100%" height="100%" fill="white" />
            <circle cx="10" cy="10" r="8" fill="black" />
          </mask>
          <circle
            class="outer circle"
            cx="10"
            cy="10"
            r="10"
            mask="url(#${this.maskId})" />
          <circle class="inner circle" cx="10" cy="10" r="5" />
        </svg>

        <div class="touch-target"></div>
      </div>
    `;
  }

  protected override updated() {
    this[internals].ariaChecked = String(this.checked);
  }

  private async handleClick(event: Event) {
    if (this.disabled) {
      return;
    }

    // allow event to propagate to user code after a microtask.
    await 0;
    if (event.defaultPrevented) {
      return;
    }

    if (isActivationClick(event)) {
      this.focus();
    }

    // Per spec, clicking on a radio input always selects it.
    this.checked = true;
    this.dispatchEvent(new Event('change', {bubbles: true}));
    this.dispatchEvent(
      new InputEvent('input', {bubbles: true, composed: true}),
    );
  }

  private async handleKeydown(event: KeyboardEvent) {
    // allow event to propagate to user code after a microtask.
    await 0;
    if (event.key !== ' ' || event.defaultPrevented) {
      return;
    }

    this.click();
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    return this.checked ? this.value : null;
  }

  override [getFormState]() {
    return String(this.checked);
  }

  override formResetCallback() {
    // The checked property does not reflect, so the original attribute set by
    // the user is used to determine the default value.
    this.checked = this.hasAttribute('checked');
  }

  override formStateRestoreCallback(state: string) {
    this.checked = state === 'true';
  }

  override [createValidator]() {
    return new RadioValidator(() => {
      if (!this.selectionController) {
        // Validation runs on superclass construction, so selection controller
        // might not actually be ready until this class constructs.
        return [this];
      }

      return this.selectionController.controls as [Radio, ...Radio[]];
    });
  }

  override [getValidityAnchor]() {
    return this.container;
  }
}


// ========== /internal/single-selection-controller.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {ReactiveController} from 'lit';

/**
 * An element that supports single-selection with `SingleSelectionController`.
 */
export interface SingleSelectionElement extends HTMLElement {
  /**
   * Whether or not the element is selected.
   */
  checked: boolean;
}

/**
 * A `ReactiveController` that provides root node-scoped single selection for
 * elements, similar to native `<input type="radio">` selection.
 *
 * To use, elements should add the controller and call
 * `selectionController.handleCheckedChange()` in a getter/setter. This must
 * be synchronous to match native behavior.
 *
 * @example
 * const CHECKED = Symbol('checked');
 *
 * class MyToggle extends LitElement {
 *   get checked() { return this[CHECKED]; }
 *   set checked(checked: boolean) {
 *     const oldValue = this.checked;
 *     if (oldValue === checked) {
 *       return;
 *     }
 *
 *     this[CHECKED] = checked;
 *     this.selectionController.handleCheckedChange();
 *     this.requestUpdate('checked', oldValue);
 *   }
 *
 *   [CHECKED] = false;
 *
 *   private selectionController = new SingleSelectionController(this);
 *
 *   constructor() {
 *     super();
 *     this.addController(this.selectionController);
 *   }
 * }
 */
export class SingleSelectionController implements ReactiveController {
  /**
   * All single selection elements in the host element's root with the same
   * `name` attribute, including the host element.
   */
  get controls(): [SingleSelectionElement, ...SingleSelectionElement[]] {
    const name = this.host.getAttribute('name');
    if (!name || !this.root || !this.host.isConnected) {
      return [this.host];
    }

    // Cast as unknown since there is not enough information for typescript to
    // know that there is always at least one element (the host).
    return Array.from(
      this.root.querySelectorAll<SingleSelectionElement>(`[name="${name}"]`),
    ) as unknown as [SingleSelectionElement, ...SingleSelectionElement[]];
  }

  private focused = false;
  private root: ParentNode | null = null;

  constructor(private readonly host: SingleSelectionElement) {}

  hostConnected() {
    this.host.addEventListener('keydown', this.handleKeyDown);
    this.host.addEventListener('focusin', this.handleFocusIn);
    this.host.addEventListener('focusout', this.handleFocusOut);

    // Update siblings after a microtask to allow other synchronous connected
    // callbacks to settle before triggering additional Lit updates. This avoids
    // stack overflow issues when too many elements are being rendered and
    // connected at the same time.
    queueMicrotask(() => {
      // Update for the newly added host.
      this.root = this.host.getRootNode() as ParentNode;
      if (this.host.checked) {
        // Uncheck other siblings when attached if already checked. This mimics
        // native <input type="radio"> behavior.
        this.uncheckSiblings();
      }

      this.updateTabIndices();
    });
  }

  hostDisconnected() {
    this.host.removeEventListener('keydown', this.handleKeyDown);
    this.host.removeEventListener('focusin', this.handleFocusIn);
    this.host.removeEventListener('focusout', this.handleFocusOut);
    // Update siblings after a microtask to allow other synchronous disconnected
    // callbacks to settle before triggering additional Lit updates. This avoids
    // stack overflow issues when too many elements are being rendered and
    // connected at the same time.
    queueMicrotask(() => {
      // Update for siblings that are still connected.
      this.updateTabIndices();
      this.root = null;
    });
  }

  /**
   * Should be called whenever the host's `checked` property changes
   * synchronously.
   */
  handleCheckedChange() {
    if (!this.host.checked) {
      return;
    }

    this.uncheckSiblings();
    this.updateTabIndices();
  }

  private readonly handleFocusIn = () => {
    this.focused = true;
    this.updateTabIndices();
  };

  private readonly handleFocusOut = () => {
    this.focused = false;
    this.updateTabIndices();
  };

  private uncheckSiblings() {
    for (const sibling of this.controls) {
      if (sibling !== this.host) {
        sibling.checked = false;
      }
    }
  }

  /**
   * Updates the `tabindex` of the host and its siblings.
   */
  private updateTabIndices() {
    // There are three tabindex states for a group of elements:
    // 1. If any are checked, that element is focusable.
    const siblings = this.controls;
    const checkedSibling = siblings.find((sibling) => sibling.checked);
    // 2. If an element is focused, the others are no longer focusable.
    if (checkedSibling || this.focused) {
      const focusable = checkedSibling || this.host;
      focusable.tabIndex = 0;

      for (const sibling of siblings) {
        if (sibling !== focusable) {
          sibling.tabIndex = -1;
        }
      }
      return;
    }

    // 3. If none are checked or focused, all are focusable.
    for (const sibling of siblings) {
      sibling.tabIndex = 0;
    }
  }

  /**
   * Handles arrow key events from the host. Using the arrow keys will
   * select and check the next or previous sibling with the host's
   * `name` attribute.
   */
  private readonly handleKeyDown = (event: KeyboardEvent) => {
    const isDown = event.key === 'ArrowDown';
    const isUp = event.key === 'ArrowUp';
    const isLeft = event.key === 'ArrowLeft';
    const isRight = event.key === 'ArrowRight';
    // Ignore non-arrow keys
    if (!isLeft && !isRight && !isDown && !isUp) {
      return;
    }

    // Don't try to select another sibling if there aren't any.
    const siblings = this.controls;
    if (!siblings.length) {
      return;
    }

    // Prevent default interactions on the element for arrow keys,
    // since this controller will introduce new behavior.
    event.preventDefault();

    // Check if moving forwards or backwards
    const isRtl = getComputedStyle(this.host).direction === 'rtl';
    const forwards = isRtl ? isLeft || isDown : isRight || isDown;

    const hostIndex = siblings.indexOf(this.host);
    let nextIndex = forwards ? hostIndex + 1 : hostIndex - 1;
    // Search for the next sibling that is not disabled to select.
    // If we return to the host index, there is nothing to select.
    while (nextIndex !== hostIndex) {
      if (nextIndex >= siblings.length) {
        // Return to start if moving past the last item.
        nextIndex = 0;
      } else if (nextIndex < 0) {
        // Go to end if moving before the first item.
        nextIndex = siblings.length - 1;
      }

      // Check if the next sibling is disabled. If so,
      // move the index and continue searching.
      const nextSibling = siblings[nextIndex];
      if (nextSibling.hasAttribute('disabled')) {
        if (forwards) {
          nextIndex++;
        } else {
          nextIndex--;
        }

        continue;
      }

      // Uncheck and remove focusability from other siblings.
      for (const sibling of siblings) {
        if (sibling !== nextSibling) {
          sibling.checked = false;
          sibling.tabIndex = -1;
          sibling.blur();
        }
      }

      // The next sibling should be checked, focused and dispatch a change event
      nextSibling.checked = true;
      nextSibling.tabIndex = 0;
      nextSibling.focus();
      // Fire a change event since the change is triggered by a user action.
      // This matches native <input type="radio"> behavior.
      nextSibling.dispatchEvent(new Event('change', {bubbles: true}));

      break;
    }
  };
}


// ========== /radio.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Radio} from './internal/radio.js';
import {styles} from './internal/radio-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-radio': MdRadio;
  }
}

/**
 * @summary Radio buttons allow users to select one option from a set.
 *
 * @description
 * Radio buttons are the recommended way to allow users to make a single
 * selection from a list of options.
 *
 * Only one radio button can be selected at a time.
 *
 * Use radio buttons to:
 * - Select a single option from a set
 * - Expose all available options
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-radio')
export class MdRadio extends Radio {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /radio_test.ts ==========
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createFormTests} from '../testing/forms.js';
import {createTokenTests} from '../testing/tokens.js';

import {RadioHarness} from './harness.js';
import {MdRadio} from './radio.js';

const defaultRadio = html`<md-radio></md-radio>`;

const radioGroup = html`
  <md-radio id="a1" name="a"></md-radio>
  <md-radio id="a2" name="a"></md-radio>
  <md-radio id="b1" name="b"></md-radio>
`;

const radioGroupDisabled = html`
  <md-radio id="a1" name="a" disabled></md-radio>
  <md-radio id="a2" name="a" disabled checked></md-radio>
`;

const radioGroupPreSelected = html`
  <md-radio id="a1" name="a"></md-radio>
  <md-radio id="a2" name="a" checked></md-radio>
  <md-radio id="a3" name="a"></md-radio>
  <md-radio id="b1" name="b"></md-radio>
`;

describe('<md-radio>', () => {
  const env = new Environment();

  // Note, this would be better in the harness, but waiting in the test setup
  // can be flaky without access to the test `env`.
  async function simulateKeyDown(element: HTMLElement, key: string) {
    const event = new KeyboardEvent('keydown', {key, bubbles: true});
    element.dispatchEvent(event);
    // We can remove the delay when FF issue addressed:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1804576
    await env.waitForStability();
  }

  async function setupTest(template = defaultRadio) {
    const root = env.render(template);
    await env.waitForStability();
    const radios = Array.from(root.querySelectorAll('md-radio'));
    const harnesses = radios.map((radio) => new RadioHarness(radio));
    return {harnesses, root};
  }

  describe('.styles', () => {
    createTokenTests(MdRadio.styles);
  });

  describe('basic', () => {
    it('initializes as an md-radio', async () => {
      const {harnesses} = await setupTest();
      expect(harnesses[0].element).toBeInstanceOf(MdRadio);
    });

    it('clicking a radio should select it', async () => {
      const {harnesses} = await setupTest(radioGroup);
      const unselected = harnesses[1];
      expect(unselected.element.checked)
        .withContext('unselected checked')
        .toBeFalse();

      await unselected.clickWithMouse();
      expect(unselected.element.checked)
        .withContext('after clicking checked')
        .toBeTrue();
    });

    it('clicking a radio can be default prevented', async () => {
      const {harnesses} = await setupTest(radioGroup);
      const unselected = harnesses[1];
      expect(unselected.element.checked)
        .withContext('unselected checked')
        .toBeFalse();

      unselected.element.addEventListener('click', (event) => {
        event.preventDefault();
      });

      await unselected.clickWithMouse();
      expect(unselected.element.checked)
        .withContext('after clicking checked')
        .toBeFalse();
    });

    it('clicking a radio should unselect other radio which is already selected', async () => {
      const {harnesses} = await setupTest(radioGroupPreSelected);
      const [, a2, a3] = harnesses;
      expect(a2.element.checked).withContext('already checked').toBeTrue();

      await a3.clickWithMouse();
      expect(a3.element.checked).withContext('new radio checked').toBeTrue();
      expect(a2.element.checked)
        .withContext('previous radio checked')
        .toBeFalse();
    });

    it('disabled radio should not be selected when clicked', async () => {
      const {harnesses} = await setupTest(radioGroupDisabled);
      const [a1, a2] = harnesses;

      expect(a1.element.checked).withContext('unchecked radio').toBeFalse();
      expect(a2.element.checked).withContext('checked radio').toBeTrue();

      await a1.clickWithMouse();
      expect(a1.element.checked)
        .withContext('still unchecked radio')
        .toBeFalse();

      await a2.clickWithMouse();
      expect(a2.element.checked).withContext('still checked radio').toBeTrue();
    });
  });

  describe('events', () => {
    it('Should trigger change event when a radio is selected', async () => {
      const {harnesses, root} = await setupTest(radioGroupPreSelected);
      const changeHandler = jasmine.createSpy('changeHandler');
      root.addEventListener('change', changeHandler);

      const a3 = harnesses[2];
      await a3.clickWithMouse();

      expect(a3.element.checked)
        .withContext('clicked radio checked')
        .toBeTrue();
      expect(changeHandler).toHaveBeenCalledTimes(1);
      expect(changeHandler).toHaveBeenCalledWith(jasmine.any(Event));
    });

    it('Should trigger input event when a radio is selected', async () => {
      const {harnesses, root} = await setupTest(radioGroupPreSelected);
      const inputHandler = jasmine.createSpy('inputHandler');
      root.addEventListener('input', inputHandler);

      const a3 = harnesses[2];
      await a3.clickWithMouse();

      expect(a3.element.checked)
        .withContext('clicked radio checked')
        .toBeTrue();
      expect(inputHandler).toHaveBeenCalledTimes(1);
      expect(inputHandler).toHaveBeenCalledWith(jasmine.any(InputEvent));
    });
  });

  describe('navigation', () => {
    it('Using arrow right should select the next radio button', async () => {
      const {harnesses} = await setupTest(radioGroupPreSelected);
      const [, a2, a3] = harnesses;
      expect(a2.element.checked)
        .withContext('default checked radio')
        .toBeTrue();

      await simulateKeyDown(a2.element, 'ArrowRight');

      expect(a3.element.checked).withContext('next radio checked').toBeTrue();
      expect(a2.element.checked).withContext('prev radio checked').toBeFalse();
    });

    it('dispatched a change event on user navigation', async () => {
      const {harnesses, root} = await setupTest(radioGroupPreSelected);
      const changeHandler = jasmine.createSpy('changeHandler');
      root.addEventListener('change', changeHandler);
      const [, a2] = harnesses;
      expect(a2.element.checked)
        .withContext('default checked radio')
        .toBeTrue();

      await simulateKeyDown(a2.element, 'ArrowRight');

      expect(changeHandler).toHaveBeenCalledTimes(1);
    });

    it('Using arrow right on the last radio should select the first radio in that group', async () => {
      const {harnesses} = await setupTest(radioGroupPreSelected);
      const [a1, a2, a3, b1] = harnesses;

      expect(a2.element.checked).toBeTrue();

      await simulateKeyDown(a2.element, 'ArrowRight');
      await simulateKeyDown(a3.element, 'ArrowRight');

      expect(a3.element.checked).withContext('last radio checked').toBeFalse();
      expect(a1.element.checked).withContext('first radio checked').toBeTrue();
      expect(b1.element.checked)
        .withContext('unrelated radio checked')
        .toBeFalse();
    });
  });

  describe('manages selection groups', () => {
    it('synchronously', async () => {
      const {harnesses} = await setupTest(radioGroup);
      const [a1, a2, b1] = harnesses;

      expect(a1.element.checked).withContext('initially unchecked').toBeFalse();
      expect(a2.element.checked).withContext('initially unchecked').toBeFalse();
      expect(b1.element.checked).withContext('initially unchecked').toBeFalse();

      // Should uncheck previously checked radio
      a2.element.checked = true;
      a1.element.checked = true;

      expect(a1.element.checked).withContext('last radio checked').toBeTrue();
      expect(a2.element.checked)
        .withContext('unchecked by last radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated radio unchecked')
        .toBeFalse();

      // Should re-check radio
      a2.element.checked = true;
      a1.element.checked = true;
      a2.element.checked = true;
      expect(a1.element.checked)
        .withContext('unchecked by second radio')
        .toBeFalse();
      expect(a2.element.checked).withContext('last radio checked').toBeTrue();
      expect(b1.element.checked)
        .withContext('unrelated radio unchecked')
        .toBeFalse();

      // Should ignore unrelated radios
      a1.element.checked = true;
      expect(a1.element.checked)
        .withContext('related checked radio')
        .toBeTrue();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated unchecked radio')
        .toBeFalse();

      b1.element.checked = true;
      expect(a1.element.checked)
        .withContext('related checked radio')
        .toBeTrue();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated checked radio')
        .toBeTrue();

      a1.element.checked = false;
      b1.element.checked = false;
      expect(a1.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated unchecked radio')
        .toBeFalse();
    });

    it('after updates settle', async () => {
      const {harnesses} = await setupTest(radioGroup);
      const [a1, a2, b1] = harnesses;
      const allUpdatesComplete = () =>
        Promise.all(harnesses.map((harness) => harness.element.updateComplete));

      await allUpdatesComplete();
      expect(a1.element.checked).withContext('initially unchecked').toBeFalse();
      expect(a2.element.checked).withContext('initially unchecked').toBeFalse();
      expect(b1.element.checked).withContext('initially unchecked').toBeFalse();

      // Should uncheck previously checked radio
      a2.element.checked = true;
      a1.element.checked = true;
      await allUpdatesComplete();

      expect(a1.element.checked).withContext('last radio checked').toBeTrue();
      expect(a2.element.checked)
        .withContext('unchecked by last radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated radio unchecked')
        .toBeFalse();

      // Should re-check radio
      a2.element.checked = true;
      a1.element.checked = true;
      a2.element.checked = true;
      await allUpdatesComplete();
      expect(a1.element.checked)
        .withContext('unchecked by second radio')
        .toBeFalse();
      expect(a2.element.checked).withContext('last radio checked').toBeTrue();
      expect(b1.element.checked)
        .withContext('unrelated radio unchecked')
        .toBeFalse();

      // Should ignore unrelated radios
      a1.element.checked = true;
      expect(a1.element.checked)
        .withContext('related checked radio')
        .toBeTrue();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated unchecked radio')
        .toBeFalse();

      b1.element.checked = true;
      await allUpdatesComplete();
      expect(a1.element.checked)
        .withContext('related checked radio')
        .toBeTrue();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated checked radio')
        .toBeTrue();

      a1.element.checked = false;
      b1.element.checked = false;
      await allUpdatesComplete();
      expect(a1.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(a2.element.checked)
        .withContext('related unchecked radio')
        .toBeFalse();
      expect(b1.element.checked)
        .withContext('unrelated unchecked radio')
        .toBeFalse();
    });

    it('when checked before connected', async () => {
      const root = env.render(html`<main></main>`);
      const container = root.querySelector('main')!;

      const r1 = document.createElement('md-radio');
      r1.setAttribute('name', 'a');
      const r2 = document.createElement('md-radio');
      r2.setAttribute('name', 'a');
      const r3 = document.createElement('md-radio');
      r3.setAttribute('name', 'a');

      // r1 and r2 should both be checked, because even though they have the
      // same name, they aren't yet connected to a root. Groups are scoped to
      // roots, and we can't know which root a radio belongs to until it is
      // connected to one. This matches native <input type="radio"> behavior.
      r1.checked = true;
      r2.checked = true;
      expect(r1.checked).toBeTrue();
      expect(r2.checked).toBeTrue();
      expect(r3.checked).toBeFalse();

      // Connecting r1 shouldn't change anything, since it's the only one in the
      // group.
      container.appendChild(r1);
      await env.waitForStability();
      expect(r1.checked).toBeTrue();
      expect(r2.checked).toBeTrue();
      expect(r3.checked).toBeFalse();

      // Appending r2 should uncheck r1, because when a new checked radio is
      // connected, it wins (this matches native input behavior).
      container.appendChild(r2);
      await env.waitForStability();
      expect(r1.checked).toBeFalse();
      expect(r2.checked).toBeTrue();
      expect(r3.checked).toBeFalse();

      // Appending r3 shouldn't change anything, because it's not checked.
      container.appendChild(r3);
      await env.waitForStability();
      expect(r1.checked).toBeFalse();
      expect(r2.checked).toBeTrue();
      expect(r3.checked).toBeFalse();

      // Checking r3 should uncheck r2 because it's now in the same group.
      r3.checked = true;
      expect(r1.checked).toBeFalse();
      expect(r2.checked).toBeFalse();
      expect(r3.checked).toBeTrue();
    });

    it('in a lit repeat', async () => {
      const values = ['a1', 'a2'];
      const repeated = values.map(
        (value) => html`<md-radio value=${value} name="a"></md-radio>`,
      );
      const root = env.render(html`${repeated}`);
      await env.waitForStability();
      const [a1, a2] = root.querySelectorAll('md-radio');

      expect(a1.checked).toBeFalse();
      expect(a2.checked).toBeFalse();
      expect(a1.value).toEqual(values[0]);
      expect(a2.value).toEqual(values[1]);

      a1.checked = true;
      expect(a1.checked).toBeTrue();
      expect(a2.checked).toBeFalse();

      a2.checked = true;
      expect(a1.checked).toBeFalse();
      expect(a2.checked).toBeTrue();

      a2.checked = false;
      expect(a1.checked).toBeFalse();
      expect(a2.checked).toBeFalse();
    });
  });

  describe('label activation', () => {
    async function setupLabelTest() {
      const root = env.render(html`
        <label> <md-radio name="a"></md-radio></label>
        <label> <md-radio name="a"></md-radio></label>
      `);
      await env.waitForStability();
      // [[label, radio]]
      return Array.from(root.querySelectorAll('label')).map(
        (el) => [el, el.firstElementChild as MdRadio] as const,
      );
    }

    it('toggles when label is clicked', async () => {
      const [[label1, radio1], [label2, radio2]] = await setupLabelTest();

      label1.click();
      await env.waitForStability();
      expect(radio1.checked).toBeTrue();
      expect(radio2.checked).toBeFalse();

      label2.click();
      await env.waitForStability();
      expect(radio1.checked).toBeFalse();
      expect(radio2.checked).toBeTrue();
    });
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-radio'),
      valueTests: [
        {
          name: 'unnamed',
          render: () => html`
            <md-radio value="One" checked></md-radio>
            <md-radio value="Two"></md-radio>
          `,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'unchecked',
          render: () => html`
            <md-radio name="radio" value="One"></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when unchecked')
              .toHaveSize(0);
          },
        },
        {
          name: 'checked first value',
          render: () => html`
            <md-radio name="radio" value="One" checked></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          assertValue(formData) {
            expect(formData.get('radio')).toBe('One');
          },
        },
        {
          name: 'checked second value',
          render: () => html`
            <md-radio name="radio" value="One"></md-radio>
            <md-radio name="radio" value="Two" checked></md-radio>
          `,
          assertValue(formData) {
            expect(formData.get('radio')).toBe('Two');
          },
        },
        {
          name: 'disabled',
          render: () => html`
            <md-radio name="radio" value="One" checked disabled></md-radio>
            <md-radio name="radio" value="Two" disabled></md-radio>
          `,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset to unchecked',
          render: () => html`
            <md-radio name="radio" value="One"></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          change(radio) {
            radio.checked = true;
          },
          assertReset(radio) {
            expect(radio.checked)
              .withContext('radio.checked after reset')
              .toBeFalse();
          },
        },
        {
          name: 'reset to checked',
          render: () => html`
            <md-radio name="radio" value="One" checked></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          change(radio) {
            radio.checked = false;
          },
          assertReset(radio) {
            expect(radio.checked)
              .withContext('radio.checked after reset')
              .toBeTrue();
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore unchecked',
          render: () => html`
            <md-radio name="radio" value="One"></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          assertRestored(radio) {
            expect(radio.checked)
              .withContext('radio.checked after restore')
              .toBeFalse();
          },
        },
        {
          name: 'restore checked',
          render: () => html`
            <md-radio name="radio" value="One" checked></md-radio>
            <md-radio name="radio" value="Two"></md-radio>
          `,
          assertRestored(radio) {
            expect(radio.checked)
              .withContext('radio.checked after restore')
              .toBeTrue();
          },
        },
      ],
    });
  });
});