/* ========== /_assist-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/assist-chip' show theme;


/* ========== /_filter-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filter-chip' show theme;


/* ========== /_input-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/input-chip' show theme;


/* ========== /_suggestion-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/suggestion-chip' show theme;


// ========== /assist-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {AssistChip} from './internal/assist-chip.js';
import {styles} from './internal/assist-styles.js';
import {styles as elevatedStyles} from './internal/elevated-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-assist-chip': MdAssistChip;
  }
}

/**
 * TODO(b/243982145): add docs
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-assist-chip')
export class MdAssistChip extends AssistChip {
  static override styles: CSSResultOrNative[] = [sharedStyles, elevatedStyles, styles];
}


// ========== /assist-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdAssistChip} from './assist-chip.js';

describe('<md-assist-chip>', () => {
  describe('.styles', () => {
    createTokenTests(MdAssistChip.styles);
  });
});


// ========== /chip-set.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {ChipSet} from './internal/chip-set.js';
import {styles} from './internal/chip-set-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-chip-set': MdChipSet;
  }
}

/**
 * TODO(b/243982145): add docs
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-chip-set')
export class MdChipSet extends ChipSet {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /filter-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles as elevatedStyles} from './internal/elevated-styles.js';
import {FilterChip} from './internal/filter-chip.js';
import {styles} from './internal/filter-styles.js';
import {styles as selectableStyles} from './internal/selectable-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';
import {styles as trailingIconStyles} from './internal/trailing-icon-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filter-chip': MdFilterChip;
  }
}

/**
 * TODO(b/243982145): add docs
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-filter-chip')
export class MdFilterChip extends FilterChip {
  static override styles: CSSResultOrNative[] = [
    sharedStyles,
    elevatedStyles,
    trailingIconStyles,
    selectableStyles,
    styles,
  ];
}


// ========== /filter-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdFilterChip} from './filter-chip.js';

describe('<md-filter-chip>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilterChip.styles);
  });
});


// ========== /input-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {InputChip} from './internal/input-chip.js';
import {styles} from './internal/input-styles.js';
import {styles as selectableStyles} from './internal/selectable-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';
import {styles as trailingIconStyles} from './internal/trailing-icon-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-input-chip': MdInputChip;
  }
}

/**
 * TODO(b/243982145): add docs
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-input-chip')
export class MdInputChip extends InputChip {
  static override styles: CSSResultOrNative[] = [
    sharedStyles,
    trailingIconStyles,
    selectableStyles,
    styles,
  ];
}


// ========== /input-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdInputChip} from './input-chip.js';

describe('<md-input-chip>', () => {
  describe('.styles', () => {
    createTokenTests(MdInputChip.styles);
  });
});


/* ========== /internal/_assist-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-assist-chip-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-assist-chip-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-assist-chip-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  @media (forced-colors: active) {
    .link .outline {
      border-color: ActiveText;
    }
  }
}


/* ========== /internal/_chip-set.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles() {
  :host {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }
}


/* ========== /internal/_elevated.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use '../../elevation/elevation';
// go/keep-sorted end

@mixin styles() {
  .elevated {
    @include elevation.theme(
      (
        'level': var(--_elevated-container-elevation),
        'shadow-color': var(--_elevated-container-shadow-color),
      )
    );
  }

  .elevated::before {
    background: var(--_elevated-container-color);
  }

  .elevated:hover {
    @include elevation.theme(
      (
        'level': var(--_elevated-hover-container-elevation),
      )
    );
  }

  .elevated:focus-within {
    @include elevation.theme(
      (
        'level': var(--_elevated-focus-container-elevation),
      )
    );
  }

  .elevated:active {
    @include elevation.theme(
      (
        'level': var(--_elevated-pressed-container-elevation),
      )
    );
  }

  .elevated.disabled {
    @include elevation.theme(
      (
        'level': var(--_elevated-disabled-container-elevation),
      )
    );
  }

  .elevated.disabled::before {
    background: var(--_elevated-disabled-container-color);
    opacity: var(--_elevated-disabled-container-opacity);
  }

  @media (forced-colors: active) {
    .elevated md-elevation {
      border: 1px solid CanvasText;
    }

    .elevated.disabled md-elevation {
      border-color: GrayText;
    }
  }
}


/* ========== /internal/_filter-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filter-chip-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-filter-chip-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filter-chip-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .selected.elevated::before {
    background: var(--_elevated-selected-container-color);
  }

  .checkmark {
    height: var(--_icon-size);
    width: var(--_icon-size);
  }

  .disabled .checkmark {
    opacity: var(--_disabled-leading-icon-opacity);
  }

  @media (forced-colors: active) {
    .disabled .checkmark {
      opacity: 1;
    }
  }
}


/* ========== /internal/_input-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-input-chip-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-input-chip-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-input-chip-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  :host([avatar]) {
    // Use a rounded border by default for avatar chips. Recreating the
    // fallbacks allows `--md-input-chip-container-shape` to cascade and
    // override this without needing to add more specificity for avatar chips.
    --_container-shape-start-start: var(
      --md-input-chip-container-shape-start-start,
      var(--md-input-chip-container-shape, calc(var(--_container-height) / 2))
    );
    --_container-shape-start-end: var(
      --md-input-chip-container-shape-start-end,
      var(--md-input-chip-container-shape, calc(var(--_container-height) / 2))
    );
    --_container-shape-end-end: var(
      --md-input-chip-container-shape-end-end,
      var(--md-input-chip-container-shape, calc(var(--_container-height) / 2))
    );
    --_container-shape-end-start: var(
      --md-input-chip-container-shape-end-start,
      var(--md-input-chip-container-shape, calc(var(--_container-height) / 2))
    );
  }

  .avatar .primary.action {
    padding-inline-start: 4px;
  }

  .avatar .leading.icon ::slotted(:first-child) {
    border-radius: var(--_avatar-shape);
    height: var(--_avatar-size);
    width: var(--_avatar-size);
  }

  .disabled.avatar .leading.icon {
    opacity: var(--_disabled-avatar-opacity);
  }

  @media (forced-colors: active) {
    .link .outline {
      border-color: ActiveText;
    }

    .disabled.avatar .leading.icon {
      opacity: 1;
    }
  }
}


/* ========== /internal/_selectable.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use '../../ripple/ripple';
// go/keep-sorted end

@mixin styles() {
  .selected {
    @include ripple.theme(
      (
        hover-color: var(--_selected-hover-state-layer-color),
        hover-opacity: var(--_selected-hover-state-layer-opacity),
        pressed-color: var(--_selected-pressed-state-layer-color),
        pressed-opacity: var(--_selected-pressed-state-layer-opacity),
      )
    );
  }

  :where(.selected)::before {
    background: var(--_selected-container-color);
  }

  :where(.selected) .outline {
    border-width: var(--_selected-outline-width);
  }

  :where(.selected.disabled)::before {
    background: var(--_disabled-selected-container-color);
    opacity: var(--_disabled-selected-container-opacity);
  }

  :where(.selected) .label {
    color: var(--_selected-label-text-color);
  }

  :where(.selected:hover) .label {
    color: var(--_selected-hover-label-text-color);
  }

  :where(.selected:focus) .label {
    color: var(--_selected-focus-label-text-color);
  }

  :where(.selected:active) .label {
    color: var(--_selected-pressed-label-text-color);
  }

  :where(.selected) .leading.icon {
    color: var(--_selected-leading-icon-color);
  }

  :where(.selected:hover) .leading.icon {
    color: var(--_selected-hover-leading-icon-color);
  }

  :where(.selected:focus) .leading.icon {
    color: var(--_selected-focus-leading-icon-color);
  }

  :where(.selected:active) .leading.icon {
    color: var(--_selected-pressed-leading-icon-color);
  }

  @media (forced-colors: active) {
    :where(.selected:not(.elevated))::before {
      // for forced-colors. Don't add it to elevated containers since elevation
      // already have a border added.
      border: 1px solid CanvasText;
    }

    :where(.selected) .outline {
      border-width: 1px;
    }
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../ripple/ripple';
// go/keep-sorted end

@mixin styles() {
  :host {
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-start-radius: var(--_container-shape-end-start);
    border-end-end-radius: var(--_container-shape-end-end);
    display: inline-flex;
    height: var(--_container-height);
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;

    @include ripple.theme(
      (
        'hover-color': var(--_hover-state-layer-color),
        'hover-opacity': var(--_hover-state-layer-opacity),
        'pressed-color': var(--_pressed-state-layer-color),
        'pressed-opacity': var(--_pressed-state-layer-opacity),
      )
    );
  }

  :host(:is([disabled], [soft-disabled])) {
    pointer-events: none;
  }

  :host([touch-target='wrapper']) {
    margin: max(0px, (48px - var(--_container-height)) / 2) 0;
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape-start-start': var(--_container-shape-start-start),
        'shape-start-end': var(--_container-shape-start-end),
        'shape-end-end': var(--_container-shape-end-end),
        'shape-end-start': var(--_container-shape-end-start),
      )
    );
  }

  .container {
    border-radius: inherit;
    box-sizing: border-box;
    display: flex;
    height: 100%;
    position: relative;
    width: 100%;

    // Container color, separate node for disabled opacity changes
    &::before {
      border-radius: inherit;
      content: '';
      inset: 0;
      pointer-events: none;
      position: absolute;
    }
  }

  .container:not(.disabled) {
    cursor: pointer;
  }

  .container.disabled {
    pointer-events: none;
  }

  .cell {
    display: flex;
  }

  .action {
    align-items: baseline;
    appearance: none;
    background: none;
    border: none;
    border-radius: inherit;
    display: flex;
    outline: none;
    padding: 0;
    position: relative;
    text-decoration: none;
  }

  .primary.action {
    // Set a min-width on the primary action so that trailing actions remain
    // inside the chip as the chip is resized.
    min-width: 0;
    padding-inline-start: var(--_leading-space);
    padding-inline-end: var(--_trailing-space);
  }

  .has-icon .primary.action {
    padding-inline-start: var(--_with-leading-icon-leading-space);
  }

  .touch {
    height: 48px;
    inset: 50% 0 0;
    position: absolute;
    transform: translateY(-50%);
    width: 100%;
  }

  :host([touch-target='none']) .touch {
    display: none;
  }

  // Outline, separate node for disabled opacity changes
  .outline {
    border: var(--_outline-width) solid var(--_outline-color);
    border-radius: inherit;
    inset: 0;
    pointer-events: none;
    position: absolute;
  }

  :where(:focus) .outline {
    border-color: var(--_focus-outline-color);
  }

  :where(.disabled) .outline {
    border-color: var(--_disabled-outline-color);
    opacity: var(--_disabled-outline-opacity);
  }

  md-ripple {
    border-radius: inherit;
  }

  .label,
  .icon,
  .touch {
    // Place content above background elements
    z-index: 1;
  }

  .label {
    align-items: center;
    color: var(--_label-text-color);
    display: flex;
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    font-weight: var(--_label-text-weight);
    height: 100%;
    line-height: var(--_label-text-line-height);
    overflow: hidden;
    user-select: none;
  }

  // An inner span is needed to truncate the label, since elements with a flex
  // display do not support the text-overflow property. The outer wrapper .label
  // needs to be a flex display to correctly set the element's baseline,
  // supporting external elements aligning to the baseline of the chip's text
  // instead of its edges or icons.
  .label-text {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  :where(:hover) .label {
    color: var(--_hover-label-text-color);
  }

  :where(:focus) .label {
    color: var(--_focus-label-text-color);
  }

  :where(:active) .label {
    color: var(--_pressed-label-text-color);
  }

  :where(.disabled) .label {
    color: var(--_disabled-label-text-color);
    opacity: var(--_disabled-label-text-opacity);
  }

  .icon {
    align-self: center;
    display: flex;
    fill: currentColor;
    position: relative;
  }

  .icon ::slotted(:first-child) {
    font-size: var(--_icon-size);
    height: var(--_icon-size);
    width: var(--_icon-size);
  }

  .leading.icon {
    color: var(--_leading-icon-color);
  }

  .leading.icon ::slotted(*),
  .leading.icon svg {
    margin-inline-end: var(--_icon-label-space);
  }

  :where(:hover) .leading.icon {
    color: var(--_hover-leading-icon-color);
  }

  :where(:focus) .leading.icon {
    color: var(--_focus-leading-icon-color);
  }

  :where(:active) .leading.icon {
    color: var(--_pressed-leading-icon-color);
  }

  :where(.disabled) .leading.icon {
    color: var(--_disabled-leading-icon-color);
    opacity: var(--_disabled-leading-icon-opacity);
  }

  @media (forced-colors: active) {
    :where(.disabled) :is(.label, .outline, .leading.icon) {
      color: GrayText;
      opacity: 1;
    }
  }

  a,
  button {
    // Override the user-agent text-transform: none of <button> and <a>
    text-transform: inherit;
  }

  a,
  button:not(:disabled, [aria-disabled='true']) {
    cursor: inherit;
  }
}


/* ========== /internal/_suggestion-chip.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-suggestion-chip-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-suggestion-chip-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-suggestion-chip-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  @media (forced-colors: active) {
    .link .outline {
      border-color: ActiveText;
    }
  }
}


/* ========== /internal/_trailing-icon.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use '../../focus/focus-ring';
// go/keep-sorted end

@mixin styles() {
  .trailing.action {
    align-items: center;
    justify-content: center;
    padding-inline-start: var(--_icon-label-space);
    padding-inline-end: var(--_with-trailing-icon-trailing-space);
  }

  .trailing.action :is(md-ripple, md-focus-ring) {
    border-radius: 50%;
    height: calc(4 / 3 * var(--_icon-size)); // 24px default
    width: calc(4 / 3 * var(--_icon-size)); // 24px default
  }

  .trailing.action md-focus-ring {
    inset: unset;
  }

  .has-trailing .primary.action {
    padding-inline-end: 0;
  }

  .trailing.icon {
    color: var(--_trailing-icon-color);
    height: var(--_icon-size);
    width: var(--_icon-size);
  }

  :where(:hover) .trailing.icon {
    color: var(--_hover-trailing-icon-color);
  }

  :where(:focus) .trailing.icon {
    color: var(--_focus-trailing-icon-color);
  }

  :where(:active) .trailing.icon {
    color: var(--_pressed-trailing-icon-color);
  }

  :where(.disabled) .trailing.icon {
    color: var(--_disabled-trailing-icon-color);
    opacity: var(--_disabled-trailing-icon-opacity);
  }

  :where(.selected) .trailing.icon {
    color: var(--_selected-trailing-icon-color);
  }

  :where(.selected:hover) .trailing.icon {
    color: var(--_selected-hover-trailing-icon-color);
  }

  :where(.selected:focus) .trailing.icon {
    color: var(--_selected-focus-trailing-icon-color);
  }

  :where(.selected:active) .trailing.icon {
    color: var(--_selected-pressed-trailing-icon-color);
  }

  @media (forced-colors: active) {
    .trailing.icon {
      color: ButtonText;
    }

    :where(.disabled) .trailing.icon {
      color: GrayText;
      opacity: 1;
    }
  }
}


// ========== /internal/assist-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';

import {html, nothing} from 'lit';
import {property} from 'lit/decorators.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';

import {Chip} from './chip.js';

/**
 * An assist chip component.
 */
export class AssistChip extends Chip {
  @property({type: Boolean}) elevated = false;
  @property() href = '';
  /**
   * The filename to use when downloading the linked resource.
   * If not specified, the browser will determine a filename.
   * This is only applicable when the chip is used as a link (`href` is set).
   */
  @property() download = '';
  @property() target: '_blank' | '_parent' | '_self' | '_top' | '' = '';

  protected get primaryId() {
    return this.href ? 'link' : 'button';
  }

  protected override get rippleDisabled() {
    // Link chips cannot be disabled
    return !this.href && (this.disabled || this.softDisabled);
  }

  protected override getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      elevated: this.elevated,
      link: !!this.href,
    };
  }

  protected override renderPrimaryAction(content: unknown) {
    const {ariaLabel} = this as ARIAMixinStrict;
    if (this.href) {
      return html`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || nothing}
          href=${this.href}
          download=${this.download || nothing}
          target=${this.target || nothing}
          >${content}</a
        >
      `;
    }

    return html`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || nothing}
        aria-disabled=${this.softDisabled || nothing}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }

  protected override renderOutline() {
    if (this.elevated) {
      return html`<md-elevation part="elevation"></md-elevation>`;
    }

    return super.renderOutline();
  }
}


// ========== /internal/assist-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';

import {Environment} from '../../testing/environment.js';

import {AssistChip} from './assist-chip.js';

customElements.define('test-assist-chip', AssistChip);

describe('Assist chip', () => {
  const env = new Environment();

  async function setupTest() {
    const chip = new AssistChip();
    env.render(html`${chip}`);
    await env.waitForStability();
    return chip;
  }

  describe('links', () => {
    it('should render a link when provided an href', async () => {
      const chip = await setupTest();
      chip.href = 'link';
      await chip.updateComplete;

      expect(chip.renderRoot.querySelector('a'))
        .withContext('should have a rendered <a> link')
        .toBeTruthy();
    });

    it('should not allow link chips to be disabled', async () => {
      const chip = await setupTest();
      chip.href = 'link';
      chip.disabled = true;
      await chip.updateComplete;

      expect(chip.renderRoot.querySelector('.disabled,:disabled'))
        .withContext('should not have any disabled styling or behavior')
        .toBeNull();
    });

    it('should not allow link chips to be soft-disabled', async () => {
      // Arrange
      // Act
      const chip = await setupTest();
      chip.href = 'link';
      chip.softDisabled = true;
      await chip.updateComplete;

      // Assert
      expect(chip.renderRoot.querySelector('.disabled,:disabled'))
        .withContext('should not have any disabled styling or behavior')
        .toBeNull();
    });
  });

  it('should use aria-disabled when soft-disabled', async () => {
    // Arrange
    // Act
    const chip = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Assert
    expect(chip.renderRoot.querySelector('button[aria-disabled="true"]'))
      .withContext('should have aria-disabled="true"')
      .not.toBeNull();
  });

  it('should be focusable when soft-disabled', async () => {
    // Arrange
    const chip = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Act
    chip.focus();

    // Assert
    expect(document.activeElement)
      .withContext('soft-disabled chip should be focused')
      .toBe(chip);
  });

  it('should not be clickable when soft-disabled', async () => {
    // Arrange
    const clickListener = jasmine.createSpy('clickListener');
    const chip = await setupTest();
    chip.softDisabled = true;
    chip.addEventListener('click', clickListener);

    // Act
    chip.click();

    // Assert
    expect(clickListener).not.toHaveBeenCalled();
  });
});


/* ========== /internal/assist-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './assist-chip';
// go/keep-sorted end

@include assist-chip.styles;


/* ========== /internal/chip-set-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './chip-set';
// go/keep-sorted end

@include chip-set.styles;


// ========== /internal/chip-set.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, isServer, LitElement} from 'lit';
import {queryAssignedElements} from 'lit/decorators.js';

import {Chip} from './chip.js';

/**
 * A chip set component.
 */
export class ChipSet extends LitElement {
  get chips() {
    return this.childElements.filter(
      (child): child is Chip => child instanceof Chip,
    );
  }

  @queryAssignedElements() private readonly childElements!: HTMLElement[];
  private readonly internals =
    // Cast needed for closure
    (this as HTMLElement).attachInternals();

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('focusin', this.updateTabIndices.bind(this));
      this.addEventListener('update-focus', this.updateTabIndices.bind(this));
      this.addEventListener('keydown', this.handleKeyDown.bind(this));
      this.internals.role = 'toolbar';
    }
  }

  protected override render() {
    return html`<slot @slotchange=${this.updateTabIndices}></slot>`;
  }

  private handleKeyDown(event: KeyboardEvent) {
    const isLeft = event.key === 'ArrowLeft';
    const isRight = event.key === 'ArrowRight';
    const isHome = event.key === 'Home';
    const isEnd = event.key === 'End';
    // Ignore non-navigation keys
    if (!isLeft && !isRight && !isHome && !isEnd) {
      return;
    }

    const {chips} = this as {chips: MaybeMultiActionChip[]};
    // Don't try to select another chip if there aren't any.
    if (chips.length < 2) {
      return;
    }

    // Prevent default interactions, such as scrolling.
    event.preventDefault();

    if (isHome || isEnd) {
      const index = isHome ? 0 : chips.length - 1;
      chips[index].focus({trailing: isEnd});
      this.updateTabIndices();
      return;
    }

    // Check if moving forwards or backwards
    const isRtl = getComputedStyle(this).direction === 'rtl';
    const forwards = isRtl ? isLeft : isRight;
    const focusedChip = chips.find((chip) => chip.matches(':focus-within'));
    if (!focusedChip) {
      // If there is not already a chip focused, select the first or last chip
      // based on the direction we're traveling.
      const nextChip = forwards ? chips[0] : chips[chips.length - 1];
      nextChip.focus({trailing: !forwards});
      this.updateTabIndices();
      return;
    }

    const currentIndex = chips.indexOf(focusedChip);
    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;
    // Search for the next sibling that is not disabled to select.
    // If we return to the host index, there is nothing to select.
    while (nextIndex !== currentIndex) {
      if (nextIndex >= chips.length) {
        // Return to start if moving past the last item.
        nextIndex = 0;
      } else if (nextIndex < 0) {
        // Go to end if moving before the first item.
        nextIndex = chips.length - 1;
      }

      // Check if the next sibling is disabled. If so,
      // move the index and continue searching.
      //
      // Some toolbar items may be focusable when disabled for increased
      // visibility.
      const nextChip = chips[nextIndex];
      if (nextChip.disabled && !nextChip.alwaysFocusable) {
        if (forwards) {
          nextIndex++;
        } else {
          nextIndex--;
        }

        continue;
      }

      nextChip.focus({trailing: !forwards});
      this.updateTabIndices();
      break;
    }
  }

  private updateTabIndices() {
    // The chip that should be focusable is either the chip that currently has
    // focus or the first chip that can be focused.
    const {chips} = this;
    let chipToFocus: Chip | undefined;
    for (const chip of chips) {
      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;
      const chipIsFocused = chip.matches(':focus-within');
      if (chipIsFocused && isChipFocusable) {
        // Found the first chip that is actively focused. This overrides the
        // first focusable chip found.
        chipToFocus = chip;
        continue;
      }

      if (isChipFocusable && !chipToFocus) {
        chipToFocus = chip;
      }

      // Disable non-focused chips. If we disable all of them, we'll grant focus
      // to the first focusable child that was found.
      chip.tabIndex = -1;
    }

    if (chipToFocus) {
      chipToFocus.tabIndex = 0;
    }
  }
}

interface MaybeMultiActionChip extends Chip {
  focus(options?: FocusOptions & {trailing?: boolean}): void;
}


// ========== /internal/chip-set_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';
import {Harness} from '../../testing/harness.js';
import {ChipHarness} from '../harness.js';

import {AssistChip} from './assist-chip.js';
import {Chip} from './chip.js';
import {ChipSet} from './chip-set.js';
import {InputChip} from './input-chip.js';

@customElement('test-chip-set')
class TestChipSet extends ChipSet {}
@customElement('test-chip-set-assist-chip')
class TestAssistChip extends AssistChip {}
@customElement('test-chip-set-input-chip')
class TestInputChip extends InputChip {}

describe('Chip set', () => {
  const env = new Environment();

  async function setupTest(children: Node[]) {
    const chipSet = new TestChipSet();
    env.render(html`
      <style>
        /* Help visualize focus rings while debugging */
        test-chip-set-assist-chip,
        test-chip-set-input-chip,
        test-chip-set-filter-chip {
          position: relative;
        }
      </style>
      ${chipSet}
    `);
    chipSet.append(...children);
    await env.waitForStability();
    return chipSet;
  }

  describe('chips', () => {
    it('should return only chip children', async () => {
      const notAChip = document.createElement('div');
      const chip = new TestAssistChip();
      const chipSet = await setupTest([notAChip, chip]);

      expect(chipSet.chips).toEqual([chip]);
    });
  });

  describe('navigation', () => {
    it('should add tabindex="-1" to all chips except the first', async () => {
      const chipSet = await setupTest([
        new TestAssistChip(),
        new TestAssistChip(),
        new TestAssistChip(),
      ]);

      expect(chipSet.chips[0].getAttribute('tabindex'))
        .withContext('first tabindex')
        .toBe('0');
      expect(chipSet.chips[1].getAttribute('tabindex'))
        .withContext('second tabindex')
        .toBe('-1');
      expect(chipSet.chips[2].getAttribute('tabindex'))
        .withContext('third tabindex')
        .toBe('-1');
    });

    async function testNavigation({
      chipSet,
      ltrKey,
      rtlKey,
      current,
      next,
    }: {
      chipSet: ChipSet;
      ltrKey: string;
      rtlKey: string;
      current: Chip | null;
      next: Chip;
    }) {
      const harness = current ? new ChipHarness(current) : new Harness(chipSet);
      // Don't use harness focusing since we need to test real focus states
      current?.focus();
      await harness.keypress(ltrKey);
      expect(next.matches(':focus-within'))
        .withContext(`next chip is focused in LTR after ${ltrKey}`)
        .toBeTrue();

      next.blur();
      chipSet.style.direction = 'rtl';
      current?.focus();
      await harness.keypress(rtlKey);
      expect(next.matches(':focus-within'))
        .withContext(`next chip is focused in RTL after ${rtlKey}`)
        .toBeTrue();
    }

    it('should navigate forward on horizontal arrow keys', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowRight',
        rtlKey: 'ArrowLeft',
        current: first,
        next: second,
      });
    });

    it('should navigate backward on horizontal keys', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowLeft',
        rtlKey: 'ArrowRight',
        current: second,
        next: first,
      });
    });

    it('should navigate to the first chip on Home', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'Home',
        rtlKey: 'Home',
        current: second,
        next: first,
      });
    });

    it('should navigate to the last chip on End', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'End',
        rtlKey: 'End',
        current: second,
        next: third,
      });
    });

    it('should navigate to first chip on forward when none focused', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowRight',
        rtlKey: 'ArrowLeft',
        current: null,
        next: first,
      });
    });

    it('should navigate to last chip on backward when none focused', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowLeft',
        rtlKey: 'ArrowRight',
        current: null,
        next: third,
      });
    });

    it('should skip over disabled chips', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      second.disabled = true;
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowRight',
        rtlKey: 'ArrowLeft',
        current: first,
        next: third,
      });
    });

    it('should NOT skip over disabled always focusable chips', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      second.disabled = true;
      second.alwaysFocusable = true;
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowRight',
        rtlKey: 'ArrowLeft',
        current: first,
        next: second,
      });
    });

    it('should NOT skip over soft-disabled chips', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      second.softDisabled = true;
      const third = new TestAssistChip();
      const chipSet = await setupTest([first, second, third]);
      await testNavigation({
        chipSet,
        ltrKey: 'ArrowRight',
        rtlKey: 'ArrowLeft',
        current: first,
        next: second,
      });
    });

    it('should focus trailing actions when navigating backwards', async () => {
      const first = new TestInputChip();
      const second = new TestInputChip();
      const third = new TestInputChip();
      await setupTest([first, second, third]);

      const harness = new ChipHarness(second);
      // Don't use harness focusing since we need to test real focus states
      second.focus();
      await harness.keypress('ArrowLeft');
      const {trailingAction} = first as unknown as {
        trailingAction: HTMLElement;
      };
      expect(trailingAction.matches(':focus-within'))
        .withContext('trailing action of first chip is focused')
        .toBeTrue();
    });

    it('should ignore other keyboard events', async () => {
      const first = new TestAssistChip();
      const second = new TestAssistChip();
      const third = new TestAssistChip();
      await setupTest([first, second, third]);

      const harness = new ChipHarness(first);
      // Don't use harness focusing since we need to test real focus states
      first.focus();
      await harness.keypress('Enter');
      expect(first.matches(':focus-within'))
        .withContext('first chip is still focused')
        .toBeTrue();
    });

    it('should do nothing if there are not at least two chips', async () => {
      const single = new TestAssistChip();
      await setupTest([single]);

      const harness = new ChipHarness(single);
      // Don't use harness focusing since we need to test real focus states
      single.focus();
      await harness.keypress('ArrowRight');
      expect(single.matches(':focus-within'))
        .withContext('single chip is still focused')
        .toBeTrue();
    });
  });
});


// ========== /internal/chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, PropertyValues, TemplateResult} from 'lit';
import {property} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';

import {mixinDelegatesAria} from '../../internal/aria/delegate.js';

// Separate variable needed for closure.
const chipBaseClass = mixinDelegatesAria(LitElement);

/**
 * A chip component.
 *
 * @fires update-focus {Event} Dispatched when `disabled` is toggled. --bubbles
 */
export abstract class Chip extends chipBaseClass {
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Whether or not the chip is disabled.
   *
   * Disabled chips are not focusable, unless `always-focusable` is set.
   */
  @property({type: Boolean, reflect: true}) disabled = false;

  /**
   * Whether or not the chip is "soft-disabled" (disabled but still
   * focusable).
   *
   * Use this when a chip needs increased visibility when disabled. See
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_disabled_controls
   * for more guidance on when this is needed.
   */
  @property({type: Boolean, attribute: 'soft-disabled', reflect: true})
  softDisabled = false;

  /**
   * When true, allow disabled chips to be focused with arrow keys.
   *
   * Add this when a chip needs increased visibility when disabled. See
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_disabled_controls
   * for more guidance on when this is needed.
   *
   * @deprecated Use `softDisabled` instead of `alwaysFocusable` + `disabled`.
   */
  @property({type: Boolean, attribute: 'always-focusable'})
  alwaysFocusable = false;

  // TODO(b/350810013): remove the label property.
  /**
   * The label of the chip.
   *
   * @deprecated Set text as content of the chip instead.
   */
  @property() label = '';

  /**
   * Only needed for SSR.
   *
   * Add this attribute when a chip has a `slot="icon"` to avoid a Flash Of
   * Unstyled Content.
   */
  @property({type: Boolean, reflect: true, attribute: 'has-icon'}) hasIcon =
    false;

  /**
   * The `id` of the action the primary focus ring and ripple are for.
   * TODO(b/310046938): use the same id for both elements
   */
  protected abstract readonly primaryId: string;

  /**
   * Whether or not the primary ripple is disabled (defaults to `disabled`).
   * Some chip actions such as links cannot be disabled.
   */
  protected get rippleDisabled() {
    return this.disabled || this.softDisabled;
  }

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('click', this.handleClick.bind(this));
    }
  }

  override focus(options?: FocusOptions) {
    if (this.disabled && !this.alwaysFocusable) {
      return;
    }

    super.focus(options);
  }

  protected override render() {
    return html`
      <div class="container ${classMap(this.getContainerClasses())}">
        ${this.renderContainerContent()}
      </div>
    `;
  }

  protected override updated(changed: PropertyValues<Chip>) {
    if (changed.has('disabled') && changed.get('disabled') !== undefined) {
      this.dispatchEvent(new Event('update-focus', {bubbles: true}));
    }
  }

  protected getContainerClasses(): ClassInfo {
    return {
      'disabled': this.disabled || this.softDisabled,
      'has-icon': this.hasIcon,
    };
  }

  protected renderContainerContent() {
    return html`
      ${this.renderOutline()}
      <md-focus-ring part="focus-ring" for=${this.primaryId}></md-focus-ring>
      <md-ripple
        for=${this.primaryId}
        ?disabled=${this.rippleDisabled}></md-ripple>
      ${this.renderPrimaryAction(this.renderPrimaryContent())}
    `;
  }

  protected renderOutline() {
    return html`<span class="outline"></span>`;
  }

  protected renderLeadingIcon(): TemplateResult {
    return html`<slot name="icon" @slotchange=${this.handleIconChange}></slot>`;
  }

  protected abstract renderPrimaryAction(content: unknown): unknown;

  private renderPrimaryContent() {
    return html`
      <span class="leading icon" aria-hidden="true">
        ${this.renderLeadingIcon()}
      </span>
      <span class="label">
        <span class="label-text" id="label">
          ${this.label ? this.label : html`<slot></slot>`}
        </span>
      </span>
      <span class="touch"></span>
    `;
  }

  private handleIconChange(event: Event) {
    const slot = event.target as HTMLSlotElement;
    this.hasIcon = slot.assignedElements({flatten: true}).length > 0;
  }

  private handleClick(event: Event) {
    // If the chip is soft-disabled or disabled + always-focusable, we need to
    // explicitly prevent the click from propagating to other event listeners
    // as well as prevent the default action.
    if (this.softDisabled || (this.disabled && this.alwaysFocusable)) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }
}


// ========== /internal/chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';
import {ChipHarness} from '../harness.js';

import {Chip} from './chip.js';

@customElement('test-chip')
class TestChip extends Chip {
  primaryId = 'button';

  override renderPrimaryAction() {
    return html`<button id=${this.primaryId}>Chip</button>`;
  }
}

describe('Chip', () => {
  const env = new Environment();

  async function setupTest() {
    const chip = new TestChip();
    env.render(html`${chip}`);
    await env.waitForStability();
    return {chip, harness: new ChipHarness(chip)};
  }

  it('should dispatch `update-focus` for chip set when disabled changes', async () => {
    const {chip} = await setupTest();
    const updateFocusListener = jasmine.createSpy('updateFocusListener');
    chip.addEventListener('update-focus', updateFocusListener);

    chip.disabled = true;
    await env.waitForStability();
    expect(updateFocusListener).toHaveBeenCalled();
  });
});


/* ========== /internal/elevated-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './elevated';
// go/keep-sorted end

@include elevated.styles;


// ========== /internal/filter-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';

import {html, nothing} from 'lit';
import {property, query} from 'lit/decorators.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';

import {MultiActionChip} from './multi-action-chip.js';
import {renderRemoveButton} from './trailing-icons.js';

/**
 * A filter chip component.
 *
 * @fires remove {Event} Dispatched when the remove button is clicked.
 */
export class FilterChip extends MultiActionChip {
  @property({type: Boolean}) elevated = false;
  @property({type: Boolean}) removable = false;
  @property({type: Boolean, reflect: true}) selected = false;

  /**
   * Only needed for SSR.
   *
   * Add this attribute when a filter chip has a `slot="selected-icon"` to avoid
   * a Flash Of Unstyled Content.
   */
  @property({type: Boolean, reflect: true, attribute: 'has-selected-icon'})
  hasSelectedIcon = false;

  protected get primaryId() {
    return 'button';
  }

  @query('.primary.action')
  protected readonly primaryAction!: HTMLElement | null;
  @query('.trailing.action')
  protected readonly trailingAction!: HTMLElement | null;

  protected override getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      elevated: this.elevated,
      selected: this.selected,
      'has-trailing': this.removable,
      'has-icon': this.hasIcon || this.selected,
    };
  }

  protected override renderPrimaryAction(content: unknown) {
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || nothing}
        aria-pressed=${this.selected}
        aria-disabled=${this.softDisabled || nothing}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        @click=${this.handleClickOnChild}
        >${content}</button
      >
    `;
  }

  protected override renderLeadingIcon() {
    if (!this.selected) {
      return super.renderLeadingIcon();
    }

    return html`
      <slot name="selected-icon">
        <svg class="checkmark" viewBox="0 0 18 18" aria-hidden="true">
          <path
            d="M6.75012 12.1274L3.62262 8.99988L2.55762 10.0574L6.75012 14.2499L15.7501 5.24988L14.6926 4.19238L6.75012 12.1274Z" />
        </svg>
      </slot>
    `;
  }

  protected override renderTrailingAction(focusListener: EventListener) {
    if (this.removable) {
      return renderRemoveButton({
        focusListener,
        ariaLabel: this.ariaLabelRemove,
        disabled: this.disabled || this.softDisabled,
      });
    }

    return nothing;
  }

  protected override renderOutline() {
    if (this.elevated) {
      return html`<md-elevation part="elevation"></md-elevation>`;
    }

    return super.renderOutline();
  }

  private handleClickOnChild(event: MouseEvent) {
    if (this.disabled || this.softDisabled) {
      return;
    }

    // Store prevValue to revert in case `chip.selected` is changed during an
    // event listener.
    const prevValue = this.selected;
    this.selected = !this.selected;

    const preventDefault = !redispatchEvent(this, event);
    if (preventDefault) {
      // We should not do `this.selected = !this.selected`, since a client
      // click listener could change its value. Instead, always revert to the
      // original value.
      this.selected = prevValue;
      return;
    }
  }
}


// ========== /internal/filter-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';
import {ChipHarness} from '../harness.js';

import {FilterChip} from './filter-chip.js';

@customElement('test-filter-chip')
class TestFilterChip extends FilterChip {
  declare primaryAction: HTMLElement;
}

describe('Filter chip', () => {
  const env = new Environment();

  async function setupTest() {
    const chip = new TestFilterChip();
    env.render(html`${chip}`);
    await env.waitForStability();
    return {chip, harness: new ChipHarness(chip)};
  }

  describe('selection', () => {
    it('should select on click', async () => {
      const {chip, harness} = await setupTest();

      await harness.clickWithMouse();
      expect(chip.selected).withContext('chip.selected').toBeTrue();
    });

    it('should deselect on click', async () => {
      const {chip, harness} = await setupTest();
      chip.selected = true;

      await harness.clickWithMouse();
      expect(chip.selected).withContext('chip.selected').toBeFalse();
    });

    it('should not select on click when disabled', async () => {
      const {chip, harness} = await setupTest();
      chip.disabled = true;

      await harness.clickWithMouse();
      expect(chip.selected).withContext('chip.selected').toBeFalse();
    });

    it('should not select on click when soft-disabled', async () => {
      // Arrange
      const {chip, harness} = await setupTest();
      chip.softDisabled = true;

      // Act
      await harness.clickWithMouse();

      // Assert
      expect(chip.selected).withContext('chip.selected').toBeFalse();
    });

    it('can prevent default', async () => {
      const {chip, harness} = await setupTest();
      const handler = jasmine.createSpy();
      chip.addEventListener('selected', handler);

      chip.addEventListener('click', (event) => {
        event.preventDefault();
      });

      await harness.clickWithMouse();
      await harness.clickWithMouse();
      expect(handler).toHaveBeenCalledTimes(0);
    });

    it('always reverts value on preventDefault() even if selected is changed in listener', async () => {
      const {chip, harness} = await setupTest();

      chip.addEventListener(
        'click',
        (event) => {
          event.preventDefault();
          chip.selected = false;
        },
        {once: true},
      );

      await harness.clickWithMouse();
      expect(chip.selected)
        .withContext('chip.selected reverts to false')
        .toBeFalse();

      chip.selected = true;
      chip.addEventListener(
        'click',
        (event) => {
          event.preventDefault();
          chip.selected = false;
        },
        {once: true},
      );

      await harness.clickWithMouse();
      expect(chip.selected)
        .withContext('chip.selected reverts to true')
        .toBeTrue();
    });
  });

  it('should be focusable when soft-disabled', async () => {
    // Arrange
    const {chip} = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Act
    chip.focus();

    // Assert
    expect(document.activeElement)
      .withContext('soft-disabled chip should be focused')
      .toBe(chip);
  });

  it('should not be clickable when soft-disabled', async () => {
    // Arrange
    const clickListener = jasmine.createSpy('clickListener');
    const {chip, harness} = await setupTest();
    chip.softDisabled = true;
    chip.addEventListener('click', clickListener);

    // Act
    await harness.clickWithMouse();

    // Assert
    expect(clickListener).not.toHaveBeenCalled();
  });

  it('should use aria-disabled when soft-disabled', async () => {
    // Arrange
    // Act
    const {chip} = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Assert
    expect(chip.renderRoot.querySelector('button[aria-disabled="true"]'))
      .withContext('should have aria-disabled="true"')
      .not.toBeNull();
  });
});


/* ========== /internal/filter-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filter-chip';
// go/keep-sorted end

@include filter-chip.styles;


// ========== /internal/input-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, nothing} from 'lit';
import {property, query} from 'lit/decorators.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';

import {MultiActionChip} from './multi-action-chip.js';
import {renderRemoveButton} from './trailing-icons.js';

/**
 * An input chip component.
 *
 * @fires remove {Event} Dispatched when the remove button is clicked.
 */
export class InputChip extends MultiActionChip {
  @property({type: Boolean}) avatar = false;
  @property() href = '';
  @property() target: '_blank' | '_parent' | '_self' | '_top' | '' = '';
  @property({type: Boolean, attribute: 'remove-only'}) removeOnly = false;
  @property({type: Boolean, reflect: true}) selected = false;

  protected get primaryId() {
    if (this.href) {
      return 'link';
    }

    if (this.removeOnly) {
      return '';
    }

    return 'button';
  }

  protected override get rippleDisabled() {
    // Link chips cannot be disabled
    return !this.href && (this.disabled || this.softDisabled);
  }

  protected get primaryAction() {
    // Don't use @query() since a remove-only input chip still has a span that
    // has "primary action" classes.
    if (this.removeOnly) {
      return null;
    }

    return this.renderRoot.querySelector<HTMLElement>('.primary.action');
  }

  @query('.trailing.action')
  protected readonly trailingAction!: HTMLElement | null;

  protected override getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      avatar: this.avatar,
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      link: !!this.href,
      selected: this.selected,
      'has-trailing': true,
    };
  }

  protected override renderPrimaryAction(content: unknown) {
    const {ariaLabel} = this as ARIAMixinStrict;
    if (this.href) {
      return html`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || nothing}
          href=${this.href}
          target=${this.target || nothing}
          >${content}</a
        >
      `;
    }

    if (this.removeOnly) {
      return html`
        <span class="primary action" aria-label=${ariaLabel || nothing}>
          ${content}
        </span>
      `;
    }

    return html`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || nothing}
        aria-disabled=${this.softDisabled || nothing}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }

  protected override renderTrailingAction(focusListener: EventListener) {
    return renderRemoveButton({
      focusListener,
      ariaLabel: this.ariaLabelRemove,
      disabled: !this.href && (this.disabled || this.softDisabled),
      tabbable: this.removeOnly,
    });
  }
}


// ========== /internal/input-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';

import {Environment} from '../../testing/environment.js';

import {InputChip} from './input-chip.js';

customElements.define('test-input-chip', InputChip);

describe('Input chip', () => {
  const env = new Environment();

  async function setupTest() {
    const chip = new InputChip();
    env.render(html`${chip}`);
    await env.waitForStability();
    return chip;
  }

  describe('links', () => {
    it('should render a link when provided an href', async () => {
      const chip = await setupTest();
      chip.href = 'link';
      await chip.updateComplete;

      expect(chip.renderRoot.querySelector('a'))
        .withContext('should have a rendered <a> link')
        .toBeTruthy();
    });

    it('should not allow link chips to be disabled', async () => {
      const chip = await setupTest();
      chip.href = 'link';
      chip.disabled = true;
      await chip.updateComplete;

      expect(chip.renderRoot.querySelector('.disabled,:disabled'))
        .withContext('should not have any disabled styling or behavior')
        .toBeNull();
    });

    it('should not allow link chips to be soft-disabled', async () => {
      // Arrange
      // Act
      const chip = await setupTest();
      chip.href = 'link';
      chip.softDisabled = true;
      await chip.updateComplete;

      // Assert
      expect(chip.renderRoot.querySelector('.disabled,:disabled'))
        .withContext('should not have any disabled styling or behavior')
        .toBeNull();
    });
  });

  it('should use aria-disabled when soft-disabled', async () => {
    // Arrange
    // Act
    const chip = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Assert
    expect(chip.renderRoot.querySelector('button[aria-disabled="true"]'))
      .withContext('should have aria-disabled="true"')
      .not.toBeNull();
  });

  it('should be focusable when soft-disabled', async () => {
    // Arrange
    const chip = await setupTest();
    chip.softDisabled = true;
    await chip.updateComplete;

    // Act
    chip.focus();

    // Assert
    expect(document.activeElement)
      .withContext('soft-disabled chip should be focused')
      .toBe(chip);
  });

  it('should not be clickable when soft-disabled', async () => {
    // Arrange
    const clickListener = jasmine.createSpy('clickListener');
    const chip = await setupTest();
    chip.softDisabled = true;
    chip.addEventListener('click', clickListener);

    // Act
    chip.click();

    // Assert
    expect(clickListener).not.toHaveBeenCalled();
  });
});


/* ========== /internal/input-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './input-chip';
// go/keep-sorted end

@include input-chip.styles;


// ========== /internal/multi-action-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, isServer} from 'lit';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';

import {Chip} from './chip.js';

const ARIA_LABEL_REMOVE = 'aria-label-remove';

/**
 * A chip component with multiple actions.
 */
export abstract class MultiActionChip extends Chip {
  get ariaLabelRemove(): string | null {
    if (this.hasAttribute(ARIA_LABEL_REMOVE)) {
      return this.getAttribute(ARIA_LABEL_REMOVE)!;
    }

    const {ariaLabel} = this as ARIAMixinStrict;

    // TODO(b/350810013): remove `this.label` when label property is removed.
    if (ariaLabel || this.label) {
      return `Remove ${ariaLabel || this.label}`;
    }

    return null;
  }

  set ariaLabelRemove(ariaLabel: string | null) {
    const prev = this.ariaLabelRemove;
    if (ariaLabel === prev) {
      return;
    }

    if (ariaLabel === null) {
      this.removeAttribute(ARIA_LABEL_REMOVE);
    } else {
      this.setAttribute(ARIA_LABEL_REMOVE, ariaLabel);
    }

    this.requestUpdate();
  }

  protected abstract readonly primaryAction: HTMLElement | null;
  protected abstract readonly trailingAction: HTMLElement | null;

  constructor() {
    super();
    this.handleTrailingActionFocus = this.handleTrailingActionFocus.bind(this);
    if (!isServer) {
      this.addEventListener('keydown', this.handleKeyDown.bind(this));
    }
  }

  override focus(options?: FocusOptions & {trailing?: boolean}) {
    const isFocusable = this.alwaysFocusable || !this.disabled;
    if (isFocusable && options?.trailing && this.trailingAction) {
      this.trailingAction.focus(options);
      return;
    }

    super.focus(options as FocusOptions);
  }

  protected override renderContainerContent() {
    return html`
      ${super.renderContainerContent()}
      ${this.renderTrailingAction(this.handleTrailingActionFocus)}
    `;
  }

  protected abstract renderTrailingAction(
    focusListener: EventListener,
  ): unknown;

  private handleKeyDown(event: KeyboardEvent) {
    const isLeft = event.key === 'ArrowLeft';
    const isRight = event.key === 'ArrowRight';
    // Ignore non-navigation keys.
    if (!isLeft && !isRight) {
      return;
    }

    if (!this.primaryAction || !this.trailingAction) {
      // Does not have multiple actions.
      return;
    }

    // Check if moving forwards or backwards
    const isRtl = getComputedStyle(this).direction === 'rtl';
    const forwards = isRtl ? isLeft : isRight;
    const isPrimaryFocused = this.primaryAction?.matches(':focus-within');
    const isTrailingFocused = this.trailingAction?.matches(':focus-within');

    if ((forwards && isTrailingFocused) || (!forwards && isPrimaryFocused)) {
      // Moving outside of the chip, it will be handled by the chip set.
      return;
    }

    // Prevent default interactions, such as scrolling.
    event.preventDefault();
    // Don't let the chip set handle this navigation event.
    event.stopPropagation();
    const actionToFocus = forwards ? this.trailingAction : this.primaryAction;
    actionToFocus.focus();
  }

  private handleTrailingActionFocus() {
    const {primaryAction, trailingAction} = this;
    if (!primaryAction || !trailingAction) {
      return;
    }

    // Temporarily turn off the primary action's focusability. This allows
    // shift+tab from the trailing action to move to the previous chip rather
    // than the primary action in the same chip.
    primaryAction.tabIndex = -1;
    trailingAction.addEventListener(
      'focusout',
      () => {
        primaryAction.tabIndex = 0;
      },
      {once: true},
    );
  }
}


// ========== /internal/multi-action-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {css, html, nothing} from 'lit';
import {customElement, property, query} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';
import {ChipHarness} from '../harness.js';

import {MultiActionChip} from './multi-action-chip.js';
import {renderRemoveButton} from './trailing-icons.js';

@customElement('test-multi-action-chip')
class TestMultiActionChip extends MultiActionChip {
  static override styles = css`
    :host {
      position: relative;
    }
  `;

  @query('#primary') primaryAction!: HTMLElement;
  @query('.trailing.action') trailingAction!: HTMLElement;
  @property() noTrailingAction = false;

  protected primaryId = 'primary';

  protected override renderPrimaryAction(content: unknown) {
    return html`<button id="primary">${content}</button>`;
  }

  protected override renderTrailingAction(focusListener: EventListener) {
    if (this.noTrailingAction) {
      return nothing;
    }

    return renderRemoveButton({
      focusListener,
      ariaLabel: this.ariaLabelRemove,
      disabled: this.disabled,
    });
  }
}

describe('Multi-action chips', () => {
  const env = new Environment();

  async function setupTest(
    template = html`<test-multi-action-chip></test-multi-action-chip>`,
  ): Promise<TestMultiActionChip> {
    const root = env.render(template);
    await env.waitForStability();
    const chip = root.querySelector<TestMultiActionChip>(
      'test-multi-action-chip',
    );
    if (!chip) {
      throw new Error('Failed to query the rendered <test-multi-action-chip>');
    }

    return chip;
  }

  describe('navigation', () => {
    it('should move internal focus forwards', async () => {
      const chip = await setupTest();
      const primaryHarness = new ChipHarness(chip);

      await primaryHarness.focusWithKeyboard();
      expect(chip.primaryAction.matches(':focus-within'))
        .withContext('primary action is focused')
        .toBeTrue();

      await primaryHarness.keypress('ArrowRight');
      expect(chip.trailingAction.matches(':focus-within'))
        .withContext('trailing action is focused')
        .toBeTrue();
    });

    it('should move internal focus forwards in rtl', async () => {
      const chip = await setupTest();
      chip.style.direction = 'rtl';
      const primaryHarness = new ChipHarness(chip);

      await primaryHarness.focusWithKeyboard();
      expect(chip.primaryAction.matches(':focus-within'))
        .withContext('primary action is focused')
        .toBeTrue();

      await primaryHarness.keypress('ArrowLeft');
      expect(chip.trailingAction.matches(':focus-within'))
        .withContext('trailing action is focused')
        .toBeTrue();
    });

    it('should move internal focus backwards', async () => {
      const chip = await setupTest();
      const trailingHarness = new ChipHarness(chip);
      trailingHarness.action = 'trailing';

      await trailingHarness.focusWithKeyboard();
      expect(chip.trailingAction.matches(':focus-within'))
        .withContext('trailing action is focused')
        .toBeTrue();

      await trailingHarness.keypress('ArrowLeft');
      expect(chip.primaryAction.matches(':focus-within'))
        .withContext('primary action is focused')
        .toBeTrue();
    });

    it('should move internal focus backwards in rtl', async () => {
      const chip = await setupTest();
      chip.style.direction = 'rtl';
      const trailingHarness = new ChipHarness(chip);
      trailingHarness.action = 'trailing';

      await trailingHarness.focusWithKeyboard();
      expect(chip.trailingAction.matches(':focus-within'))
        .withContext('trailing action is focused')
        .toBeTrue();

      await trailingHarness.keypress('ArrowRight');
      expect(chip.primaryAction.matches(':focus-within'))
        .withContext('primary action is focused')
        .toBeTrue();
    });

    it('should not bubble when navigating internally', async () => {
      const chip = await setupTest();
      const primaryHarness = new ChipHarness(chip);
      const keydownHandler = jasmine.createSpy();
      if (!chip.parentElement) {
        throw new Error('Expected chip to have a parentElement for test.');
      }

      chip.parentElement.addEventListener('keydown', keydownHandler);

      await primaryHarness.focusWithKeyboard();
      await primaryHarness.keypress('ArrowRight');
      expect(keydownHandler).not.toHaveBeenCalled();
    });

    it('should bubble event when navigating forward past trailing action', async () => {
      const chip = await setupTest();
      const trailingHarness = new ChipHarness(chip);
      trailingHarness.action = 'trailing';
      const keydownHandler = jasmine.createSpy();
      if (!chip.parentElement) {
        throw new Error('Expected chip to have a parentElement for test.');
      }

      chip.parentElement.addEventListener('keydown', keydownHandler);

      await trailingHarness.focusWithKeyboard();
      await trailingHarness.keypress('ArrowRight');
      expect(keydownHandler).toHaveBeenCalledTimes(1);
    });

    it('should bubble event when navigating backward before primary action', async () => {
      const chip = await setupTest();
      const primaryHarness = new ChipHarness(chip);
      const keydownHandler = jasmine.createSpy();
      if (!chip.parentElement) {
        throw new Error('Expected chip to have a parentElement for test.');
      }

      chip.parentElement.addEventListener('keydown', keydownHandler);

      await primaryHarness.focusWithKeyboard();
      await primaryHarness.keypress('ArrowLeft');
      expect(keydownHandler).toHaveBeenCalledTimes(1);
    });

    it('should do nothing if it does not have multiple actions', async () => {
      const chip = await setupTest();
      chip.noTrailingAction = true;
      await env.waitForStability();

      const primaryHarness = new ChipHarness(chip);
      await primaryHarness.focusWithKeyboard();
      await primaryHarness.keypress('ArrowLeft');
      expect(chip.primaryAction.matches(':focus-within'))
        .withContext('primary action is still focused')
        .toBeTrue();
    });
  });

  describe('remove action', () => {
    it('should remove chip from DOM when remove button clicked', async () => {
      const chip = await setupTest();
      const harness = new ChipHarness(chip);
      harness.action = 'trailing';

      expect(chip.parentElement)
        .withContext('chip should be attached before removing')
        .not.toBeNull();
      await harness.clickWithMouse();
      expect(chip.parentElement)
        .withContext('chip should be detached after removing')
        .toBeNull();
    });

    it('should dispatch a "remove" event when removed', async () => {
      const chip = await setupTest();
      const harness = new ChipHarness(chip);
      harness.action = 'trailing';
      const handler = jasmine.createSpy();
      chip.addEventListener('remove', handler);

      await harness.clickWithMouse();
      expect(handler).toHaveBeenCalledTimes(1);
    });

    it('should not remove chip if "remove" event is default prevented', async () => {
      const chip = await setupTest();
      const harness = new ChipHarness(chip);
      harness.action = 'trailing';
      chip.addEventListener('remove', (event) => {
        event.preventDefault();
      });

      await harness.clickWithMouse();
      expect(chip.parentElement)
        .withContext('chip should still be attached')
        .not.toBeNull();
    });

    it('should provide a default "ariaLabelRemove" value', async () => {
      const label = 'Label';
      const chip = await setupTest(
        html`<test-multi-action-chip>${label}</test-multi-action-chip>`,
      );

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(`Remove ${label}`);
    });

    it('should provide a default "ariaLabelRemove" when "ariaLabel" is provided', async () => {
      const label = 'Label';
      const chip = await setupTest(
        html`<test-multi-action-chip aria-label=${'Descriptive label'}>
          ${label}
        </test-multi-action-chip>`,
      );

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(
        `Remove ${chip.ariaLabel}`,
      );
    });

    it('should allow setting a custom "ariaLabelRemove"', async () => {
      const label = 'Label';
      const customAriaLabelRemove = 'Remove custom label';
      const chip = await setupTest(
        html`<test-multi-action-chip
          aria-label=${'Descriptive label'}
          aria-label-remove=${customAriaLabelRemove}>
          ${label}
        </test-multi-action-chip>`,
      );

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(
        customAriaLabelRemove,
      );
    });

    // TODO(b/350810013): remove test when label property is removed.
    it('should provide a default "ariaLabelRemove" value (using the label property)', async () => {
      const chip = await setupTest();
      chip.label = 'Label';
      await env.waitForStability();

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(
        `Remove ${chip.label}`,
      );
    });

    // TODO(b/350810013): remove test when label property is removed.
    it('should provide a default "ariaLabelRemove" when "ariaLabel" is provided (using the label property)', async () => {
      const chip = await setupTest();
      chip.label = 'Label';
      chip.ariaLabel = 'Descriptive label';
      await env.waitForStability();

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(
        `Remove ${chip.ariaLabel}`,
      );
    });

    // TODO(b/350810013): remove test when label property is removed.
    it('should allow setting a custom "ariaLabelRemove" (using the label property)', async () => {
      const chip = await setupTest();
      chip.label = 'Label';
      chip.ariaLabel = 'Descriptive label';
      const customAriaLabelRemove = 'Remove custom label';
      chip.ariaLabelRemove = customAriaLabelRemove;
      await env.waitForStability();

      expect(getA11yLabelForChipRemoveButton(chip)).toEqual(
        customAriaLabelRemove,
      );
    });
  });
});

/**
 * Returns the text content of a slot.
 */
function getSlotTextContent(slot: HTMLSlotElement) {
  // Remove any newlines, comments, and whitespace from the label slot.
  let text = '';
  for (const node of slot.assignedNodes() ?? []) {
    if (node.nodeType === Node.TEXT_NODE) {
      text += node.textContent?.trim() || '';
    }
  }
  return text;
}

/**
 * Returns the a11y label of the remove button. If the button has an aria-label,
 * it will return that. If it has aria-labelledby, it will return the text
 * content of the elements it is labelled by.
 */
function getA11yLabelForChipRemoveButton(chip: TestMultiActionChip): string {
  const removeButton = chip.shadowRoot!.querySelector<HTMLButtonElement>(
    'button.trailing.action',
  )!;

  if (removeButton.ariaLabel) {
    return removeButton.ariaLabel;
  }

  // If the remove button is not aria-labelled, it should be aria-labelledby.
  const removeButtonAriaLabelledBy =
    removeButton.getAttribute('aria-labelledby')!;
  const elementsLabelledBy: HTMLElement[] = [];
  removeButtonAriaLabelledBy.split(' ').forEach((id) => {
    const labelledByElement = chip.shadowRoot?.getElementById(id);
    if (!labelledByElement) {
      throw new Error(
        `Cannot find element with ID "#{id}" in the chip's shadow root`,
      );
    }
    elementsLabelledBy.push(labelledByElement);
  });
  const textFromAriaLabelledBy: string[] = [];
  elementsLabelledBy.forEach((element) => {
    const unnamedSlotChildElement =
      element.querySelector<HTMLSlotElement>('slot:not([name])');
    if (unnamedSlotChildElement) {
      textFromAriaLabelledBy.push(getSlotTextContent(unnamedSlotChildElement));
    } else {
      textFromAriaLabelledBy.push(element.textContent ?? '');
    }
  });
  return textFromAriaLabelledBy.join(' ');
}


/* ========== /internal/selectable-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './selectable';
// go/keep-sorted end

@include selectable.styles;


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /internal/suggestion-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {AssistChip} from './assist-chip.js';

/**
 * A suggestion chip component.
 */
export class SuggestionChip extends AssistChip {}

// Note: assist and suggestion chips are functionally identical with different
// tokens.


// ========== /internal/suggestion-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {AssistChip} from './assist-chip.js';
import {SuggestionChip} from './suggestion-chip.js';

customElements.define('test-suggestion-chip', SuggestionChip);

describe('Suggestion chip', () => {
  it('should be an assist chip', () => {
    expect(new SuggestionChip()).toBeInstanceOf(AssistChip);
  });
});


/* ========== /internal/suggestion-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './suggestion-chip';
// go/keep-sorted end

@include suggestion-chip.styles;


/* ========== /internal/trailing-icon-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './trailing-icon';
// go/keep-sorted end

@include trailing-icon.styles;


// ========== /internal/trailing-icons.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, nothing} from 'lit';

import {Chip} from './chip.js';

interface RemoveButtonProperties {
  ariaLabel: string | null;
  disabled: boolean;
  focusListener: EventListener;
  tabbable?: boolean;
}

/** @protected */
export function renderRemoveButton({
  ariaLabel,
  disabled,
  focusListener,
  tabbable = false,
}: RemoveButtonProperties) {
  // When an aria-label is not provided, we use two spans with aria-labelledby
  // to create the "Remove <textContent>" label for the remove button. The first
  // is this #remove-label span, the second is the chip's #label slot span.
  return html`
    <span id="remove-label" hidden aria-hidden="true">Remove</span>
    <button
      class="trailing action"
      aria-label=${ariaLabel || nothing}
      aria-labelledby=${!ariaLabel ? 'remove-label label' : nothing}
      tabindex=${!tabbable ? -1 : nothing}
      @click=${handleRemoveClick}
      @focus=${focusListener}>
      <md-focus-ring part="trailing-focus-ring"></md-focus-ring>
      <md-ripple ?disabled=${disabled}></md-ripple>
      <span class="trailing icon" aria-hidden="true">
        <slot name="remove-trailing-icon">
          <svg viewBox="0 96 960 960">
            <path
              d="m249 849-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z" />
          </svg>
        </slot>
      </span>
      <span class="touch"></span>
    </button>
  `;
}

function handleRemoveClick(this: Chip, event: Event) {
  if (this.disabled || this.softDisabled) {
    return;
  }

  event.stopPropagation();
  const preventDefault = !this.dispatchEvent(
    new Event('remove', {cancelable: true}),
  );
  if (preventDefault) {
    return;
  }

  this.remove();
}


// ========== /suggestion-chip.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles as elevatedStyles} from './internal/elevated-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';
import {SuggestionChip} from './internal/suggestion-chip.js';
import {styles} from './internal/suggestion-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-suggestion-chip': MdSuggestionChip;
  }
}

/**
 * TODO(b/243982145): add docs
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-suggestion-chip')
export class MdSuggestionChip extends SuggestionChip {
  static override styles: CSSResultOrNative[] = [sharedStyles, elevatedStyles, styles];
}


// ========== /suggestion-chip_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdSuggestionChip} from './suggestion-chip.js';

describe('<md-suggestion-chip>', () => {
  describe('.styles', () => {
    createTokenTests(MdSuggestionChip.styles);
  });
});