/* ========== /_filled-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-field' show theme;


/* ========== /_outlined-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/outlined-field' show theme;


// ========== /filled-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {FilledField} from './internal/filled-field.js';
import {styles as filledStyles} from './internal/filled-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-field': MdFilledField;
  }
}

/**
 * TODO(b/228525797): add docs
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-field')
export class MdFilledField extends FilledField {
  static override styles: CSSResultOrNative[] = [sharedStyles, filledStyles];
}


// ========== /filled-field_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdFilledField} from './filled-field.js';

describe('<md-filled-field>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledField.styles);
  });
});


/* ========== /internal/_content.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
@use 'sass:math';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();
// Duration of the label animation.
$_label-duration: map.get($_md-sys-motion, 'duration-short3');
// Duration of the content's visibility animation.
$_visible-duration: math.round(math.div($_label-duration * 5, 9));
// Short delay when entering (focusing/populating) so that the label may move
// out of the way before the content starts to appear.
$_enter-delay: $_label-duration - $_visible-duration;

@mixin styles() {
  @layer styles {
    .start,
    .middle,
    .end {
      display: flex;
      box-sizing: border-box;
      height: 100%;
      // Relative position for absolutely positioned labels (to avoid interfering
      // with baseline alignment).
      position: relative;
    }

    .start {
      color: var(--_leading-content-color);
    }

    .end {
      color: var(--_trailing-content-color);
    }

    .start,
    .end {
      align-items: center;
      justify-content: center;
    }

    .with-start .start {
      margin-inline: var(--_with-leading-content-leading-space)
        var(--_content-space);
    }

    .with-end .end {
      margin-inline: var(--_content-space)
        var(--_with-trailing-content-trailing-space);
    }

    .middle {
      align-items: stretch;
      // The container of the field aligns sections by "center". Only the middle
      // section opts in to baseline alignment.
      //
      // Labels are absolutely positioned, which leaves only the content as the
      // evaluated baseline for the field.
      //
      // See https://www.w3.org/TR/css-flexbox-1/#baseline-participation
      align-self: baseline;
      flex: 1;
    }

    .content {
      color: var(--_content-color);
      display: flex;
      flex: 1;
      opacity: 0;
      transition: opacity $_visible-duration
        map.get($_md-sys-motion, 'easing-emphasized');
    }

    .no-label .content,
    .focused .content,
    .populated .content {
      opacity: 1;
      transition-delay: $_enter-delay;
    }

    :is(.disabled, .disable-transitions) .content {
      transition: none;
    }

    .content ::slotted(*) {
      all: unset;
      // Use `currentColor` to inherit the various state colors that are set
      // below.
      color: currentColor;
      font-family: var(--_content-font);
      font-size: var(--_content-size);
      line-height: var(--_content-line-height);
      font-weight: var(--_content-weight);
      width: 100%;
      // Reverting values before "all: unset"
      overflow-wrap: revert; // Needed to break words in textarea
      white-space: revert; // Needed for Firefox textarea
    }

    .content ::slotted(:not(textarea)) {
      padding-top: var(--_top-space);
      padding-bottom: var(--_bottom-space);
    }

    .content ::slotted(textarea) {
      // Use margin for textareas since they will scroll over the label if not.
      margin-top: var(--_top-space);
      margin-bottom: var(--_bottom-space);
    }

    :hover .content {
      color: var(--_hover-content-color);
    }

    :hover .start {
      color: var(--_hover-leading-content-color);
    }

    :hover .end {
      color: var(--_hover-trailing-content-color);
    }

    .focused .content {
      color: var(--_focus-content-color);
    }

    .focused .start {
      color: var(--_focus-leading-content-color);
    }

    .focused .end {
      color: var(--_focus-trailing-content-color);
    }

    .disabled .content {
      color: var(--_disabled-content-color);
    }

    .disabled.no-label .content,
    .disabled.focused .content,
    .disabled.populated .content {
      opacity: var(--_disabled-content-opacity);
    }

    .disabled .start {
      color: var(--_disabled-leading-content-color);
      opacity: var(--_disabled-leading-content-opacity);
    }

    .disabled .end {
      color: var(--_disabled-trailing-content-color);
      opacity: var(--_disabled-trailing-content-opacity);
    }

    .error .content {
      color: var(--_error-content-color);
    }

    .error .start {
      color: var(--_error-leading-content-color);
    }

    .error .end {
      color: var(--_error-trailing-content-color);
    }

    .error:hover .content {
      color: var(--_error-hover-content-color);
    }

    .error:hover .start {
      color: var(--_error-hover-leading-content-color);
    }

    .error:hover .end {
      color: var(--_error-hover-trailing-content-color);
    }

    .error.focused .content {
      color: var(--_error-focus-content-color);
    }

    .error.focused .start {
      color: var(--_error-focus-leading-content-color);
    }

    .error.focused .end {
      color: var(--_error-focus-trailing-content-color);
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .disabled :is(.start, .content, .end) {
        color: GrayText;
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/_filled-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:meta';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();

@mixin theme($tokens) {
  $supported-tokens: list.join(
    tokens.$md-comp-filled-field-supported-tokens,
    (
      'container-shape-start-start',
      'container-shape-start-end',
      'container-shape-end-end',
      'container-shape-end-start'
    )
  );

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $token == 'container-shape' and meta.type-of($value) == 'list' {
      @error 'Filled field `container-shape` may not be specified as a list. Use logical (`*-start-start`) tokens instead.';
    }

    @if $value {
      --md-filled-field-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-field-values();

  @layer styles {
    :host {
      // Only use the logical properties.
      $tokens: map.remove($tokens, 'container-shape');
      @each $token, $value in $tokens {
        --_#{$token}: #{$value};
      }
    }

    .background,
    .state-layer {
      border-radius: inherit;
      inset: 0;
      pointer-events: none;
      position: absolute;
    }

    .background {
      background: var(--_container-color);
    }

    .state-layer {
      visibility: hidden;
    }

    .field:not(.disabled):hover .state-layer {
      visibility: visible;
    }

    .label.floating {
      position: absolute;
      top: var(--_with-label-top-space);
    }

    .field:not(.with-start) .label-wrapper {
      margin-inline-start: var(--_leading-space);
    }

    .field:not(.with-end) .label-wrapper {
      margin-inline-end: var(--_trailing-space);
    }

    .active-indicator {
      inset: auto 0 0 0;
      // Prevent click events on the indicator element since it has no width and
      // causes bugs when handled by the foundation for updating transform-origin.
      pointer-events: none;
      position: absolute;
      width: 100%;
      z-index: 1;

      &::before,
      &::after {
        border-bottom: var(--_active-indicator-height) solid
          var(--_active-indicator-color);
        inset: auto 0 0 0;
        content: '';
        position: absolute;
        width: 100%;
      }

      // focused indicator
      &::after {
        opacity: 0;
        transition: opacity map.get($_md-sys-motion, 'duration-short3')
          map.get($_md-sys-motion, 'easing-emphasized');
      }
    }

    .focused .active-indicator::after {
      opacity: 1;
    }

    .field:not(.with-start) .content ::slotted(*) {
      padding-inline-start: var(--_leading-space);
    }

    .field:not(.with-end) .content ::slotted(*) {
      padding-inline-end: var(--_trailing-space);
    }

    .field:not(.no-label) .content ::slotted(:not(textarea)) {
      padding-bottom: var(--_with-label-bottom-space);
      padding-top: calc(
        var(--_with-label-top-space) + var(--_label-text-populated-line-height)
      );
    }

    .field:not(.no-label) .content ::slotted(textarea) {
      // Use margin for textareas since they will scroll over the label if not.
      margin-bottom: var(--_with-label-bottom-space);
      margin-top: calc(
        var(--_with-label-top-space) + var(--_label-text-populated-line-height)
      );
    }

    :hover .active-indicator::before {
      border-bottom-color: var(--_hover-active-indicator-color);
      border-bottom-width: var(--_hover-active-indicator-height);
    }

    // Focus is on a separate element and does not need a focus selector
    .active-indicator::after {
      border-bottom-color: var(--_focus-active-indicator-color);
      border-bottom-width: var(--_focus-active-indicator-height);
    }

    :hover .state-layer {
      background: var(--_hover-state-layer-color);
      opacity: var(--_hover-state-layer-opacity);
    }

    .disabled .active-indicator::before {
      border-bottom-color: var(--_disabled-active-indicator-color);
      border-bottom-width: var(--_disabled-active-indicator-height);
      opacity: var(--_disabled-active-indicator-opacity);
    }

    .disabled .background {
      background: var(--_disabled-container-color);
      opacity: var(--_disabled-container-opacity);
    }

    .error .active-indicator::before {
      border-bottom-color: var(--_error-active-indicator-color);
    }

    .error:hover .active-indicator::before {
      border-bottom-color: var(--_error-hover-active-indicator-color);
    }

    .error:hover .state-layer {
      background: var(--_error-hover-state-layer-color);
      opacity: var(--_error-hover-state-layer-opacity);
    }

    // Focus is on a separate element and does not need a focus selector
    .error .active-indicator::after {
      border-bottom-color: var(--_error-focus-active-indicator-color);
    }

    // Move the container up so that the resize handle doesn't overlap the focus
    // indicator. Content is moved back the opposite direction.
    .resizable .container {
      bottom: var(--_focus-active-indicator-height);
      // Ensures the container doesn't create an overhang that can be clicked on.
      clip-path: inset(var(--_focus-active-indicator-height) 0 0 0);
    }

    .resizable .container > * {
      top: var(--_focus-active-indicator-height);
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .disabled .active-indicator::before {
        border-color: GrayText;
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/_label.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles() {
  @layer styles {
    .label {
      box-sizing: border-box;
      color: var(--_label-text-color);
      overflow: hidden;
      max-width: 100%;
      text-overflow: ellipsis;
      white-space: nowrap;
      z-index: 1;
      font-family: var(--_label-text-font);
      font-size: var(--_label-text-size);
      line-height: var(--_label-text-line-height);
      font-weight: var(--_label-text-weight);
      width: min-content;
    }

    .label-wrapper {
      inset: 0;
      // The resting label at 100% height can block pointer events to the content
      // if it's very long and spans the full width of the field. Additionally,
      // selecting the label's text doesn't present a good UX, since the user
      // selection should be re-focused to another element (such as the input)
      // upon focusing. Finally, since the actual label elements are swapped, it
      // is not easy to maintain the user's label text selection.
      pointer-events: none;
      position: absolute;
    }

    .label.resting {
      position: absolute;
      top: var(--_top-space);
    }

    .label.floating {
      font-size: var(--_label-text-populated-size);
      line-height: var(--_label-text-populated-line-height);
      transform-origin: top left;
    }

    .label.hidden {
      opacity: 0;
    }

    .no-label .label {
      display: none;
    }

    // Labels need start/end padding when there isn't start/end content so they
    // don't sit on the edge of the field. We use a wrapper element around the
    // labels so as not to affect the dimensions used in the label keyframes.
    .label-wrapper {
      inset: 0;
      position: absolute;
      // Don't let setting text-align on the field change the label's alignment.
      // It should only impact content text.
      text-align: initial;
    }

    :hover .label {
      color: var(--_hover-label-text-color);
    }

    .focused .label {
      color: var(--_focus-label-text-color);
    }

    .disabled .label {
      color: var(--_disabled-label-text-color);
    }

    .disabled .label:not(.hidden) {
      opacity: var(--_disabled-label-text-opacity);
    }

    .error .label {
      color: var(--_error-label-text-color);
    }

    .error:hover .label {
      color: var(--_error-hover-label-text-color);
    }

    .error.focused .label {
      color: var(--_error-focus-label-text-color);
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .disabled .label:not(.hidden) {
        color: GrayText;
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/_outlined-field.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();

@mixin theme($tokens) {
  $supported-tokens: list.join(
    tokens.$md-comp-outlined-field-supported-tokens,
    (
      'container-shape-start-start',
      'container-shape-start-end',
      'container-shape-end-end',
      'container-shape-end-start'
    )
  );

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-field-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-field-values();

  @layer styles {
    :host {
      // Only use the logical properties.
      $tokens: map.remove($tokens, 'container-shape');
      @each $token, $value in $tokens {
        --_#{$token}: #{$value};
      }
    }

    .outline {
      border-color: var(--_outline-color);
      border-radius: inherit;
      display: flex;
      // Allow events to target elements underneath the outline, such as icons.
      pointer-events: none;
      height: 100%;
      position: absolute;
      width: 100%;
      z-index: 1;
    }

    .outline-start,
    .outline-panel-inactive,
    .outline-panel-active,
    .outline-end {
      // ::before is inactive border, ::after is active border. Borders are
      // absolutely positioned within their elements.
      &::before,
      &::after {
        border: inherit;
        content: '';
        inset: 0;
        position: absolute;
      }
    }

    .outline-start,
    .outline-end {
      border: inherit;
      border-radius: inherit;
      box-sizing: border-box;
      position: relative;

      &::before,
      &::after {
        border-bottom-style: solid;
        border-top-style: solid;
      }

      &::after {
        opacity: 0;
        transition: opacity map.get($_md-sys-motion, 'duration-short3')
          map.get($_md-sys-motion, 'easing-emphasized');
      }
    }

    .focused .outline-start::after,
    .focused .outline-end::after {
      opacity: 1;
    }

    .outline-start {
      &::before,
      &::after {
        border-inline-start-style: solid;
        border-inline-end-style: none;
        border-start-start-radius: inherit;
        border-start-end-radius: 0;
        border-end-start-radius: inherit;
        border-end-end-radius: 0;
        margin-inline-end: var(--_outline-label-padding);
      }
    }

    .outline-end {
      flex-grow: 1;
      margin-inline-start: calc(-1 * var(--_outline-label-padding));

      &::before,
      &::after {
        border-inline-start-style: none;
        border-inline-end-style: solid;
        border-start-start-radius: 0;
        border-start-end-radius: inherit;
        border-end-start-radius: 0;
        border-end-end-radius: inherit;
      }
    }

    .outline-notch {
      align-items: flex-start;
      border: inherit;
      display: flex;
      margin-inline-start: calc(-1 * var(--_outline-label-padding));
      margin-inline-end: var(--_outline-label-padding);
      max-width: calc(100% - var(--_leading-space) - var(--_trailing-space));
      padding: 0 var(--_outline-label-padding);
      position: relative;
    }

    .no-label .outline-notch {
      display: none;
    }

    .outline-panel-inactive,
    .outline-panel-active {
      border: inherit;
      border-bottom-style: solid;
      inset: 0;
      position: absolute;

      &::before,
      &::after {
        border-top-style: solid;
        border-bottom: none;
        bottom: auto;
        transform: scaleX(1);
        transition: transform map.get($_md-sys-motion, 'duration-short3')
          map.get($_md-sys-motion, 'easing-emphasized');
      }

      // Note: no need to do any RTL flipping here. If RTLCSS flips this, it's also
      // ok, we just need one to be left and one to be right.
      &::before {
        right: 50%;
        transform-origin: top left;
      }

      &::after {
        left: 50%;
        transform-origin: top right;
      }
    }

    .populated .outline-panel-inactive,
    .populated .outline-panel-active,
    .focused .outline-panel-inactive,
    .focused .outline-panel-active {
      &::before,
      &::after {
        transform: scaleX(0);
      }
    }

    .outline-panel-active {
      opacity: 0;
      transition: opacity map.get($_md-sys-motion, 'duration-short3')
        map.get($_md-sys-motion, 'easing-emphasized');
    }

    .focused .outline-panel-active {
      opacity: 1;
    }

    .outline-label {
      display: flex;
      max-width: 100%;
      // Center the floating label within the outline stroke
      transform: translateY(calc(-100% + var(--_label-text-padding-bottom)));
    }

    // Add padding that will grow to compensate for the outline's shape.
    // This is needed to prevent the outline border from clipping with the label
    // and is mirrored in the container padding to align the content and resting
    // label with the adjusted floating label.
    $shape-start: max(
      var(--_container-shape-start-start),
      var(--_container-shape-end-start)
    );
    $shape-end: max(
      var(--_container-shape-start-end),
      var(--_container-shape-end-end)
    );
    $start-space: max(
      var(--_leading-space),
      $shape-start + var(--_outline-label-padding)
    );
    $end-space: max(var(--_trailing-space), $shape-end);

    .outline-start,
    .field:not(.with-start) .content ::slotted(*) {
      padding-inline-start: $start-space;
    }

    .field:not(.with-start) .label-wrapper {
      margin-inline-start: $start-space;
    }

    .field:not(.with-end) .content ::slotted(*) {
      padding-inline-end: $end-space;
    }

    .field:not(.with-end) .label-wrapper {
      margin-inline-end: $end-space;
    }

    .outline-start::before,
    .outline-end::before,
    .outline-panel-inactive,
    .outline-panel-inactive::before,
    .outline-panel-inactive::after {
      border-width: var(--_outline-width);
    }

    // States

    :hover .outline {
      border-color: var(--_hover-outline-color);
      color: var(--_hover-outline-color); // Needed for Firefox HCM
    }

    :hover .outline-start::before,
    :hover .outline-end::before,
    :hover .outline-panel-inactive,
    :hover .outline-panel-inactive::before,
    :hover .outline-panel-inactive::after {
      border-width: var(--_hover-outline-width);
    }

    .focused .outline {
      border-color: var(--_focus-outline-color);
      color: var(--_focus-outline-color); // Needed for Firefox HCM
    }

    .outline-start::after,
    .outline-end::after,
    .outline-panel-active,
    .outline-panel-active::before,
    .outline-panel-active::after {
      border-width: var(--_focus-outline-width);
    }

    .disabled .outline {
      border-color: var(--_disabled-outline-color);
      color: var(--_disabled-outline-color); // Needed for Firefox HCM
    }

    .disabled .outline-start,
    .disabled .outline-end,
    .disabled .outline-panel-inactive {
      opacity: var(--_disabled-outline-opacity);
    }

    .disabled .outline-start::before,
    .disabled .outline-end::before,
    .disabled .outline-panel-inactive,
    .disabled .outline-panel-inactive::before,
    .disabled .outline-panel-inactive::after {
      border-width: var(--_disabled-outline-width);
    }

    .error .outline {
      border-color: var(--_error-outline-color);
      color: var(--_error-outline-color); // Needed for Firefox HCM
    }

    .error:hover .outline {
      border-color: var(--_error-hover-outline-color);
      // Needed for Firefox HCM
      color: var(--_error-hover-outline-color);
    }

    .error.focused .outline {
      border-color: var(--_error-focus-outline-color);
      // Needed for Firefox HCM
      color: var(--_error-focus-outline-color);
    }

    // Move the container up and to the left so that the resize handle doesn't
    // overlap the focus outline. Content is moved back the opposite direction.
    .resizable .container {
      bottom: var(--_focus-outline-width);
      inset-inline-end: var(--_focus-outline-width);
      // Ensures the container doesn't create an overhang that can be clicked on.
      clip-path: inset(
        var(--_focus-outline-width) 0 0 var(--_focus-outline-width)
      );
    }

    .resizable .container > * {
      top: var(--_focus-outline-width);
      inset-inline-start: var(--_focus-outline-width);
    }

    .resizable .container:dir(rtl) {
      clip-path: inset(
        var(--_focus-outline-width) var(--_focus-outline-width) 0 0
      );
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .disabled .outline {
        border-color: GrayText;
        color: GrayText; // Needed for Firefox HCM
      }

      .disabled :is(.outline-start, .outline-end, .outline-panel-inactive) {
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use './content';
@use './label';
@use './supporting-text';
// go/keep-sorted end

@mixin styles() {
  :host {
    display: inline-flex;
    resize: both;
  }

  .field {
    display: flex;
    flex: 1;
    flex-direction: column;
    // Allow the use of block/inline reflexive RTL properties without impacting
    // structure when languages change.
    writing-mode: horizontal-tb;
    max-width: 100%; // Do not allow field to grow beyond explicitly set width
  }

  // A separate wrapper is needed around the container for the outline, whose
  // floating label needs overflow: visible. The container itself needs
  // overflow: hidden when resizable.
  .container-overflow {
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-end-radius: var(--_container-shape-end-end);
    border-end-start-radius: var(--_container-shape-end-start);
    display: flex;
    height: 100%;
    position: relative;
  }

  .container {
    align-items: center;
    border-radius: inherit;
    display: flex;
    flex: 1;
    max-height: 100%;
    min-height: 100%;
    min-width: min-content;
    position: relative;
  }

  .field,
  .container-overflow {
    resize: inherit;
  }

  .resizable:not(.disabled) .container {
    // `resize` is inherited from the host, but only applies to the container
    // when resizable.
    resize: inherit;
    // Overflow is visible when not resizable to allow overflowing content such
    // as popups or icon focus rings.
    // Resizable fields cannot display overflowing content due to `resize` not
    // allowing it.
    overflow: hidden;
  }

  .disabled {
    pointer-events: none;
  }

  slot[name='container'] {
    border-radius: inherit;
  }

  slot[name='container']::slotted(*) {
    border-radius: inherit;
    inset: 0;
    pointer-events: none;
    position: absolute;
  }

  @include content.styles;
  @include label.styles;
  @include supporting-text.styles;
}


/* ========== /internal/_supporting-text.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles() {
  @layer styles {
    .supporting-text {
      color: var(--_supporting-text-color);
      display: flex;
      font-family: var(--_supporting-text-font);
      font-size: var(--_supporting-text-size);
      line-height: var(--_supporting-text-line-height);
      font-weight: var(--_supporting-text-weight);
      gap: 16px;
      justify-content: space-between;
      padding-inline-start: var(--_supporting-text-leading-space);
      padding-inline-end: var(--_supporting-text-trailing-space);
      padding-top: var(--_supporting-text-top-space);
    }

    // Don't shrink the counter when the supporting text is long and wraps
    .supporting-text :nth-child(2) {
      flex-shrink: 0;
    }

    :hover .supporting-text {
      color: var(--_hover-supporting-text-color);
    }

    .focus .supporting-text {
      color: var(--_focus-supporting-text-color);
    }

    .disabled .supporting-text {
      color: var(--_disabled-supporting-text-color);
      opacity: var(--_disabled-supporting-text-opacity);
    }

    .error .supporting-text {
      color: var(--_error-supporting-text-color);
    }

    .error:hover .supporting-text {
      color: var(--_error-hover-supporting-text-color);
    }

    .error.focus .supporting-text {
      color: var(--_error-focus-supporting-text-color);
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .disabled .supporting-text {
        color: GrayText;
        opacity: 1;
      }
    }
  }
}


// ========== /internal/field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  html,
  LitElement,
  nothing,
  PropertyValues,
  render,
  TemplateResult,
} from 'lit';
import {property, query, queryAssignedElements, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {EASING} from '../../internal/motion/animation.js';

/**
 * A field component.
 */
export class Field extends LitElement {
  @property({type: Boolean}) disabled = false;
  @property({type: Boolean}) error = false;
  @property({type: Boolean}) focused = false;
  @property() label = '';
  @property({type: Boolean, attribute: 'no-asterisk'}) noAsterisk = false;
  @property({type: Boolean}) populated = false;
  @property({type: Boolean}) required = false;
  @property({type: Boolean}) resizable = false;
  @property({attribute: 'supporting-text'}) supportingText = '';
  @property({attribute: 'error-text'}) errorText = '';
  @property({type: Number}) count = -1;
  @property({type: Number}) max = -1;

  /**
   * Whether or not the field has leading content.
   */
  @property({type: Boolean, attribute: 'has-start'}) hasStart = false;

  /**
   * Whether or not the field has trailing content.
   */
  @property({type: Boolean, attribute: 'has-end'}) hasEnd = false;

  @queryAssignedElements({slot: 'aria-describedby'})
  private readonly slottedAriaDescribedBy!: HTMLElement[];

  private get counterText() {
    // Count and max are typed as number, but can be set to null when Lit removes
    // their attributes. These getters coerce back to a number for calculations.
    const countAsNumber = this.count ?? -1;
    const maxAsNumber = this.max ?? -1;
    // Counter does not show if count is negative, or max is negative or 0.
    if (countAsNumber < 0 || maxAsNumber <= 0) {
      return '';
    }

    return `${countAsNumber} / ${maxAsNumber}`;
  }

  private get supportingOrErrorText() {
    return this.error && this.errorText ? this.errorText : this.supportingText;
  }

  @state() private isAnimating = false;
  private labelAnimation?: Animation;
  /**
   * When set to true, the error text's `role="alert"` will be removed, then
   * re-added after an animation frame. This will re-announce an error message
   * to screen readers.
   */
  @state() private refreshErrorAlert = false;
  @state() private disableTransitions = false;
  @query('.label.floating')
  private readonly floatingLabelEl!: HTMLElement | null;
  @query('.label.resting') private readonly restingLabelEl!: HTMLElement | null;
  @query('.container') private readonly containerEl!: HTMLElement | null;

  /**
   * Re-announces the field's error supporting text to screen readers.
   *
   * Error text announces to screen readers anytime it is visible and changes.
   * Use the method to re-announce the message when the text has not changed,
   * but announcement is still needed (such as for `reportValidity()`).
   */
  reannounceError() {
    this.refreshErrorAlert = true;
  }

  protected override update(props: PropertyValues<Field>) {
    // Client-side property updates
    const isDisabledChanging =
      props.has('disabled') && props.get('disabled') !== undefined;
    if (isDisabledChanging) {
      this.disableTransitions = true;
    }

    // When disabling, remove focus styles if focused.
    if (this.disabled && this.focused) {
      props.set('focused', true);
      this.focused = false;
    }

    // Animate if focused or populated change.
    this.animateLabelIfNeeded({
      wasFocused: props.get('focused'),
      wasPopulated: props.get('populated'),
    });

    super.update(props);
  }

  protected override render() {
    const floatingLabel = this.renderLabel(/*isFloating*/ true);
    const restingLabel = this.renderLabel(/*isFloating*/ false);
    const outline = this.renderOutline?.(floatingLabel);
    const classes = {
      'disabled': this.disabled,
      'disable-transitions': this.disableTransitions,
      'error': this.error && !this.disabled,
      'focused': this.focused,
      'with-start': this.hasStart,
      'with-end': this.hasEnd,
      'populated': this.populated,
      'resizable': this.resizable,
      'required': this.required,
      'no-label': !this.label,
    };

    return html`
      <div class="field ${classMap(classes)}">
        <div class="container-overflow">
          ${this.renderBackground?.()}
          <slot name="container"></slot>
          ${this.renderStateLayer?.()} ${this.renderIndicator?.()} ${outline}
          <div class="container">
            <div class="start">
              <slot name="start"></slot>
            </div>
            <div class="middle">
              <div class="label-wrapper">
                ${restingLabel} ${outline ? nothing : floatingLabel}
              </div>
              <div class="content">
                <slot></slot>
              </div>
            </div>
            <div class="end">
              <slot name="end"></slot>
            </div>
          </div>
        </div>
        ${this.renderSupportingText()}
      </div>
    `;
  }

  protected override updated(changed: PropertyValues<Field>) {
    if (
      changed.has('supportingText') ||
      changed.has('errorText') ||
      changed.has('count') ||
      changed.has('max')
    ) {
      this.updateSlottedAriaDescribedBy();
    }

    if (this.refreshErrorAlert) {
      // The past render cycle removed the role="alert" from the error message.
      // Re-add it after an animation frame to re-announce the error.
      requestAnimationFrame(() => {
        this.refreshErrorAlert = false;
      });
    }

    if (this.disableTransitions) {
      requestAnimationFrame(() => {
        this.disableTransitions = false;
      });
    }
  }

  protected renderBackground?(): TemplateResult;
  protected renderStateLayer?(): TemplateResult;
  protected renderIndicator?(): TemplateResult;
  protected renderOutline?(floatingLabel: unknown): TemplateResult;

  private renderSupportingText() {
    const {supportingOrErrorText, counterText} = this;
    if (!supportingOrErrorText && !counterText) {
      return nothing;
    }

    // Always render the supporting text span so that our `space-around`
    // container puts the counter at the end.
    const start = html`<span>${supportingOrErrorText}</span>`;
    // Conditionally render counter so we don't render the extra `gap`.
    // TODO(b/244473435): add aria-label and announcements
    const end = counterText
      ? html`<span class="counter">${counterText}</span>`
      : nothing;

    // Announce if there is an error and error text visible.
    // If refreshErrorAlert is true, do not announce. This will remove the
    // role="alert" attribute. Another render cycle will happen after an
    // animation frame to re-add the role.
    const shouldErrorAnnounce =
      this.error && this.errorText && !this.refreshErrorAlert;
    const role = shouldErrorAnnounce ? 'alert' : nothing;
    return html`
      <div class="supporting-text" role=${role}>${start}${end}</div>
      <slot
        name="aria-describedby"
        @slotchange=${this.updateSlottedAriaDescribedBy}></slot>
    `;
  }

  private updateSlottedAriaDescribedBy() {
    for (const element of this.slottedAriaDescribedBy) {
      render(html`${this.supportingOrErrorText} ${this.counterText}`, element);
      element.setAttribute('hidden', '');
    }
  }

  private renderLabel(isFloating: boolean) {
    if (!this.label) {
      return nothing;
    }

    let visible: boolean;
    if (isFloating) {
      // Floating label is visible when focused/populated or when animating.
      visible = this.focused || this.populated || this.isAnimating;
    } else {
      // Resting label is visible when unfocused. It is never visible while
      // animating.
      visible = !this.focused && !this.populated && !this.isAnimating;
    }

    const classes = {
      'hidden': !visible,
      'floating': isFloating,
      'resting': !isFloating,
    };

    // Add '*' if a label is present and the field is required
    const labelText = `${this.label}${
      this.required && !this.noAsterisk ? '*' : ''
    }`;

    return html`
      <span class="label ${classMap(classes)}" aria-hidden=${!visible}
        >${labelText}</span
      >
    `;
  }

  private animateLabelIfNeeded({
    wasFocused,
    wasPopulated,
  }: {
    wasFocused?: boolean;
    wasPopulated?: boolean;
  }) {
    if (!this.label) {
      return;
    }

    wasFocused ??= this.focused;
    wasPopulated ??= this.populated;
    const wasFloating = wasFocused || wasPopulated;
    const shouldBeFloating = this.focused || this.populated;
    if (wasFloating === shouldBeFloating) {
      return;
    }

    const keyframes = this.getLabelKeyframes();
    if (!keyframes.length) {
      return;
    }

    this.isAnimating = true;
    this.labelAnimation?.cancel();

    // Only one label is visible at a time for clearer text rendering.
    // The floating label is visible and used during animation. At the end of
    // the animation, it will either remain visible (if floating) or hide and
    // the resting label will be shown.
    //
    // We don't use forward filling because if the dimensions of the text field
    // change (leading icon removed, density changes, etc), then the animation
    // will be inaccurate.
    //
    // Re-calculating the animation each time will prevent any visual glitches
    // from appearing.
    // TODO(b/241113345): use animation tokens
    this.labelAnimation = this.floatingLabelEl?.animate(keyframes, {
      duration: 150,
      easing: EASING.STANDARD,
    });

    this.labelAnimation?.addEventListener('finish', () => {
      // At the end of the animation, update the visible label.
      this.isAnimating = false;
    });
  }

  private getLabelKeyframes() {
    const {floatingLabelEl, restingLabelEl} = this;
    if (!floatingLabelEl || !restingLabelEl) {
      return [];
    }

    const {
      x: floatingX,
      y: floatingY,
      height: floatingHeight,
    } = floatingLabelEl.getBoundingClientRect();
    const {
      x: restingX,
      y: restingY,
      height: restingHeight,
    } = restingLabelEl.getBoundingClientRect();
    const floatingScrollWidth = floatingLabelEl.scrollWidth;
    const restingScrollWidth = restingLabelEl.scrollWidth;
    // If either label has no dimensions (e.g., display: none), skip animation
    if (floatingScrollWidth === 0 || restingScrollWidth === 0) {
      return [];
    }
    // Scale by width ratio instead of font size since letter-spacing will scale
    // incorrectly. Using the width we can better approximate the adjusted
    // scale and compensate for tracking and overflow.
    // (use scrollWidth instead of width to account for clipped labels)
    const scale = restingScrollWidth / floatingScrollWidth;
    const xDelta = restingX - floatingX;
    // The line-height of the resting and floating label are different. When
    // we move the floating label down to the resting label's position, it won't
    // exactly match because of this. We need to adjust by half of what the
    // final scaled floating label's height will be.
    const yDelta =
      restingY -
      floatingY +
      Math.round((restingHeight - floatingHeight * scale) / 2);

    // Create the two transforms: floating to resting (using the calculations
    // above), and resting to floating (re-setting the transform to initial
    // values).
    const restTransform = `translateX(${xDelta}px) translateY(${yDelta}px) scale(${scale})`;
    const floatTransform = `translateX(0) translateY(0) scale(1)`;

    // Constrain the floating labels width to a scaled percentage of the
    // resting label's width. This will prevent long clipped labels from
    // overflowing the container.
    const restingClientWidth = restingLabelEl.clientWidth;
    const isRestingClipped = restingScrollWidth > restingClientWidth;
    const width = isRestingClipped ? `${restingClientWidth / scale}px` : '';
    if (this.focused || this.populated) {
      return [
        {transform: restTransform, width},
        {transform: floatTransform, width},
      ];
    }

    return [
      {transform: floatTransform, width},
      {transform: restTransform, width},
    ];
  }

  getSurfacePositionClientRect() {
    return this.containerEl!.getBoundingClientRect();
  }
}


// ========== /internal/field_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html, TemplateResult} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';
import {FieldHarness} from '../harness.js';

import {Field} from './field.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-test-field': TestField;
  }
}

@customElement('md-test-field')
class TestField extends Field {
  get labelText() {
    return this.renderRoot.querySelector('.label')?.textContent ?? '';
  }

  get supportingTextContent() {
    return this.renderRoot.querySelector('.supporting-text')?.textContent ?? '';
  }

  didErrorAnnounce() {
    return (
      this.renderRoot
        .querySelector('.supporting-text')
        ?.getAttribute('role') === 'alert'
    );
  }

  // Ensure floating/resting labels are both rendered
  protected override renderOutline(floatingLabel: TemplateResult) {
    return floatingLabel;
  }
}

describe('Field', () => {
  const env = new Environment();

  async function setupTest(props: Partial<Field> = {}) {
    // Variant type does not matter for shared tests
    const template = html`
      <md-test-field
        .label=${props.label ?? ''}
        ?no-asterisk=${props.noAsterisk ?? false}
        ?disabled=${props.disabled ?? false}
        .error=${props.error ?? false}
        .populated=${props.populated ?? false}
        .required=${props.required ?? false}
        .supportingText=${props.supportingText ?? ''}
        .errorText=${props.errorText ?? ''}>
        <input />
      </md-test-field>
    `;
    const root = env.render(template);
    const instance = root.querySelector('md-test-field');
    if (!instance) {
      throw new Error('Could not query rendered <md-test-field>.');
    }

    await env.waitForStability();
    return {
      instance,
      harness: new FieldHarness(instance),
    };
  }

  it('should unfocus field when disabled', async () => {
    // Setup.
    const {instance, harness} = await setupTest();
    await harness.focusWithKeyboard();
    await env.waitForStability();
    // Test case.
    instance.disabled = true;
    await env.waitForStability();
    // Assertion.
    expect(instance.focused)
      .withContext('focused is false after disabled is set to true')
      .toBe(false);
  });

  it('should not allow focus when disabled', async () => {
    // Setup.
    const {instance, harness} = await setupTest({disabled: true});
    await harness.focusWithKeyboard();
    // Test case.
    await env.waitForStability();
    // Assertion.
    expect(instance.focused)
      .withContext('focused set back to false when disabled')
      .toBe(false);
  });

  /*
    TODO(b/225951156): update animation tests since l2w refactor breaks them
    describe('#animateLabelIfNeeded()', () => {
      it('should update visible label type to resting before animation
    finishes', async () => {
           // Setup.
           const {instance, harness} = await setupTest({label: 'Label'});
           const floatingLabel = await instance.floatingLabelElement;
           // Test case.
           await harness.focusWithKeyboard();
           await env.waitForStability();
           // Assertion.
           expect(floatingLabel.classList)
               .withContext('should display resting label for animation')
               .not.toContain('label--hidden');
         });

      it('should update visible label type to resting immediately when resting',
         async () => {
           // Setup.
           const {instance, harness} = await setupTest({label: 'Label'});
           const restingLabel = await instance.restingLabelElement;
           await harness.focusWithKeyboard();
           // Test case.
           await harness.blur();
           // Assertion.
           expect(restingLabel.classList)
               .withContext('should display resting label for animation')
               .not.toContain('label--hidden');
         });

      it('should update visible label type after floating animation ends',
         async () => {
           // Setup.
           const {instance, harness} = await setupTest({label: 'Label'});
           const animation = new Animation();
           const floatingLabel = await instance.floatingLabelElement;
           const restingLabel = await instance.restingLabelElement;
           spyOn(restingLabel, 'animate').and.returnValue(animation);
           // Test case.
           await harness.focusWithKeyboard();
           await env.waitForStability();
           animation.play();
           await env.waitForStability();
           // Assertion.
           expect(floatingLabel.classList)
               .withContext('visible label should be floating after focusing')
               .not.toContain('label--hidden');
         });

      it('should update visible label type after resting animation ends',
         async () => {
           // Setup.
           const {instance, harness} = await setupTest({label: 'Label'});
           await harness.focusWithKeyboard();
           const animation = new Animation();
           const restingLabel = await instance.restingLabelElement;
           spyOn(restingLabel, 'animate').and.returnValue(animation);
           // Test case.
           await harness.blur();
           await env.waitForStability();
           animation.play();
           await env.waitForStability();
           // Assertion.
           expect(restingLabel.classList)
               .withContext('visible label should be resting after unfocusing')
               .not.toContain('label--hidden');
         });

      it('should animate label when focused changes', async () => {
        // Setup.
        const {instance, harness} = await setupTest({label: 'Label'});
        const floatingLabel = await instance.floatingLabelElement;
        spyOn(floatingLabel, 'animate').and.callThrough();
        // Test case.
        await harness.focusWithKeyboard();
        await env.waitForStability();
        // Assertion.
        expect(floatingLabel.animate).toHaveBeenCalledTimes(1);
      });

      it('should animate label when populated changes', async () => {
        // Setup.
        const {instance} = await setupTest({label: 'Label'});
        const floatingLabel = await instance.floatingLabelElement;
        spyOn(floatingLabel, 'animate').and.callThrough();
        // Test case.
        instance.populated = true;
        await env.waitForStability();
        // Assertion.
        expect(floatingLabel.animate).toHaveBeenCalledTimes(1);
      });

      it('should not animate when there is no label', async () => {
        // Setup.
        const {instance, harness} = await setupTest({label: undefined});
        const floatingLabel = await instance.floatingLabelElement;
        spyOn(floatingLabel, 'animate').and.callThrough();
        // Test case.
        await harness.focusWithKeyboard();
        await env.waitForStability();
        // Assertion.
        expect(floatingLabel.animate)
            .withContext('should not animate label when there is none')
            .not.toHaveBeenCalled();
      });

      it('should still set the visible label type when there is no label',
         async () => {
           // Setup.
           const {instance, harness} = await setupTest({label: undefined});
           const floatingLabel = await instance.floatingLabelElement;
           await harness.focusWithKeyboard();
           // Test case.
           await env.waitForStability();
           // Assertion.
           expect(floatingLabel.classList)
               .withContext(
                   'focusing should still set visible label type to floating')
               .toContain('label--hidden');

           // Test case.
           await harness.blur();
           await env.waitForStability();
           // Test case.
           expect(floatingLabel.classList)
               .withContext(
                   'unfocusing should still set visible label type to resting')
               .not.toContain('label--hidden');
         });

      it('should not animate if focusing a populated field', async () => {
        // Setup.
        const {instance, harness} =
            await setupTest({label: 'Label', populated: true});
        const floatingLabel = await instance.floatingLabelElement;
        spyOn(floatingLabel, 'animate').and.callThrough();
        // Test case.
        await harness.focusWithKeyboard();
        await env.waitForStability();
        // Assertion.
        expect(floatingLabel.animate)
            .withContext('should not animate when focusing a populated field')
            .not.toHaveBeenCalled();
      });

      it('should not animate if populating a focused field', async () => {
        // Setup.
        const {instance, harness} = await setupTest({label: 'Label'});
        await harness.focusWithKeyboard();
        const floatingLabel = await instance.floatingLabelElement;
        spyOn(floatingLabel, 'animate').and.callThrough();
        // Test case.
        instance.populated = true;
        await env.waitForStability();
        // Assertion.
        expect(floatingLabel.animate)
            .withContext('should not animate when populated a focused field')
            .not.toHaveBeenCalled();
      });

      it('should cancel previous animation', async () => {
        // Set up.
        const {instance, harness} = await setupTest({label: 'Label'});
        const restingLabel = await instance.restingLabelElement;
        const firstAnimation = new Animation();
        spyOn(firstAnimation, 'cancel').and.callThrough();
        const secondAnimation = new Animation();
        spyOn(secondAnimation, 'cancel').and.callThrough();
        spyOn(restingLabel, 'animate')
            .and.returnValues(firstAnimation, secondAnimation);
        // Test case.
        await harness.focusWithKeyboard();
        await env.waitForStability();
        await harness.blur();
        await env.waitForStability();
        // Assertion.
        expect(firstAnimation.cancel)
            .withContext('first animation should be cancelled')
            .toHaveBeenCalled();
        expect(secondAnimation.cancel)
            .withContext('second animation should play')
            .not.toHaveBeenCalled();
      });
    });
  */
  describe('.label', () => {
    it('should render empty string when there is no label', async () => {
      // Setup.
      // Test case.
      const {instance} = await setupTest({label: undefined});
      // Assertion.
      expect(instance.labelText)
        .withContext(
          'label text should be empty string if label is not provided',
        )
        .toBe('');
    });

    it('should render label', async () => {
      // Setup.
      // Test case.
      const labelValue = 'Label';
      const {instance} = await setupTest({label: labelValue});
      // Assertion.
      expect(instance.labelText)
        .withContext('label text should equal label when not required')
        .toBe(labelValue);
    });

    it('should adds asterisk if required', async () => {
      // Setup.
      // Test case.
      const labelValue = 'Label';
      const {instance} = await setupTest({required: true, label: labelValue});
      // Assertion.
      expect(instance.labelText)
        .withContext(
          'label text should equal label with asterisk when required',
        )
        .toBe(`${labelValue}*`);
    });

    it('should not render asterisk if required when there is no label', async () => {
      // Setup.
      // Test case.
      const {instance} = await setupTest({required: true, label: undefined});
      // Assertion.
      expect(instance.labelText)
        .withContext(
          'label text should be empty string if label is not provided, even when required',
        )
        .toBe('');
    });

    it('should not render asterisk if required, but noAsterisk', async () => {
      // Setup.
      // Test case.
      const labelValue = 'Label';
      const {instance} = await setupTest({
        required: true,
        label: labelValue,
        noAsterisk: true,
      });
      //Assertion
      expect(instance.labelText)
        .withContext(
          'label test should equal label without asterisk, when required and noAsterisk',
        )
        .toBe(labelValue);
    });
  });

  describe('supporting text', () => {
    it('should update to errorText when error is true', async () => {
      const errorText = 'Error message';
      const {instance} = await setupTest({
        error: true,
        supportingText: 'Supporting text',
        errorText,
      });

      expect(instance.supportingTextContent).toEqual(errorText);
    });
  });

  describe('error announcement', () => {
    it('should announce errors when both error and errorText are set', async () => {
      const {instance} = await setupTest({
        error: true,
        errorText: 'Error message',
      });

      expect(instance.didErrorAnnounce())
        .withContext('instance.didErrorAnnounce()')
        .toBeTrue();
    });

    it('should not announce supporting text', async () => {
      const {instance} = await setupTest();
      instance.error = true;
      instance.supportingText = 'Not an error';
      await env.waitForStability();

      expect(instance.didErrorAnnounce())
        .withContext('instance.didErrorAnnounce()')
        .toBeFalse();
    });

    it('should re-announce when reannounceError() is called', async () => {
      const {instance} = await setupTest({
        error: true,
        errorText: 'Error message',
      });

      instance.reannounceError();
      await env.waitForStability();
      // After lit update, but before re-render refresh
      expect(instance.didErrorAnnounce())
        .withContext('didErrorAnnounce() before refresh')
        .toBeFalse();

      // After the second lit update render refresh
      await env.waitForStability();
      expect(instance.didErrorAnnounce())
        .withContext('didErrorAnnounce() after refresh')
        .toBeTrue();
    });
  });

  describe('label animation', () => {
    it('should not produce NaN transforms when populated while hidden', async () => {
      const {instance} = await setupTest({label: 'Hidden Label'});
      instance.style.display = 'none';
      await env.waitForStability();

      const floatingLabel =
        instance.shadowRoot?.querySelector('.label.floating')!;
      expect(floatingLabel).withContext('floating label element').toBeDefined();
      const floatingLabelAnimateSpy = spyOn(
        floatingLabel,
        'animate',
      ).and.callThrough();

      instance.populated = true;
      await env.waitForStability();

      expect(floatingLabelAnimateSpy)
        .withContext('floatingLabel.animate()')
        .not.toHaveBeenCalled();
    });
  });
});


// ========== /internal/filled-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Field} from './field.js';

/**
 * A filled field component.
 */
export class FilledField extends Field {
  protected override renderBackground() {
    return html` <div class="background"></div> `;
  }

  protected override renderStateLayer() {
    return html` <div class="state-layer"></div> `;
  }

  protected override renderIndicator() {
    return html`<div class="active-indicator"></div>`;
  }
}


/* ========== /internal/filled-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@use './filled-field';

@include filled-field.styles;


// ========== /internal/outlined-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Field} from './field.js';

/**
 * An outlined field component.
 */
export class OutlinedField extends Field {
  protected override renderOutline(floatingLabel: unknown) {
    return html`
      <div class="outline">
        <div class="outline-start"></div>
        <div class="outline-notch">
          <div class="outline-panel-inactive"></div>
          <div class="outline-panel-active"></div>
          <div class="outline-label">${floatingLabel}</div>
        </div>
        <div class="outline-end"></div>
      </div>
    `;
  }
}


/* ========== /internal/outlined-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//
@use './outlined-field';

@include outlined-field.styles;


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@use './shared';

@include shared.styles;


// ========== /outlined-field.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {OutlinedField} from './internal/outlined-field.js';
import {styles as outlinedStyles} from './internal/outlined-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-field': MdOutlinedField;
  }
}

/**
 * TODO(b/228525797): add docs
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-field')
export class MdOutlinedField extends OutlinedField {
  static override styles: CSSResultOrNative[] = [sharedStyles, outlinedStyles];
}


// ========== /outlined-field_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdOutlinedField} from './outlined-field.js';

describe('<md-outlined-field>', () => {
  describe('.styles', () => {
    createTokenTests(MdOutlinedField.styles);
  });
});