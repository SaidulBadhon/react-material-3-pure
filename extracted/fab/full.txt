/* ========== /_fab.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/fab-branded' as branded-* show branded-theme;
@forward './internal/fab' show theme;


// ========== /branded-fab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Fab, FabVariant} from './internal/fab.js';
import {styles} from './internal/fab-branded-styles.js';
import {styles as forcedColors} from './internal/forced-colors-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

export {type FabSize} from './internal/shared.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-branded-fab': MdBrandedFab;
  }
}

/**
 * @summary Floating action buttons (FABs) help people take primary actions.
 * They’re used to represent the most important action on a screen, such as
 * Create or Reply.
 *
 * @description
 * __Emphasis:__ High emphasis – For the primary, most important, or most common
 * action on a screen
 *
 * __Rationale:__ The FAB remains the default component for a screen’s primary
 * action. It comes in three sizes: small FAB, FAB, and large FAB. The extended
 * FAB’s wider format and text label give it more visual prominence than a  FAB.
 * It’s often used on larger screens where a FAB would seem too small. Branded
 * FABs are used to specifically call attention to branded logo icons.
 *
 * __Example usages:__
 * - FAB
 *   - Create
 *   - Compose
 * - Extended FAB
 *   - Create
 *   - Compose
 *   - New Thread
 *   - New File
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-branded-fab')
export class MdBrandedFab extends Fab {
  /**
   * Branded FABs have no variants
   */
  declare variant: FabVariant;

  override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'primary': false,
      'secondary': false,
      'tertiary': false,
      'small': false,
    };
  }
  static override styles: CSSResultOrNative[] = [
    sharedStyles,
    styles,
    forcedColors,
  ];
}


// ========== /fab.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Fab} from './internal/fab.js';
import {styles} from './internal/fab-styles.js';
import {styles as forcedColors} from './internal/forced-colors-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

export {type FabVariant} from './internal/fab.js';
export {type FabSize} from './internal/shared.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-fab': MdFab;
  }
}

/**
 * @summary Floating action buttons (FABs) help people take primary actions.
 * They’re used to represent the most important action on a screen, such as
 * Create or Reply.
 *
 * @description
 * __Emphasis:__ High emphasis – For the primary, most important, or most common
 * action on a screen
 *
 * __Rationale:__ The FAB remains the default component for a screen’s primary
 * action. It comes in three sizes: small FAB, FAB, and large FAB. The extended
 * FAB’s wider format and text label give it more visual prominence than a  FAB.
 * It’s often used on larger screens where a FAB would seem too small.
 *
 * __Example usages:__
 * - FAB
 *   - Create
 *   - Compose
 * - Extended FAB
 *   - Create
 *   - Compose
 *   - New Thread
 *   - New File
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-fab')
export class MdFab extends Fab {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles, forcedColors];
}


// ========== /fab_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html, render} from 'lit';

import {Environment} from '../testing/environment.js';
import {createTokenTests} from '../testing/tokens.js';

import {MdBrandedFab} from './branded-fab.js';
import {MdFab} from './fab.js';
import {FabHarness} from './harness.js';

describe('<md-fab>', () => {
  const env = new Environment();

  async function setupTest() {
    const element = env.render(html`<md-fab></md-fab>`).querySelector('md-fab');
    if (!element) {
      throw new Error('Could not query rendered <md-fab>.');
    }

    await env.waitForStability();
    const button = element.renderRoot.querySelector('button');
    if (!button) {
      throw new Error('Could not query rendered <button>.');
    }

    return {
      button,
      harness: new FabHarness(element),
    };
  }

  describe('.styles', () => {
    createTokenTests(MdFab.styles);
  });

  describe('basic', () => {
    it('initializes as an md-fab', async () => {
      const {harness} = await setupTest();
      expect(harness.element).toBeInstanceOf(MdFab);
      expect(harness.element.lowered).toEqual(false);
      expect(harness.element.label).toEqual('');
      expect(harness.element.variant).toEqual('surface');
      expect(harness.element.size).toEqual('medium');
      expect(harness.element.label).toEqual('');
    });

    describe('variants', () => {
      it('variant classes are set', async () => {
        const {harness, button} = await setupTest();
        harness.element.variant = 'primary';
        await env.waitForStability();

        expect(button.classList.contains('primary')).toBeTrue();
        expect(button.classList.contains('secondary')).toBeFalse();
        expect(button.classList.contains('tertiary')).toBeFalse();

        harness.element.variant = 'secondary';
        await env.waitForStability();

        expect(button.classList.contains('primary')).toBeFalse();
        expect(button.classList.contains('secondary')).toBeTrue();
        expect(button.classList.contains('tertiary')).toBeFalse();

        harness.element.variant = 'tertiary';
        await env.waitForStability();

        expect(button.classList.contains('primary')).toBeFalse();
        expect(button.classList.contains('secondary')).toBeFalse();
        expect(button.classList.contains('tertiary')).toBeTrue();
      });

      it('size classes are set', async () => {
        const {harness, button} = await setupTest();
        harness.element.size = 'small';
        await env.waitForStability();

        expect(button.classList.contains('small')).toBeTrue();
        expect(button.classList.contains('large')).toBeFalse();

        harness.element.size = 'large';
        await env.waitForStability();

        expect(button.classList.contains('small')).toBeFalse();
        expect(button.classList.contains('large')).toBeTrue();
      });
    });

    it('size classes are not set when extended', async () => {
      const {harness, button} = await setupTest();
      harness.element.size = 'small';
      await env.waitForStability();

      expect(button.classList.contains('small')).toBeTrue();

      harness.element.label = 'label';
      await env.waitForStability();

      expect(button.classList.contains('small')).toBeFalse();
      expect(button.classList.contains('large')).toBeFalse();

      harness.element.size = 'large';
      await env.waitForStability();

      expect(button.classList.contains('small')).toBeFalse();
      expect(button.classList.contains('large')).toBeFalse();
    });
  });

  describe('lowered', () => {
    it('sets the correct classes', async () => {
      const {harness, button} = await setupTest();
      harness.element.lowered = true;
      await env.waitForStability();

      expect(button.classList.contains('lowered')).toBeTrue();
    });
  });

  describe('icon', () => {
    it('node with `slot=icon` will serve as the fab icon', async () => {
      const {harness} = await setupTest();
      render(html`<i slot="icon">star</i>`, harness.element);
      const icon = harness.element.querySelector<HTMLElement>('[slot="icon"]')!;
      expect(icon.textContent!.trim()).toEqual('star');
    });
  });

  describe('label', () => {
    it('displays label text', async () => {
      const {harness, button} = await setupTest();
      harness.element.label = 'foo';
      await env.waitForStability();

      const content = button.querySelector('.label')!;
      expect(content.textContent!.trim()).toEqual('foo');
    });

    it('serves as `aria-label` of native button', async () => {
      const {harness, button} = await setupTest();
      harness.element.ariaLabel = 'foo';
      await env.waitForStability();

      expect(button.getAttribute('aria-label')).toEqual('foo');
    });
  });
});

describe('<md-branded-fab>', () => {
  const env = new Environment();

  async function setupTest() {
    const element = env
      .render(html`<md-branded-fab></md-branded-fab>`)
      .querySelector('md-branded-fab');
    if (!element) {
      throw new Error('Could not query rendered <md-branded-fab>.');
    }

    await env.waitForStability();
    const button = element.renderRoot.querySelector('button');
    if (!button) {
      throw new Error('Could not query rendered <button>.');
    }

    return {
      button,
      harness: new FabHarness(element),
    };
  }

  describe('.styles', () => {
    createTokenTests(MdBrandedFab.styles);
  });

  describe('variants', () => {
    it('variant classes are not set', async () => {
      const {harness, button} = await setupTest();
      harness.element.variant = 'primary';
      await env.waitForStability();

      expect(button.classList.contains('primary')).toBeFalse();
      expect(button.classList.contains('secondary')).toBeFalse();
      expect(button.classList.contains('tertiary')).toBeFalse();

      harness.element.variant = 'secondary';
      await env.waitForStability();

      expect(button.classList.contains('primary')).toBeFalse();
      expect(button.classList.contains('secondary')).toBeFalse();
      expect(button.classList.contains('tertiary')).toBeFalse();

      harness.element.variant = 'tertiary';
      await env.waitForStability();

      expect(button.classList.contains('primary')).toBeFalse();
      expect(button.classList.contains('secondary')).toBeFalse();
      expect(button.classList.contains('tertiary')).toBeFalse();
    });

    it('small size classes are not set', async () => {
      const {harness, button} = await setupTest();
      harness.element.size = 'small';
      await env.waitForStability();

      expect(button.classList.contains('small')).toBeFalse();
      expect(button.classList.contains('large')).toBeFalse();
    });
  });

  describe('accessibility', () => {
    it('sets aria-hidden on the icon slot when aria-label is set', async () => {
      const {button, harness} = await setupTest();
      await env.waitForStability();

      const iconSlot = button.querySelector('slot[name="icon"]')!;

      expect(button.hasAttribute('aria-label')).toBeFalse();
      expect(iconSlot.hasAttribute('aria-hidden')).toBeFalse();

      const element = harness.element;
      element.ariaLabel = 'foo';
      await env.waitForStability();

      expect(button.hasAttribute('aria-label')).toBeTrue();
      expect(iconSlot.getAttribute('aria-hidden')).toEqual('true');
    });

    it('sets aria-hidden on the icon slot when label is set', async () => {
      const {button, harness} = await setupTest();
      await env.waitForStability();
      const element = harness.element;

      const iconSlot = button.querySelector('slot[name="icon"]')!;

      expect(!!element.label).toBeFalse();
      expect(iconSlot.hasAttribute('aria-hidden')).toBeFalse();

      element.label = 'foo';
      await env.waitForStability();

      expect(!!element.label).toBeTrue();
      expect(iconSlot.getAttribute('aria-hidden')).toEqual('true');
    });
  });
});


/* ========== /internal/_fab-branded.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-fab-branded-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-fab-branded-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-fab-branded-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape', 'large-container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }
}


/* ========== /internal/_fab.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: ltokens.$md-comp-fab-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-fab-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-fab-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove(
      $tokens,
      'container-shape',
      'large-container-shape',
      'small-container-shape'
    );

    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    cursor: pointer;
  }

  :host([size='small'][touch-target='wrapper']) {
    margin: max(0px, 48px - var(--_small-container-height));
  }

  .fab {
    @include color(
      (
        'focus-icon-color': var(--_focus-icon-color),
        'hover-icon-color': var(--_hover-icon-color),
        'icon-color': var(--_icon-color),
        'pressed-icon-color': var(--_pressed-icon-color),
      )
    );

    cursor: inherit;

    &.primary {
      @include color(
        (
          'container-color': var(--_primary-container-color),
          'focus-icon-color': var(--_primary-focus-icon-color),
          'hover-icon-color': var(--_primary-hover-icon-color),
          'hover-state-layer-color': var(--_primary-hover-state-layer-color),
          'icon-color': var(--_primary-icon-color),
          'pressed-icon-color': var(--_primary-pressed-icon-color),
          'pressed-state-layer-color': var(--_primary-pressed-state-layer-color),
          'label-text-color': var(--_primary-label-text-color),
          'hover-label-text-color': var(--_primary-hover-label-text-color),
          'focus-label-text-color': var(--_primary-focus-label-text-color),
          'pressed-label-text-color': var(--_primary-pressed-label-text-color),
        )
      );
    }

    &.secondary {
      @include color(
        (
          'container-color': var(--_secondary-container-color),
          'focus-icon-color': var(--_secondary-focus-icon-color),
          'hover-icon-color': var(--_secondary-hover-icon-color),
          'hover-state-layer-color': var(--_secondary-hover-state-layer-color),
          'icon-color': var(--_secondary-icon-color),
          'pressed-icon-color': var(--_secondary-pressed-icon-color),
          'pressed-state-layer-color':
            var(--_secondary-pressed-state-layer-color),
          'label-text-color': var(--_secondary-label-text-color),
          'hover-label-text-color': var(--_secondary-hover-label-text-color),
          'focus-label-text-color': var(--_secondary-focus-label-text-color),
          'pressed-label-text-color': var(--_secondary-pressed-label-text-color),
        )
      );
    }

    &.tertiary {
      @include color(
        (
          'container-color': var(--_tertiary-container-color),
          'focus-icon-color': var(--_tertiary-focus-icon-color),
          'hover-icon-color': var(--_tertiary-hover-icon-color),
          'hover-state-layer-color': var(--_tertiary-hover-state-layer-color),
          'icon-color': var(--_tertiary-icon-color),
          'pressed-icon-color': var(--_tertiary-pressed-icon-color),
          'pressed-state-layer-color':
            var(--_tertiary-pressed-state-layer-color),
          'label-text-color': var(--_tertiary-label-text-color),
          'hover-label-text-color': var(--_tertiary-hover-label-text-color),
          'focus-label-text-color': var(--_tertiary-focus-label-text-color),
          'pressed-label-text-color': var(--_tertiary-pressed-label-text-color),
        )
      );
    }
  }

  // The default content is needed because we do a bit of trickery. If there is
  // no slotted icon we need to have `padding-inline: 20px` but if there is, we
  // need `padding-inline: 16px 20px`.
  //
  // So what this approach does is make the margin / padding-inline of the outer
  // button `padding-inline: 16px 20px`, so if there is something slotted, it
  // renders correctly. This default content span then fills the extra `4px`
  // inline spacing if nothing is slotted which effectively makes the button's
  // inline spacing `20px/20px`.
  .fab.extended slot span {
    padding-inline-start: 4px;
  }

  .fab.small {
    width: var(--_small-container-width);
    height: var(--_small-container-height);

    .icon ::slotted(*) {
      width: var(--_small-icon-size);
      height: var(--_small-icon-size);
      font-size: var(--_small-icon-size);
    }

    &,
    .ripple {
      border-start-start-radius: var(--_small-container-shape-start-start);
      border-start-end-radius: var(--_small-container-shape-start-end);
      border-end-start-radius: var(--_small-container-shape-end-start);
      border-end-end-radius: var(--_small-container-shape-end-end);
    }

    md-focus-ring {
      @include focus-ring.theme(
        (
          'shape-start-start': var(--_small-container-shape-start-start),
          'shape-start-end': var(--_small-container-shape-start-end),
          'shape-end-end': var(--_small-container-shape-end-end),
          'shape-end-start': var(--_small-container-shape-end-start),
        )
      );
    }
  }
}

@mixin color($colors) {
  background-color: map.get($colors, 'container-color');

  @include ripple.theme(
    (
      hover-color: map.get($colors, hover-state-layer-color),
      pressed-color: map.get($colors, pressed-state-layer-color),
    )
  );

  .icon ::slotted(*) {
    color: map.get($colors, icon-color);
  }

  &:focus {
    color: map.get($colors, focus-icon-color);
  }

  &:hover {
    color: map.get($colors, hover-icon-color);
  }

  &:active {
    color: map.get($colors, pressed-icon-color);
  }

  .label {
    color: map.get($colors, label-text-color);

    .fab:hover & {
      color: map.get($colors, hover-label-text-color);
    }

    .fab:focus & {
      color: map.get($colors, focus-label-text-color);
    }

    .fab:active & {
      color: map.get($colors, pressed-label-text-color);
    }
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/elevation';
@use '../../focus/focus-ring';
@use '../../ripple/ripple';
@use '../../tokens';
@use './fab';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();

@mixin styles() {
  :host {
    @include ripple.theme(
      (
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );

    display: inline-flex;
    -webkit-tap-highlight-color: transparent;
  }

  :host([size='medium'][touch-target='wrapper']) {
    margin: max(0px, 48px - var(--_container-height));
  }

  :host([size='large'][touch-target='wrapper']) {
    margin: max(0px, 48px - var(--_large-container-height));
  }

  .fab,
  .icon,
  .icon ::slotted(*) {
    display: flex;
  }

  .fab {
    align-items: center;
    justify-content: center;
    vertical-align: middle;
    padding: 0;
    position: relative;
    height: var(--_container-height);
    transition-property: background-color;
    border-width: 0px;
    outline: none;
    // Required for elevation and ripple to stay below content
    z-index: 0;
    // Override the user-agent text-transform: none of <button>
    text-transform: inherit;

    &.extended {
      width: inherit;
      box-sizing: border-box;
      padding-inline-start: 16px;
      padding-inline-end: 20px;
    }

    &:not(.extended) {
      width: var(--_container-width);
    }

    &.large {
      width: var(--_large-container-width);
      height: var(--_large-container-height);

      .icon ::slotted(*) {
        width: var(--_large-icon-size);
        height: var(--_large-icon-size);
        font-size: var(--_large-icon-size);
      }

      &,
      .ripple {
        border-start-start-radius: var(--_large-container-shape-start-start);
        border-start-end-radius: var(--_large-container-shape-start-end);
        border-end-start-radius: var(--_large-container-shape-end-start);
        border-end-end-radius: var(--_large-container-shape-end-end);
      }

      md-focus-ring {
        @include focus-ring.theme(
          (
            'shape-start-start': var(--_large-container-shape-start-start),
            'shape-start-end': var(--_large-container-shape-start-end),
            'shape-end-end': var(--_large-container-shape-end-end),
            'shape-end-start': var(--_large-container-shape-end-start),
          )
        );
      }
    }

    @include _elevation(
      (
        'default': var(--_container-elevation),
        'focus': var(--_focus-container-elevation),
        'hover': var(--_hover-container-elevation),
        'pressed': var(--_pressed-container-elevation),
      ),
      var(--_container-shadow-color)
    );

    &.lowered {
      background-color: var(--_lowered-container-color);

      @include _elevation(
        (
          'default': var(--_lowered-container-elevation),
          'focus': var(--_lowered-focus-container-elevation),
          'hover': var(--_lowered-hover-container-elevation),
          'pressed': var(--_lowered-pressed-container-elevation),
        )
      );
    }

    @include fab.color(
      (
        'container-color': var(--_container-color),
        'hover-state-layer-color': var(--_hover-state-layer-color),
        'pressed-state-layer-color': var(--_pressed-state-layer-color),
        'label-text-color': var(--_label-text-color),
        'hover-label-text-color': var(--_hover-label-text-color),
        'focus-label-text-color': var(--_focus-label-text-color),
        'pressed-label-text-color': var(--_pressed-label-text-color),
      )
    );
  }

  .label {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    line-height: var(--_label-text-line-height);
    font-weight: var(--_label-text-weight);
  }

  .fab.extended .icon ::slotted(*) {
    margin-inline-end: 12px;
  }

  .ripple {
    overflow: hidden;
  }

  .ripple,
  md-elevation {
    // puts both behind content
    z-index: -1;
  }

  .touch-target {
    position: absolute;
    top: 50%;
    height: 48px;
    left: 50%;
    width: 48px;
    transform: translate(-50%, -50%);
  }

  :host([touch-target='none']) .touch-target {
    display: none;
  }

  md-elevation,
  .fab {
    // TODO: replace duration with animation tokens
    transition-duration: 280ms;
    transition-timing-function: map.get($_md-sys-motion, 'easing-emphasized');
  }

  .fab,
  .ripple {
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-start-radius: var(--_container-shape-end-start);
    border-end-end-radius: var(--_container-shape-end-end);
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape-start-start': var(--_container-shape-start-start),
        'shape-start-end': var(--_container-shape-start-end),
        'shape-end-end': var(--_container-shape-end-end),
        'shape-end-start': var(--_container-shape-end-start),
      )
    );
  }

  .icon ::slotted(*) {
    width: var(--_icon-size);
    height: var(--_icon-size);
    font-size: var(--_icon-size);
  }
}

@mixin _elevation($states, $shadow-color: null) {
  @include elevation.theme(
    (
      'level': map.get($states, 'default'),
    )
  );

  @if $shadow-color {
    @include elevation.theme(
      (
        'shadow-color': $shadow-color,
      )
    );
  }

  // apply elevation in order of focused, hovered, pressed, disabled
  // this ensures a button will have hover elevation after being focused
  &:focus {
    @include elevation.theme(
      (
        'level': map.get($states, 'focus'),
      )
    );
  }

  &:hover {
    @include elevation.theme(
      (
        'level': map.get($states, 'hover'),
      )
    );
  }

  &:active {
    @include elevation.theme(
      (
        'level': map.get($states, 'pressed'),
      )
    );
  }
}


/* ========== /internal/fab-branded-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './fab-branded';
// go/keep-sorted end

@include fab-branded.styles;


/* ========== /internal/fab-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './fab';
// go/keep-sorted end

@include fab.styles;


// ========== /internal/fab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {property} from 'lit/decorators.js';

import {SharedFab} from './shared.js';

/**
 * The variants available to non-branded FABs.
 */
export type FabVariant = 'surface' | 'primary' | 'secondary' | 'tertiary';

// tslint:disable-next-line:enforce-comments-on-exported-symbols
export class Fab extends SharedFab {
  /**
   * The FAB color variant to render.
   */
  @property() variant: FabVariant = 'surface';

  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'primary': this.variant === 'primary',
      'secondary': this.variant === 'secondary',
      'tertiary': this.variant === 'tertiary',
    };
  }
}


/* ========== /internal/forced-colors-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use '../../focus/focus-ring';
// go/keep-sorted end

@media (forced-colors: active) {
  .fab {
    border: 1px solid ButtonText;

    &.extended {
      // Adjust the padding-inline to account for the 1px border in HCM.
      padding-inline-start: 15px;
      padding-inline-end: 19px;
    }
  }

  md-focus-ring {
    // Adjust the focus ring padding to account for the 1px border in HCM.
    @include focus-ring.theme(
      (
        'outward-offset': 3px,
      )
    );
  }
}


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /internal/shared.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, LitElement, nothing} from 'lit';
import {property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';

/**
 * Sizes variants available to non-extended FABs.
 */
export type FabSize = 'medium' | 'small' | 'large';

// Separate variable needed for closure.
const fabBaseClass = mixinDelegatesAria(LitElement);

// tslint:disable-next-line:enforce-comments-on-exported-symbols
export abstract class SharedFab extends fabBaseClass {
  /** @nocollapse */
  static override shadowRootOptions: ShadowRootInit = {
    mode: 'open' as const,
    delegatesFocus: true,
  };

  /**
   * The size of the FAB.
   *
   * NOTE: Branded FABs cannot be sized to `small`, and Extended FABs do not
   * have different sizes.
   */
  @property({reflect: true}) size: FabSize = 'medium';

  /**
   * The text to display on the FAB.
   */
  @property() label = '';

  /**
   * Lowers the FAB's elevation.
   */
  @property({type: Boolean}) lowered = false;

  protected override render() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <button
        class="fab ${classMap(this.getRenderClasses())}"
        aria-label=${ariaLabel || nothing}>
        <md-elevation part="elevation"></md-elevation>
        <md-focus-ring part="focus-ring"></md-focus-ring>
        <md-ripple class="ripple"></md-ripple>
        ${this.renderTouchTarget()} ${this.renderIcon()} ${this.renderLabel()}
      </button>
    `;
  }

  protected getRenderClasses() {
    const isExtended = !!this.label;
    return {
      'lowered': this.lowered,
      'small': this.size === 'small' && !isExtended,
      'large': this.size === 'large' && !isExtended,
      'extended': isExtended,
    };
  }

  private renderTouchTarget() {
    return html`<div class="touch-target"></div>`;
  }

  private renderLabel() {
    return this.label ? html`<span class="label">${this.label}</span>` : '';
  }

  private renderIcon() {
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`<span class="icon">
      <slot
        name="icon"
        aria-hidden=${ariaLabel || this.label
          ? 'true'
          : (nothing as unknown as 'false')}>
        <span></span>
      </slot>
    </span>`;
  }
}