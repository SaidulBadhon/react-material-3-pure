/* ========== /_switch.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/switch' show theme;


/* ========== /internal/_handle.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();
$_easing-standard: map.get($_md-sys-motion, 'easing-standard');

@mixin styles($tokens) {
  @layer styles {
    .handle-container {
      display: flex;
      place-content: center;
      place-items: center;
      position: relative;
      // this easing is custom to perform the "overshoot" animation
      transition: margin 300ms cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    $margin: calc(
      map.get($tokens, 'track-width') - map.get($tokens, 'track-height')
    );

    .selected .handle-container {
      margin-inline-start: $margin;
    }

    .unselected .handle-container {
      margin-inline-end: $margin;
    }

    .disabled .handle-container {
      transition: none;
    }

    .handle {
      // Handle shape
      border-start-start-radius: map.get($tokens, 'handle-shape-start-start');
      border-start-end-radius: map.get($tokens, 'handle-shape-start-end');
      border-end-end-radius: map.get($tokens, 'handle-shape-end-end');
      border-end-start-radius: map.get($tokens, 'handle-shape-end-start');
      height: map.get($tokens, 'handle-height');
      width: map.get($tokens, 'handle-width');

      transform-origin: center;
      transition-property: height, width;
      transition-duration: 250ms, 250ms;
      transition-timing-function: $_easing-standard, $_easing-standard;
      z-index: 0;
    }

    .handle::before {
      content: '';
      display: flex;
      inset: 0;
      position: absolute;
      border-radius: inherit;
      box-sizing: border-box;
      transition: background-color 67ms linear;
    }

    .disabled .handle,
    .disabled .handle::before {
      transition: none;
    }

    .selected .handle {
      height: map.get($tokens, 'selected-handle-height');
      width: map.get($tokens, 'selected-handle-width');
    }

    .handle.with-icon {
      height: map.get($tokens, 'with-icon-handle-height');
      width: map.get($tokens, 'with-icon-handle-width');
    }

    .selected:not(.disabled):active .handle,
    .unselected:not(.disabled):active .handle {
      height: map.get($tokens, 'pressed-handle-height');
      width: map.get($tokens, 'pressed-handle-width');
      transition-timing-function: linear;
      transition-duration: 100ms;
    }

    .selected .handle::before {
      background-color: map.get($tokens, 'selected-handle-color');
    }

    .selected:hover .handle::before {
      background-color: map.get($tokens, 'selected-hover-handle-color');
    }

    .selected:focus-within .handle::before {
      background-color: map.get($tokens, 'selected-focus-handle-color');
    }

    .selected:active .handle::before {
      background-color: map.get($tokens, 'selected-pressed-handle-color');
    }

    .selected.disabled .handle::before {
      background-color: map.get($tokens, 'disabled-selected-handle-color');
      opacity: map.get($tokens, 'disabled-selected-handle-opacity');
    }

    .unselected .handle::before {
      background-color: map.get($tokens, 'handle-color');
    }

    .unselected:hover .handle::before {
      background-color: map.get($tokens, 'hover-handle-color');
    }

    .unselected:focus-within .handle::before {
      background-color: map.get($tokens, 'focus-handle-color');
    }

    .unselected:active .handle::before {
      background-color: map.get($tokens, 'pressed-handle-color');
    }

    .unselected.disabled .handle::before {
      background-color: map.get($tokens, 'disabled-handle-color');
      opacity: map.get($tokens, 'disabled-handle-opacity');
    }

    md-ripple {
      border-radius: map.get($tokens, 'state-layer-shape');
      height: map.get($tokens, 'state-layer-size');
      inset: unset;
      width: map.get($tokens, 'state-layer-size');
    }

    .selected md-ripple {
      @include ripple.theme(
        (
          'hover-color': map.get($tokens, 'selected-hover-state-layer-color'),
          'pressed-color':
            map.get($tokens, 'selected-pressed-state-layer-color'),
          'hover-opacity':
            map.get($tokens, 'selected-hover-state-layer-opacity'),
          'pressed-opacity':
            map.get($tokens, 'selected-pressed-state-layer-opacity'),
        )
      );
    }

    .unselected md-ripple {
      @include ripple.theme(
        (
          'hover-color': map.get($tokens, 'hover-state-layer-color'),
          'pressed-color': map.get($tokens, 'pressed-state-layer-color'),
          'hover-opacity': map.get($tokens, 'hover-state-layer-opacity'),
          'pressed-opacity': map.get($tokens, 'pressed-state-layer-opacity'),
        )
      );
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .unselected .handle::before {
        background: ButtonText;
      }

      .disabled .handle::before {
        opacity: 1;
      }

      .disabled.unselected .handle::before {
        background: GrayText;
      }
    }
  }
}


/* ========== /internal/_icon.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();
$_easing-standard: map.get($_md-sys-motion, 'easing-standard');

@mixin styles($tokens) {
  @layer styles {
    .icons {
      position: relative;
      height: 100%;
      width: 100%;
    }

    .icon {
      position: absolute;
      inset: 0;
      margin: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      fill: currentColor;

      transition: fill 67ms linear, opacity 33ms linear,
        transform 167ms $_easing-standard;
      opacity: 0;
    }

    .disabled .icon {
      transition: none;
    }

    .selected .icon--on,
    .unselected .icon--off {
      opacity: 1;
    }

    // rotate selected icon into view when there is no unselected icon
    .unselected .handle:not(.with-icon) .icon--on {
      transform: rotate(-45deg);
    }

    .icon--off {
      width: map.get($tokens, 'icon-size');
      height: map.get($tokens, 'icon-size');
      color: map.get($tokens, 'icon-color');
    }

    .unselected:hover .icon--off {
      color: map.get($tokens, 'hover-icon-color');
    }

    .unselected:focus-within .icon--off {
      color: map.get($tokens, 'focus-icon-color');
    }

    .unselected:active .icon--off {
      color: map.get($tokens, 'pressed-icon-color');
    }

    .unselected.disabled .icon--off {
      color: map.get($tokens, 'disabled-icon-color');
      opacity: map.get($tokens, 'disabled-icon-opacity');
    }

    .icon--on {
      width: map.get($tokens, 'selected-icon-size');
      height: map.get($tokens, 'selected-icon-size');
      color: map.get($tokens, 'selected-icon-color');
    }

    .selected:hover .icon--on {
      color: map.get($tokens, 'selected-hover-icon-color');
    }

    .selected:focus-within .icon--on {
      color: map.get($tokens, 'selected-focus-icon-color');
    }

    .selected:active .icon--on {
      color: map.get($tokens, 'selected-pressed-icon-color');
    }

    .selected.disabled .icon--on {
      color: map.get($tokens, 'disabled-selected-icon-color');
      opacity: map.get($tokens, 'disabled-selected-icon-opacity');
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .icon--off {
        fill: Canvas;
      }

      .icon--on {
        fill: ButtonText;
      }

      .disabled.unselected .icon--off,
      .disabled.selected .icon--on {
        opacity: 1;
      }

      .disabled .icon--on {
        fill: GrayText;
      }
    }
  }
}


/* ========== /internal/_switch.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../tokens';
@use './handle';
@use './icon';
@use './track';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-switch-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-switch-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-switch-values();

  @layer styles, hcm;
  @layer styles {
    :host {
      display: inline-flex;
      outline: none;
      vertical-align: top;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
    }

    :host([disabled]) {
      cursor: default;
    }

    :host([touch-target='wrapper']) {
      margin: max(0px, (48px - map.get($tokens, 'track-height')) / 2) 0px;
    }

    md-focus-ring {
      @include focus-ring.theme(
        (
          'shape-start-start': map.get($tokens, 'track-shape-start-start'),
          'shape-start-end': map.get($tokens, 'track-shape-start-end'),
          'shape-end-end': map.get($tokens, 'track-shape-end-end'),
          'shape-end-start': map.get($tokens, 'track-shape-end-start'),
        )
      );
    }

    .switch {
      align-items: center;
      display: inline-flex;
      flex-shrink: 0; // Stop from collapsing in flex containers
      position: relative;
      width: map.get($tokens, 'track-width');
      height: map.get($tokens, 'track-height');

      // Track shape
      border-start-start-radius: map.get($tokens, 'track-shape-start-start');
      border-start-end-radius: map.get($tokens, 'track-shape-start-end');
      border-end-end-radius: map.get($tokens, 'track-shape-end-end');
      border-end-start-radius: map.get($tokens, 'track-shape-end-start');
    }

    // Input is also touch target
    input {
      appearance: none;
      height: max(100%, map.get($tokens, 'touch-target-size'));
      outline: none;
      margin: 0;
      position: absolute;
      width: max(100%, map.get($tokens, 'touch-target-size'));
      z-index: 1;
      cursor: inherit;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    :host([touch-target='none']) input {
      display: none;
    }
  }

  @include track.styles($tokens);
  @include handle.styles($tokens);
  @include icon.styles($tokens);
}


/* ========== /internal/_track.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end

@mixin styles($tokens) {
  @layer styles {
    .track {
      position: absolute;
      width: 100%;
      height: 100%;
      box-sizing: border-box;

      border-radius: inherit;

      // Center content
      display: flex;
      justify-content: center;
      align-items: center;
    }

    // Separate node for background/outline colors to support opacity changes.
    .track::before {
      content: '';
      display: flex;
      position: absolute;
      height: 100%;
      width: 100%;
      border-radius: inherit;
      box-sizing: border-box;
      transition-property: opacity, background-color;
      transition-timing-function: linear;
      transition-duration: 67ms;
    }

    .disabled .track {
      background-color: transparent;
      border-color: transparent;
    }

    .disabled .track::before,
    .disabled .track::after {
      transition: none;
      opacity: map.get($tokens, 'disabled-track-opacity');
    }

    .disabled .track::before {
      background-clip: content-box;
    }

    .selected .track::before {
      background-color: map.get($tokens, 'selected-track-color');
    }

    .selected:hover .track::before {
      background-color: map.get($tokens, 'selected-hover-track-color');
    }

    .selected:focus-within .track::before {
      background-color: map.get($tokens, 'selected-focus-track-color');
    }

    .selected:active .track::before {
      background-color: map.get($tokens, 'selected-pressed-track-color');
    }

    .selected.disabled .track {
      background-clip: border-box;
    }

    .selected.disabled .track::before {
      background-color: map.get($tokens, 'disabled-selected-track-color');
    }

    .unselected .track::before {
      background-color: map.get($tokens, 'track-color');
      border-color: map.get($tokens, 'track-outline-color');
      border-style: solid;
      border-width: map.get($tokens, 'track-outline-width');
    }

    .unselected:hover .track::before {
      background-color: map.get($tokens, 'hover-track-color');
      border-color: map.get($tokens, 'hover-track-outline-color');
    }

    .unselected:focus-visible .track::before {
      background-color: map.get($tokens, 'focus-track-color');
      border-color: map.get($tokens, 'focus-track-outline-color');
    }

    .unselected:active .track::before {
      background-color: map.get($tokens, 'pressed-track-color');
      border-color: map.get($tokens, 'pressed-track-outline-color');
    }

    .unselected.disabled .track::before {
      background-color: map.get($tokens, 'disabled-track-color');
      border-color: map.get($tokens, 'disabled-track-outline-color');
    }
  }

  @layer hcm {
    @media (forced-colors: active) {
      .selected .track::before {
        background: ButtonText;
        border-color: ButtonText;
      }

      .disabled .track::before {
        border-color: GrayText;
        opacity: 1;
      }

      .disabled.selected .track::before {
        background: GrayText;
      }
    }
  }
}


/* ========== /internal/switch-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './switch';
// go/keep-sorted end

@include switch.styles;


// ========== /internal/switch.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, nothing, TemplateResult} from 'lit';
import {property, query} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';

import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {
  afterDispatch,
  setupDispatchHooks,
} from '../../internal/events/dispatch-hooks.js';
import {
  dispatchActivationClick,
  isActivationClick,
} from '../../internal/events/form-label-activation.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';
import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from '../../labs/behaviors/constraint-validation.js';
import {mixinElementInternals} from '../../labs/behaviors/element-internals.js';
import {
  getFormState,
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {CheckboxValidator} from '../../labs/behaviors/validators/checkbox-validator.js';

// Separate variable needed for closure.
const switchBaseClass = mixinDelegatesAria(
  mixinConstraintValidation(
    mixinFormAssociated(mixinElementInternals(LitElement)),
  ),
);

/**
 * @fires input {InputEvent} Fired whenever `selected` changes due to user
 * interaction (bubbles and composed).
 * @fires change {Event} Fired whenever `selected` changes due to user
 * interaction (bubbles).
 */
export class Switch extends switchBaseClass {
  /** @nocollapse */
  static override shadowRootOptions: ShadowRootInit = {
    mode: 'open',
    delegatesFocus: true,
  };

  /**
   * Puts the switch in the selected state and sets the form submission value to
   * the `value` property.
   */
  @property({type: Boolean}) selected = false;

  /**
   * Shows both the selected and deselected icons.
   */
  @property({type: Boolean}) icons = false;

  /**
   * Shows only the selected icon, and not the deselected icon. If `true`,
   * overrides the behavior of the `icons` property.
   */
  @property({type: Boolean, attribute: 'show-only-selected-icon'})
  showOnlySelectedIcon = false;

  /**
   * When true, require the switch to be selected when participating in
   * form submission.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#validation
   */
  @property({type: Boolean}) required = false;

  /**
   * The value associated with this switch on form submission. `null` is
   * submitted when `selected` is `false`.
   */
  @property() value = 'on';

  @query('input') private readonly input!: HTMLInputElement | null;

  constructor() {
    super();
    if (isServer) {
      return;
    }

    // This click listener does not currently need dispatch hooks since it does
    // not check `event.defaultPrevented`.
    this.addEventListener('click', (event: MouseEvent) => {
      if (!isActivationClick(event) || !this.input) {
        return;
      }
      this.focus();
      dispatchActivationClick(this.input);
    });

    // Add the aria keyboard interaction pattern for switch and the Enter key.
    // See https://www.w3.org/WAI/ARIA/apg/patterns/switch/.
    setupDispatchHooks(this, 'keydown');
    this.addEventListener('keydown', (event: KeyboardEvent) => {
      afterDispatch(event, () => {
        const ignoreEvent = event.defaultPrevented || event.key !== 'Enter';
        if (ignoreEvent || this.disabled || !this.input) {
          return;
        }

        this.input.click();
      });
    });
  }

  protected override render(): TemplateResult {
    return html`
      <div class="switch ${classMap(this.getRenderClasses())}">
        <input
          id="switch"
          class="touch"
          type="checkbox"
          role="switch"
          aria-label=${(this as ARIAMixin).ariaLabel || nothing}
          ?checked=${this.selected}
          ?disabled=${this.disabled}
          ?required=${this.required}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <md-focus-ring part="focus-ring" for="switch"></md-focus-ring>
        <span class="track"> ${this.renderHandle()} </span>
      </div>
    `;
  }

  private getRenderClasses(): ClassInfo {
    return {
      'selected': this.selected,
      'unselected': !this.selected,
      'disabled': this.disabled,
    };
  }

  private renderHandle() {
    const classes = {
      'with-icon': this.showOnlySelectedIcon ? this.selected : this.icons,
    };
    return html`
      ${this.renderTouchTarget()}
      <span class="handle-container">
        <md-ripple for="switch" ?disabled="${this.disabled}"></md-ripple>
        <span class="handle ${classMap(classes)}">
          ${this.shouldShowIcons() ? this.renderIcons() : html``}
        </span>
      </span>
    `;
  }

  private renderIcons() {
    return html`
      <div class="icons">
        ${this.renderOnIcon()}
        ${this.showOnlySelectedIcon ? html`` : this.renderOffIcon()}
      </div>
    `;
  }

  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  private renderOnIcon() {
    return html`
      <slot class="icon icon--on" name="on-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M9.55 18.2 3.65 12.3 5.275 10.675 9.55 14.95 18.725 5.775 20.35 7.4Z" />
        </svg>
      </slot>
    `;
  }

  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Aclose%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  private renderOffIcon() {
    return html`
      <slot class="icon icon--off" name="off-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M6.4 19.2 4.8 17.6 10.4 12 4.8 6.4 6.4 4.8 12 10.4 17.6 4.8 19.2 6.4 13.6 12 19.2 17.6 17.6 19.2 12 13.6Z" />
        </svg>
      </slot>
    `;
  }

  private renderTouchTarget() {
    return html`<span class="touch"></span>`;
  }

  private shouldShowIcons(): boolean {
    return this.icons || this.showOnlySelectedIcon;
  }

  private handleInput(event: Event) {
    const target = event.target as HTMLInputElement;
    this.selected = target.checked;
    // <input> 'input' event bubbles and is composed, don't re-dispatch it.
  }

  private handleChange(event: Event) {
    // <input> 'change' event is not composed, re-dispatch it.
    redispatchEvent(this, event);
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    return this.selected ? this.value : null;
  }

  override [getFormState]() {
    return String(this.selected);
  }

  override formResetCallback() {
    // The selected property does not reflect, so the original attribute set by
    // the user is used to determine the default value.
    this.selected = this.hasAttribute('selected');
  }

  override formStateRestoreCallback(state: string) {
    this.selected = state === 'true';
  }

  override [createValidator]() {
    return new CheckboxValidator(() => ({
      checked: this.selected,
      required: this.required,
    }));
  }

  override [getValidityAnchor]() {
    return this.input;
  }
}


// ========== /internal/switch_test.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';
import {customElement} from 'lit/decorators.js';
import {ifDefined} from 'lit/directives/if-defined.js';

import {Environment} from '../../testing/environment.js';
import {Harness} from '../../testing/harness.js';

import {Switch} from './switch.js';

@customElement('md-test-switch')
class TestSwitch extends Switch {}

declare global {
  interface HTMLElementTagNameMap {
    'md-test-switch': TestSwitch;
  }
}

function renderSwitch(propsInit: Partial<TestSwitch> = {}) {
  return html`
    <md-test-switch
      ?selected=${propsInit.selected === true}
      ?disabled=${propsInit.disabled === true}
      .name=${propsInit.name ?? ''}
      value=${ifDefined(propsInit.value)}></md-test-switch>
  `;
}

function renderSwitchInForm(propsInit: Partial<TestSwitch> = {}) {
  return html` <form>${renderSwitch(propsInit)}</form> `;
}

function renderSwitchInLabel(propsInit: Partial<TestSwitch> = {}) {
  return html` <label>${renderSwitch(propsInit)}</label> `;
}

describe('md-switch', () => {
  const env = new Environment();

  async function switchElement(
    propsInit: Partial<TestSwitch> = {},
    template = renderSwitch,
  ) {
    const root = env.render(html`<div>${template(propsInit)}</div>`);
    await env.waitForStability();
    const element = root.querySelector('md-test-switch');
    if (!element) {
      throw new Error('Could not query rendered <md-test-switch>.');
    }
    return element;
  }

  let toggle: TestSwitch;

  beforeEach(async () => {
    toggle = await switchElement();
  });

  describe('selected', () => {
    let selected: TestSwitch;

    beforeEach(async () => {
      selected = await switchElement({selected: true});
    });

    it('is false by default', () => {
      expect(toggle.selected).toBeFalse();
    });

    it('adds selected class when true', () => {
      const toggleRoot = toggle.shadowRoot!.querySelector('.switch')!;
      expect(Array.from(toggleRoot.classList)).not.toContain('selected');

      const selectedRoot = selected.shadowRoot!.querySelector('.switch')!;
      expect(Array.from(selectedRoot.classList)).toContain('selected');
    });

    it('adds unselected class when false', () => {
      const toggleRoot = toggle.shadowRoot!.querySelector('.switch')!;
      expect(Array.from(toggleRoot.classList)).toContain('unselected');

      const selectedRoot = selected.shadowRoot!.querySelector('.switch')!;
      expect(Array.from(selectedRoot.classList)).not.toContain('unselected');
    });
  });

  describe('disabled', () => {
    let disabled: TestSwitch;

    beforeEach(async () => {
      disabled = await switchElement({disabled: true});
    });

    it('is false by default', () => {
      expect(toggle.disabled).toBeFalse();
    });

    it('sets disabled of input', () => {
      const toggleInput = toggle.shadowRoot!.querySelector('input')!;
      expect(toggleInput.disabled).toBeFalse();

      const selectedInput = disabled.shadowRoot!.querySelector('input')!;
      expect(selectedInput.disabled).toBeTrue();
    });
  });

  describe('aria', () => {
    it('delegates aria-label to the proper element', async () => {
      const input = toggle.shadowRoot!.querySelector('input')!;
      toggle.setAttribute('aria-label', 'foo');
      await toggle.updateComplete;
      expect(toggle.ariaLabel).toEqual('foo');
      expect(toggle.getAttribute('aria-label')).toEqual('foo');
      expect(input.getAttribute('aria-label')).toEqual('foo');
    });

    it('delegates .ariaLabel to the proper element', async () => {
      const input = toggle.shadowRoot!.querySelector('input')!;
      toggle.ariaLabel = 'foo';
      await toggle.updateComplete;
      expect(toggle.ariaLabel).toEqual('foo');
      expect(toggle.getAttribute('aria-label')).toEqual('foo');
      expect(input.getAttribute('aria-label')).toEqual('foo');
    });
  });

  describe('name', () => {
    it('is an empty string by default', () => {
      expect(toggle.name).toEqual('');
    });

    it('reflects as an attribute', async () => {
      toggle.name = 'foo';
      await toggle.updateComplete;
      expect(toggle.getAttribute('name')).toEqual('foo');
    });
  });

  describe('value', () => {
    it('is "on" by default', () => {
      expect(toggle.value).toEqual('on');
    });
  });

  describe('click()', () => {
    it('toggles element', () => {
      expect(toggle.selected).withContext('is false by default').toBeFalse();
      toggle.click();
      expect(toggle.selected).withContext('should toggle selected').toBeTrue();
    });

    it('does nothing if disabled', () => {
      expect(toggle.selected).withContext('is false by default').toBeFalse();
      toggle.disabled = true;
      toggle.click();
      expect(toggle.selected).withContext('should remain false').toBeFalse();
    });

    it('reflects `selected` state in input events', () => {
      let state = false;
      const inputHandler = jasmine
        .createSpy('inputHandler')
        .and.callFake(() => {
          state = toggle.selected;
        });

      toggle.addEventListener('input', inputHandler);

      toggle.click();
      expect(inputHandler).withContext('input listener').toHaveBeenCalled();
      expect(state)
        .withContext('switch.selected during input listener')
        .toBeTrue();
    });
  });

  describe('form submission', () => {
    async function switchInForm(
      propsInit: Partial<TestSwitch> = {},
      template = renderSwitchInForm,
    ) {
      const element = await switchElement(propsInit, template);
      return new Harness(element);
    }

    it('does not submit if not selected', async () => {
      const harness = await switchInForm({name: 'foo'});
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toBeNull();
    });

    it('does not submit if disabled', async () => {
      const harness = await switchInForm({
        name: 'foo',
        selected: true,
        disabled: true,
      });
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toBeNull();
    });

    it('does not submit if name is not provided', async () => {
      const harness = await switchInForm({selected: true});
      const formData = await harness.submitForm();
      const keys = Array.from(formData.keys());
      expect(keys.length).toEqual(0);
    });

    it('submits under correct conditions', async () => {
      const harness = await switchInForm({
        name: 'foo',
        selected: true,
        value: 'bar',
      });
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toEqual('bar');
    });

    describe('label activation', () => {
      let label: HTMLLabelElement;

      it('toggles when label is clicked', async () => {
        toggle = await switchElement({}, renderSwitchInLabel);
        label = toggle.parentElement as HTMLLabelElement;
        label.click();
        await env.waitForStability();
        expect(toggle.selected).toBeTrue();
        label.click();
        await env.waitForStability();
        expect(toggle.selected).toBeFalse();
      });
    });
  });

  describe('validation', () => {
    it('should set valueMissing when required and not selected', async () => {
      toggle.required = true;

      expect(toggle.validity.valueMissing)
        .withContext('toggle.validity.valueMissing')
        .toBeTrue();
    });

    it('should not set valueMissing when required and selected', async () => {
      toggle.required = true;
      toggle.selected = true;

      expect(toggle.validity.valueMissing)
        .withContext('toggle.validity.valueMissing')
        .toBeFalse();
    });
  });
});


// ========== /switch.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Switch} from './internal/switch.js';
import {styles} from './internal/switch-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-switch': MdSwitch;
  }
}

/**
 * @summary Switches toggle the state of a single item on or off.
 *
 * @description
 * There's one type of switch in Material. Use this selection control when the
 * user needs to toggle a single item on or off.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-switch')
export class MdSwitch extends Switch {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /switch_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createFormTests} from '../testing/forms.js';
import {createTokenTests} from '../testing/tokens.js';

import {SwitchHarness} from './harness.js';
import {MdSwitch} from './switch.js';

describe('<md-switch>', () => {
  const env = new Environment();

  describe('.styles', () => {
    createTokenTests(MdSwitch.styles);
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-switch'),
      valueTests: [
        {
          name: 'unnamed',
          render: () => html`<md-switch selected></md-switch>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'unselected',
          render: () => html`<md-switch name="switch"></md-switch>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when unselected')
              .toHaveSize(0);
          },
        },
        {
          name: 'selected default value',
          render: () => html`<md-switch name="switch" selected></md-switch>`,
          assertValue(formData) {
            expect(formData.get('switch')).toBe('on');
          },
        },
        {
          name: 'selected custom value',
          render: () =>
            html`<md-switch
              name="switch"
              selected
              value="Custom value"></md-switch>`,
          assertValue(formData) {
            expect(formData.get('switch')).toBe('Custom value');
          },
        },
        {
          name: 'disabled',
          render: () =>
            html`<md-switch name="switch" selected disabled></md-switch>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset to unselected',
          render: () => html`<md-switch name="switch"></md-switch>`,
          change(control) {
            control.selected = true;
          },
          assertReset(control) {
            expect(control.selected)
              .withContext('control.selected after reset')
              .toBeFalse();
          },
        },
        {
          name: 'reset to selected',
          render: () => html`<md-switch name="switch" selected></md-switch>`,
          change(control) {
            control.selected = false;
          },
          assertReset(control) {
            expect(control.selected)
              .withContext('control.selected after reset')
              .toBeTrue();
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore unselected',
          render: () => html`<md-switch name="switch"></md-switch>`,
          assertRestored(control) {
            expect(control.selected)
              .withContext('control.selected after restore')
              .toBeFalse();
          },
        },
        {
          name: 'restore selected',
          render: () => html`<md-switch name="switch" selected></md-switch>`,
          assertRestored(control) {
            expect(control.selected)
              .withContext('control.selected after restore')
              .toBeTrue();
          },
        },
      ],
    });
  });

  describe('enter key activation', () => {
    // Don't use harness.clickWithKeyboard() since it simulates a click event.
    // The underlying `<input type="checkbox">` will not dispatch click events
    // in response to the Enter key.

    it('should toggle the switch on', async () => {
      // Arrange
      const root = env.render(html`<md-switch></md-switch>`);
      const harness = new SwitchHarness(root.querySelector('md-switch')!);

      // Act
      await harness.keypress('Enter');
      await harness.element.updateComplete;

      // Assert
      expect(harness.element.selected)
        .withContext('switch is selected after Enter')
        .toBeTrue();
    });

    it('should toggle the switch off', async () => {
      // Arrange
      const root = env.render(html`<md-switch selected></md-switch>`);
      const harness = new SwitchHarness(root.querySelector('md-switch')!);

      // Act
      await harness.keypress('Enter');
      await harness.element.updateComplete;

      // Assert
      expect(harness.element.selected)
        .withContext('switch is unselected after Enter')
        .toBeFalse();
    });

    it('should not toggle the switch when disabled', async () => {
      // Arrange
      const root = env.render(html`<md-switch disabled></md-switch>`);
      const harness = new SwitchHarness(root.querySelector('md-switch')!);

      // Act
      await harness.keypress('Enter');
      await harness.element.updateComplete;

      // Assert
      expect(harness.element.selected)
        .withContext('disabled switch is not selected after Enter')
        .toBeFalse();
    });

    it('should not toggle the switch when keydown event is canceled', async () => {
      // Arrange
      const root = env.render(html`<md-switch></md-switch>`);
      const harness = new SwitchHarness(root.querySelector('md-switch')!);
      harness.element.addEventListener('keydown', (event) => {
        event.preventDefault();
      });

      // Act
      await harness.keypress('Enter');
      await harness.element.updateComplete;

      // Assert
      expect(harness.element.selected)
        .withContext('switch is not selected when Enter is canceled')
        .toBeFalse();
    });
  });
});