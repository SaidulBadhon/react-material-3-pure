/* ========== /_primary-tab.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/primary-tab' show theme;


/* ========== /_secondary-tab.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/secondary-tab' show theme;


/* ========== /internal/_primary-tab.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-primary-tab-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-primary-tab-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-primary-tab-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .content.stacked {
    flex-direction: column;
    gap: 2px;
  }

  .content.stacked.has-icon.has-label {
    height: var(--_with-icon-and-label-text-container-height);
  }
}


/* ========== /internal/_secondary-tab.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-secondary-tab-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-secondary-tab-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-secondary-tab-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }
}


/* ========== /internal/_tab.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/elevation';
@use '../../focus/focus-ring';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

@mixin styles() {
  :host {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    outline: none;
    padding: 0 16px;
    position: relative;
    -webkit-tap-highlight-color: transparent;
    vertical-align: middle;
    user-select: none;
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    line-height: var(--_label-text-line-height);
    font-weight: var(--_label-text-weight);
    color: var(--_label-text-color);
    z-index: 0; // Ensure this is a stacking context so the indicator displays

    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );

    // b/316459034 - elevation should be removed
    @include elevation.theme(
      (
        level: var(--_container-elevation),
      )
    );
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape': 8px,
      )
    );
  }

  :host([active]) md-focus-ring {
    margin-bottom: calc(var(--_active-indicator-height) + 1px);
  }

  .button::before {
    background: var(--_container-color);
    content: '';
    inset: 0;
    position: absolute;
    z-index: -1;
  }

  .button::before,
  md-ripple,
  md-elevation {
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-end-radius: var(--_container-shape-end-end);
    border-end-start-radius: var(--_container-shape-end-start);
  }

  .content {
    position: relative;
    box-sizing: border-box;
    display: inline-flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    height: var(--_container-height);
    gap: 8px;
  }

  .indicator {
    position: absolute;
    box-sizing: border-box;
    z-index: -1;
    transform-origin: bottom left;
    background: var(--_active-indicator-color);
    border-radius: var(--_active-indicator-shape);
    height: var(--_active-indicator-height);
    inset: auto 0 0 0;
    // hidden unless the tab is selected
    opacity: 0;
  }

  // unselected states
  ::slotted([slot='icon']) {
    display: inline-flex;
    position: relative;
    writing-mode: horizontal-tb;
    fill: currentColor;
    color: var(--_icon-color);
    font-size: var(--_icon-size);
    width: var(--_icon-size);
    height: var(--_icon-size);
  }

  :host(:hover) {
    color: var(--_hover-label-text-color);
    cursor: pointer;
  }

  :host(:hover) ::slotted([slot='icon']) {
    color: var(--_hover-icon-color);
  }

  :host(:focus) {
    color: var(--_focus-label-text-color);
  }

  :host(:focus) ::slotted([slot='icon']) {
    color: var(--_focus-icon-color);
  }

  :host(:active) {
    color: var(--_pressed-label-text-color);
  }

  :host(:active) ::slotted([slot='icon']) {
    color: var(--_pressed-icon-color);
  }

  // selected styling
  :host([active]) .indicator {
    opacity: 1;
  }
  :host([active]) {
    color: var(--_active-label-text-color);

    @include ripple.theme(
      (
        hover-color: var(--_active-hover-state-layer-color),
        hover-opacity: var(--_active-hover-state-layer-opacity),
        pressed-color: var(--_active-pressed-state-layer-color),
        pressed-opacity: var(--_active-pressed-state-layer-opacity),
      )
    );
  }

  :host([active]) ::slotted([slot='icon']) {
    color: var(--_active-icon-color);
  }

  // selected states
  :host([active]:hover) {
    color: var(--_active-hover-label-text-color);
  }

  :host([active]:hover) ::slotted([slot='icon']) {
    color: var(--_active-hover-icon-color);
  }

  :host([active]:focus) {
    color: var(--_active-focus-label-text-color);
  }

  :host([active]:focus) ::slotted([slot='icon']) {
    color: var(--_active-focus-icon-color);
  }

  :host([active]:active) {
    color: var(--_active-pressed-label-text-color);
  }

  :host([active]:active) ::slotted([slot='icon']) {
    color: var(--_active-pressed-icon-color);
  }

  :host,
  ::slotted(*) {
    white-space: nowrap;
  }

  @media (forced-colors: active) {
    .indicator {
      background: CanvasText;
    }
  }
}


/* ========== /internal/_tabs.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// Note, there are currently no tokens for tabs. Instead, tabs are entirely
// themed via primary/secondary tab.
@mixin styles() {
  :host {
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: auto;
    scroll-behavior: smooth;
    scrollbar-width: none;
    position: relative;
  }

  :host([hidden]) {
    display: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }

  .tabs {
    align-items: end;
    display: flex;
    height: 100%;
    overflow: inherit;
    scroll-behavior: inherit;
    scrollbar-width: inherit;
    justify-content: space-between;
    width: 100%;
  }

  ::slotted(*) {
    flex: 1;
  }

  // draw selected on top so its indicator can be transitioned from the
  // previously selected tab, on top of it
  ::slotted([active]) {
    z-index: 1;
  }
}


/* ========== /internal/primary-tab-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './primary-tab';
// go/keep-sorted end

@include primary-tab.styles;


// ========== /internal/primary-tab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {property} from 'lit/decorators.js';

import {Tab} from './tab.js';

/**
 * A primary tab component.
 */
export class PrimaryTab extends Tab {
  /**
   * Whether or not the icon renders inline with label or stacked vertically.
   */
  @property({type: Boolean, attribute: 'inline-icon'}) inlineIcon = false;

  protected override getContentClasses() {
    return {
      ...super.getContentClasses(),
      'stacked': !this.inlineIcon,
    };
  }
}


/* ========== /internal/secondary-tab-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './secondary-tab';
// go/keep-sorted end

@include secondary-tab.styles;


// ========== /internal/secondary-tab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Tab} from './tab.js';

/**
 * A secondary tab component.
 */
export class SecondaryTab extends Tab {
  protected override fullWidthIndicator = true;
}


/* ========== /internal/tab-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './tab';
// go/keep-sorted end

@include tab.styles;


// ========== /internal/tab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, nothing} from 'lit';
import {
  property,
  query,
  queryAssignedElements,
  queryAssignedNodes,
  state,
} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';

import {EASING} from '../../internal/motion/animation.js';
import {mixinFocusable} from '../../labs/behaviors/focusable.js';

/**
 * Symbol used by the tab bar to request a tab to animate its indicator from a
 * previously selected tab.
 */
export const ANIMATE_INDICATOR = Symbol('animateIndicator');

// Separate variable needed for closure.
const tabBaseClass = mixinFocusable(LitElement);

/**
 * Tab component.
 */
export class Tab extends tabBaseClass {
  /**
   * The attribute `md-tab` indicates that the element is a tab for the parent
   * element, `<md-tabs>`. Make sure if you're implementing your own `md-tab`
   * component that you have an `md-tab` attribute set.
   */
  @property({type: Boolean, reflect: true, attribute: 'md-tab'})
  readonly isTab = true;

  /**
   * Whether or not the tab is selected.
   **/
  @property({type: Boolean, reflect: true}) active = false;

  /**
   * @deprecated use `active`
   */
  @property({type: Boolean})
  get selected() {
    return this.active;
  }
  set selected(active: boolean) {
    this.active = active;
  }

  /**
   * In SSR, set this to true when an icon is present.
   */
  @property({type: Boolean, attribute: 'has-icon'}) hasIcon = false;

  /**
   * In SSR, set this to true when there is no label and only an icon.
   */
  @property({type: Boolean, attribute: 'icon-only'}) iconOnly = false;

  @query('.indicator') private readonly indicator!: HTMLElement | null;
  @state() protected fullWidthIndicator = false;
  @queryAssignedNodes({flatten: true})
  private readonly assignedDefaultNodes!: Node[];
  @queryAssignedElements({slot: 'icon', flatten: true})
  private readonly assignedIcons!: HTMLElement[];
  private readonly internals =
    // Cast needed for closure
    (this as HTMLElement).attachInternals();

  constructor() {
    super();
    if (!isServer) {
      this.internals.role = 'tab';
      this.addEventListener('keydown', this.handleKeydown.bind(this));
    }
  }

  protected override render() {
    const indicator = html`<div class="indicator"></div>`;
    return html`<div
      class="button"
      role="presentation"
      @click=${this.handleContentClick}>
      <md-focus-ring part="focus-ring" inward .control=${this}></md-focus-ring>
      <md-elevation part="elevation"></md-elevation>
      <md-ripple .control=${this}></md-ripple>
      <div
        class="content ${classMap(this.getContentClasses())}"
        role="presentation">
        <slot name="icon" @slotchange=${this.handleIconSlotChange}></slot>
        <slot @slotchange=${this.handleSlotChange}></slot>
        ${this.fullWidthIndicator ? nothing : indicator}
      </div>
      ${this.fullWidthIndicator ? indicator : nothing}
    </div>`;
  }

  protected getContentClasses(): ClassInfo {
    return {
      'has-icon': this.hasIcon,
      'has-label': !this.iconOnly,
    };
  }

  protected override updated() {
    this.internals.ariaSelected = String(this.active);
  }

  private async handleKeydown(event: KeyboardEvent) {
    // Allow event to bubble.
    await 0;
    if (event.defaultPrevented) {
      return;
    }

    if (event.key === 'Enter' || event.key === ' ') {
      // Prevent default behavior such as scrolling when pressing spacebar.
      event.preventDefault();
      this.click();
    }
  }

  private handleContentClick(event: Event) {
    // Ensure the "click" target is always the tab, and not content, by stopping
    // propagation of content clicks and re-clicking the host.
    event.stopPropagation();
    this.click();
  }

  [ANIMATE_INDICATOR](previousTab: Tab) {
    if (!this.indicator) {
      return;
    }

    this.indicator.getAnimations().forEach((a) => {
      a.cancel();
    });
    const frames = this.getKeyframes(previousTab);
    if (frames !== null) {
      this.indicator.animate(frames, {
        duration: 250,
        easing: EASING.EMPHASIZED,
      });
    }
  }

  private getKeyframes(previousTab: Tab) {
    const reduceMotion = shouldReduceMotion();
    if (!this.active) {
      return reduceMotion ? [{'opacity': 1}, {'transform': 'none'}] : null;
    }

    const from: Keyframe = {};
    const fromRect =
      previousTab.indicator?.getBoundingClientRect() ?? ({} as DOMRect);
    const fromPos = fromRect.left;
    const fromExtent = fromRect.width;
    const toRect = this.indicator!.getBoundingClientRect();
    const toPos = toRect.left;
    const toExtent = toRect.width;
    const scale = fromExtent / toExtent;
    if (
      !reduceMotion &&
      fromPos !== undefined &&
      toPos !== undefined &&
      !isNaN(scale)
    ) {
      from['transform'] = `translateX(${(fromPos - toPos).toFixed(
        4,
      )}px) scaleX(${scale.toFixed(4)})`;
    } else {
      from['opacity'] = 0;
    }
    // note, including `transform: none` avoids quirky Safari behavior
    // that can hide the animation.
    return [from, {'transform': 'none'}];
  }

  private handleSlotChange() {
    this.iconOnly = false;
    // Check if there's any label text or elements. If not, then there is only
    // an icon.
    for (const node of this.assignedDefaultNodes) {
      const hasTextContent =
        node.nodeType === Node.TEXT_NODE &&
        !!(node as Text).wholeText.match(/\S/);
      if (node.nodeType === Node.ELEMENT_NODE || hasTextContent) {
        return;
      }
    }

    this.iconOnly = true;
  }

  private handleIconSlotChange() {
    this.hasIcon = this.assignedIcons.length > 0;
  }
}

function shouldReduceMotion() {
  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
}


/* ========== /internal/tabs-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './tabs';
// go/keep-sorted end

@include tabs.styles;


// ========== /internal/tabs.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../divider/divider.js';

import {html, isServer, LitElement} from 'lit';
import {property, query, queryAssignedElements} from 'lit/decorators.js';

import {ANIMATE_INDICATOR, Tab} from './tab.js';

/**
 * @fires change {Event} Fired when the selected tab changes. The target's
 * `activeTabIndex` or `activeTab` provide information about the selection
 * change. The change event is fired when a user interaction like a space/enter
 * key or click cause a selection change. The tab selection based on these
 * actions can be cancelled by calling preventDefault on the triggering
 * `keydown` or `click` event. --bubbles
 *
 * @example
 * // perform an action if a tab is clicked
 * tabs.addEventListener('change', (event: Event) => {
 *   if (event.target.activeTabIndex === 2)
 *     takeAction();
 *   }
 * });
 *
 * // prevent a click from triggering tab selection under some condition
 * tabs.addEventListener('click', (event: Event) => {
 *   if (notReady)
 *     event.preventDefault();
 *   }
 * });
 *
 */
export class Tabs extends LitElement {
  /**
   * The tabs of this tab bar.
   */
  @queryAssignedElements({flatten: true, selector: '[md-tab]'})
  readonly tabs!: Tab[];

  /**
   * The currently selected tab, `null` only when there are no tab children.
   *
   * @export
   */
  get activeTab() {
    return this.tabs.find((tab) => tab.active) ?? null;
  }
  set activeTab(tab: Tab | null) {
    // Ignore setting activeTab to null. As long as there are children, one tab
    // must be selected.
    if (tab) {
      this.activateTab(tab);
    }
  }

  /**
   * The index of the currently selected tab.
   *
   * @export
   */
  @property({type: Number, attribute: 'active-tab-index'})
  get activeTabIndex() {
    return this.tabs.findIndex((tab) => tab.active);
  }
  set activeTabIndex(index: number) {
    const activateTabAtIndex = () => {
      const tab = this.tabs[index];
      // Ignore out-of-bound indices.
      if (tab) {
        this.activateTab(tab);
      }
    };

    if (!this.slotElement) {
      // This is needed to support setting the activeTabIndex via a lit property
      // binding.
      //
      // ```ts
      // html`
      //   <md-tabs .activeTabIndex=${1}>
      //     <md-tab>First</md-tab>
      //     <md-tab>Second</md-tab>
      //   </md-tabs>
      // `;
      // ```
      //
      // It's needed since lit's rendering lifecycle is asynchronous, and the
      // `<slot>` element hasn't rendered, so `tabs` is empty.
      this.updateComplete.then(activateTabAtIndex);
      return;
    }

    activateTabAtIndex();
  }

  /**
   * Whether or not to automatically select a tab when it is focused.
   */
  @property({type: Boolean, attribute: 'auto-activate'}) autoActivate = false;

  @query('.tabs') private readonly tabsScrollerElement!: HTMLElement | null;
  @query('slot') private readonly slotElement!: HTMLSlotElement | null;

  private get focusedTab() {
    return this.tabs.find((tab) => tab.matches(':focus-within'));
  }

  private readonly internals =
    // Cast needed for closure
    (this as HTMLElement).attachInternals();

  constructor() {
    super();
    if (!isServer) {
      this.internals.role = 'tablist';
      this.addEventListener('keydown', this.handleKeydown.bind(this));
      this.addEventListener('keyup', this.handleKeyup.bind(this));
      this.addEventListener('focusout', this.handleFocusout.bind(this));
    }
  }

  /**
   * Scrolls the toolbar, if overflowing, to the active tab, or the provided
   * tab.
   *
   * @param tabToScrollTo The tab that should be scrolled to. Defaults to the
   *     active tab.
   * @return A Promise that resolves after the tab has been scrolled to.
   */
  async scrollToTab(tabToScrollTo?: Tab | null) {
    await this.updateComplete;
    const {tabs} = this;
    tabToScrollTo ??= this.activeTab;
    if (
      !tabToScrollTo ||
      !tabs.includes(tabToScrollTo) ||
      !this.tabsScrollerElement
    ) {
      return;
    }

    // wait for tabs to render.
    for (const tab of this.tabs) {
      await tab.updateComplete;
    }

    const offset = tabToScrollTo.offsetLeft;
    const extent = tabToScrollTo.offsetWidth;
    const scroll = this.scrollLeft;
    const hostExtent = this.offsetWidth;
    const scrollMargin = 48;
    const min = offset - scrollMargin;
    const max = offset + extent - hostExtent + scrollMargin;
    const to = Math.min(min, Math.max(max, scroll));
    // When a tab is focused, use 'auto' to use the CSS `scroll-behavior`. The
    // default behavior is smooth scrolling. However, when there is not a tab
    // focused on initialization, use 'instant' to immediately bring the focused
    // tab into view.
    const behavior: ScrollBehavior = !this.focusedTab ? 'instant' : 'auto';
    this.tabsScrollerElement.scrollTo({behavior, top: 0, left: to});
  }

  protected override render() {
    return html`
      <div class="tabs">
        <slot
          @slotchange=${this.handleSlotChange}
          @click=${this.handleTabClick}></slot>
      </div>
      <md-divider part="divider"></md-divider>
    `;
  }

  private async handleTabClick(event: Event) {
    const tab = event.target;
    // Allow event to bubble
    await 0;
    if (event.defaultPrevented || !isTab(tab) || tab.active) {
      return;
    }

    this.activateTab(tab);
  }

  private activateTab(activeTab: Tab) {
    const {tabs} = this;
    const previousTab = this.activeTab;
    if (!tabs.includes(activeTab) || previousTab === activeTab) {
      // Ignore setting activeTab to a tab element that is not a child.
      return;
    }

    for (const tab of tabs) {
      tab.active = tab === activeTab;
    }

    if (previousTab) {
      // Don't dispatch a change event if activating a tab when no previous tabs
      // were selected, such as when md-tabs auto-selects the first tab.
      const defaultPrevented = !this.dispatchEvent(
        new Event('change', {bubbles: true, cancelable: true}),
      );
      if (defaultPrevented) {
        for (const tab of tabs) {
          tab.active = tab === previousTab;
        }
        return;
      }

      activeTab[ANIMATE_INDICATOR](previousTab);
    }

    this.updateFocusableTab(activeTab);
    this.scrollToTab(activeTab);
  }

  private updateFocusableTab(focusableTab: Tab) {
    for (const tab of this.tabs) {
      tab.tabIndex = tab === focusableTab ? 0 : -1;
    }
  }

  // focus item on keydown and optionally select it
  private async handleKeydown(event: KeyboardEvent) {
    // Allow event to bubble.
    await 0;
    const isLeft = event.key === 'ArrowLeft';
    const isRight = event.key === 'ArrowRight';
    const isHome = event.key === 'Home';
    const isEnd = event.key === 'End';
    // Ignore non-navigation keys
    if (event.defaultPrevented || (!isLeft && !isRight && !isHome && !isEnd)) {
      return;
    }

    const {tabs} = this;
    // Don't try to select another tab if there aren't any.
    if (tabs.length < 2) {
      return;
    }

    // Prevent default interactions, such as scrolling.
    event.preventDefault();

    let indexToFocus: number;
    if (isHome || isEnd) {
      indexToFocus = isHome ? 0 : tabs.length - 1;
    } else {
      // Check if moving forwards or backwards
      const isRtl = getComputedStyle(this).direction === 'rtl';
      const forwards = isRtl ? isLeft : isRight;
      const {focusedTab} = this;
      if (!focusedTab) {
        // If there is not already a tab focused, select the first or last tab
        // based on the direction we're traveling.
        indexToFocus = forwards ? 0 : tabs.length - 1;
      } else {
        const focusedIndex = this.tabs.indexOf(focusedTab);
        indexToFocus = forwards ? focusedIndex + 1 : focusedIndex - 1;
        if (indexToFocus >= tabs.length) {
          // Return to start if moving past the last item.
          indexToFocus = 0;
        } else if (indexToFocus < 0) {
          // Go to end if moving before the first item.
          indexToFocus = tabs.length - 1;
        }
      }
    }

    const tabToFocus = tabs[indexToFocus];
    tabToFocus.focus();
    if (this.autoActivate) {
      this.activateTab(tabToFocus);
    } else {
      this.updateFocusableTab(tabToFocus);
    }
  }

  // scroll to item on keyup.
  private handleKeyup() {
    this.scrollToTab(this.focusedTab ?? this.activeTab);
  }

  private handleFocusout() {
    // restore focus to selected item when blurring the tab bar.
    if (this.matches(':focus-within')) {
      return;
    }

    const {activeTab} = this;
    if (activeTab) {
      this.updateFocusableTab(activeTab);
    }
  }

  private handleSlotChange() {
    const firstTab = this.tabs[0];
    if (!this.activeTab && firstTab) {
      // If the active tab was removed, auto-select the first one. There should
      // always be a selected tab while the bar has children.
      this.activateTab(firstTab);
    }

    // When children shift, ensure the active tab is visible. For example, if
    // many children are added before the active tab, it'd be pushed off screen.
    // This ensures it stays visible.
    this.scrollToTab(this.activeTab);
  }
}

function isTab(element: unknown): element is Tab {
  return element instanceof HTMLElement && element.hasAttribute('md-tab');
}


// ========== /primary-tab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {PrimaryTab} from './internal/primary-tab.js';
import {styles as primaryStyles} from './internal/primary-tab-styles.js';
import {styles as sharedStyles} from './internal/tab-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-primary-tab': MdPrimaryTab;
  }
}

// TODO(b/267336507): add docs
/**
 * @summary Tab allow users to display a tab within a Tabs.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-primary-tab')
export class MdPrimaryTab extends PrimaryTab {
  static override styles: CSSResultOrNative[] = [sharedStyles, primaryStyles];
}


// ========== /secondary-tab.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {SecondaryTab} from './internal/secondary-tab.js';
import {styles as secondaryStyles} from './internal/secondary-tab-styles.js';
import {styles as sharedStyles} from './internal/tab-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-secondary-tab': MdSecondaryTab;
  }
}

// TODO(b/267336507): add docs
/**
 * @summary Tab allow users to display a tab within a Tabs.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-secondary-tab')
export class MdSecondaryTab extends SecondaryTab {
  static override styles: CSSResultOrNative[] = [sharedStyles, secondaryStyles];
}


// ========== /tabs.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Tabs} from './internal/tabs.js';
import {styles} from './internal/tabs-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-tabs': MdTabs;
  }
}

// TODO(b/267336507): add docs
/**
 * @summary Tabs displays a list of selectable tabs.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-tabs')
export class MdTabs extends Tabs {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /tabs_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createTokenTests} from '../testing/tokens.js';

import {TabsHarness} from './harness.js';
import {MdPrimaryTab} from './primary-tab.js';
import {MdSecondaryTab} from './secondary-tab.js';
import {MdTabs} from './tabs.js';

interface TabsTestProps {
  activeTabIndex?: number;
}

function getTabsTemplate(props?: TabsTestProps) {
  return html` <md-tabs .activeTabIndex=${props?.activeTabIndex ?? 0}>
    <md-primary-tab>A</md-primary-tab>
    <md-primary-tab>B</md-primary-tab>
    <md-primary-tab>C</md-primary-tab>
  </md-tabs>`;
}

describe('<md-tabs>', () => {
  const env = new Environment();

  async function setupTest(props?: TabsTestProps, template = getTabsTemplate) {
    const root = env.render(template(props));
    await env.waitForStability();
    const tab = root.querySelector<MdTabs>('md-tabs')!;
    const harness = new TabsHarness(tab);
    return {harness, root};
  }

  describe('.styles', () => {
    createTokenTests(MdTabs.styles);
    createTokenTests(MdPrimaryTab.styles);
    createTokenTests(MdSecondaryTab.styles);
  });

  describe('properties', () => {
    it('renders selected with indicator', async () => {
      const {harness} = await setupTest({activeTabIndex: 1});
      expect(harness.element.activeTabIndex).toBe(1);
      expect(harness.element.activeTab).toBe(harness.harnessedItems[1].element);
      harness.harnessedItems.forEach(async (tabHarness, i) => {
        const shouldBeSelected = i === harness.element.activeTabIndex;
        await tabHarness.element.updateComplete;
        expect(tabHarness.element.active).toBe(shouldBeSelected);
        expect(await tabHarness.isIndicatorShowing()).toBe(shouldBeSelected);
      });
      await env.waitForStability();
      harness.element.activeTabIndex = 0;
      await harness.element.updateComplete;
      expect(harness.element.activeTabIndex).toBe(0);
      harness.harnessedItems.forEach(async (tabHarness, i) => {
        const shouldBeSelected = i === harness.element.activeTabIndex;
        await tabHarness.element.updateComplete;
        expect(tabHarness.element.active).toBe(shouldBeSelected);
        expect(await tabHarness.isIndicatorShowing()).toBe(shouldBeSelected);
      });
    });

    it('updates activeTab', async () => {
      const {harness} = await setupTest({activeTabIndex: 1});
      expect(harness.element.activeTab).toBe(harness.harnessedItems[1].element);
      harness.element.activeTabIndex = 0;
      await harness.element.updateComplete;
      expect(harness.element.activeTab).toBe(harness.harnessedItems[0].element);
    });

    it('maintains selection when tabs are mutated', async () => {
      // Note: adding and moving tabs does not change selection
      const {harness} = await setupTest({activeTabIndex: 1});
      const [, second] = harness.element.tabs;
      expect(harness.element.activeTab).toBe(second);
      const tab = document.createElement('md-primary-tab');
      tab.textContent = 'tab';
      // add before selected
      harness.element.prepend(tab);
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(second);
      // move after selected
      harness.element.activeTab?.after(tab);
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(second);
      // move before selected
      harness.element.prepend(tab);
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(second);
      // remove
      tab.remove();
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(second);
    });

    it('selects first item when selected tab is removed', async () => {
      const {harness} = await setupTest({activeTabIndex: 1});
      const [first, second] = harness.element.tabs;
      expect(harness.element.activeTab).toBe(second);
      second.remove();
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(first);
    });

    it('should ignore setting activeTab when tab is not a child', async () => {
      const {harness} = await setupTest();
      const [firstTab] = harness.element.tabs;
      expect(harness.element.activeTab).toBe(firstTab);
      const unrelatedTab = document.createElement('md-primary-tab');
      harness.element.activeTab = unrelatedTab;
      await env.waitForStability();
      expect(harness.element.activeTab).toBe(firstTab);
    });

    it('should allow setting activeTabIndex in a lit property binding', async () => {
      const root = env.render(html`
        <md-tabs .activeTabIndex=${1}>
          <md-primary-tab>A</md-primary-tab>
          <md-primary-tab>B</md-primary-tab>
        </md-tabs>
      `);

      await env.waitForStability();
      const tabs = root.querySelector('md-tabs')!;
      expect(tabs.activeTabIndex).withContext('activeTabIndex').toBe(1);
      expect(tabs.activeTab?.textContent)
        .withContext('activeTab')
        .toBe('B');
    });

    it('should allow setting active-tab-index as an attribute', async () => {
      const root = env.render(html`
        <md-tabs active-tab-index=${1}>
          <md-primary-tab>A</md-primary-tab>
          <md-primary-tab>B</md-primary-tab>
        </md-tabs>
      `);

      await env.waitForStability();
      const tabs = root.querySelector('md-tabs')!;
      expect(tabs.activeTabIndex).withContext('activeTabIndex').toBe(1);
      expect(tabs.activeTab?.textContent)
        .withContext('activeTab')
        .toBe('B');
    });
  });

  it('should dispatch "change" when tab changes', async () => {
    const {harness} = await setupTest();
    const changeListener = jasmine.createSpy('changeListener');
    harness.element.addEventListener('change', changeListener);

    await harness.harnessedItems[1].clickWithMouse();
    expect(changeListener).toHaveBeenCalledTimes(1);
  });

  it('should not dispatch "change" when changing to unrelated tab', async () => {
    const {harness} = await setupTest();
    const changeListener = jasmine.createSpy('changeListener');
    harness.element.addEventListener('change', changeListener);

    harness.element.activeTab = document.createElement('md-primary-tab');
    await env.waitForStability();
    expect(changeListener).not.toHaveBeenCalled();
  });

  it('should not dispatch "change" when setting activeTab to itself', async () => {
    const {harness} = await setupTest();
    const changeListener = jasmine.createSpy('changeListener');
    harness.element.addEventListener('change', changeListener);

    harness.element.activeTab = harness.element.activeTab;
    await env.waitForStability();
    expect(changeListener).not.toHaveBeenCalled();
  });
});