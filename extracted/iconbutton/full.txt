/* ========== /_filled-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-icon-button' show theme;


/* ========== /_filled-tonal-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-tonal-icon-button' show theme;


/* ========== /_icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/icon-button' show theme;


/* ========== /_outlined-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/outlined-icon-button' show theme;


// ========== /filled-icon-button.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles} from './internal/filled-styles.js';
import {IconButton} from './internal/icon-button.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-icon-button': MdFilledIconButton;
  }
}

/**
 * @summary Icon buttons help people take supplementary actions with a single
 * tap.
 *
 * @description
 * __Emphasis:__ Low emphasis – For optional or supplementary actions with the
 * least amount of prominence.
 *
 * __Rationale:__ The most compact and unobtrusive type of button, icon buttons
 * are used for optional supplementary actions such as "Bookmark" or "Star."
 *
 * __Example usages:__
 * - Add to Favorites
 * - Print
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-icon-button')
export class MdFilledIconButton extends IconButton {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];

  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'filled': true,
      'toggle-filled': this.toggle,
    };
  }
}


// ========== /filled-icon-button_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdFilledIconButton} from './filled-icon-button.js';

describe('<md-filled-icon-button>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledIconButton.styles);
  });
});


// ========== /filled-tonal-icon-button.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles} from './internal/filled-tonal-styles.js';
import {IconButton} from './internal/icon-button.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-tonal-icon-button': MdFilledTonalIconButton;
  }
}

/**
 * @summary Icon buttons help people take supplementary actions with a single
 * tap.
 *
 * @description
 * __Emphasis:__ Low emphasis – For optional or supplementary actions with the
 * least amount of prominence.
 *
 * __Rationale:__ The most compact and unobtrusive type of button, icon buttons
 * are used for optional supplementary actions such as "Bookmark" or "Star."
 *
 * __Example usages:__
 * - Add to Favorites
 * - Print
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-tonal-icon-button')
export class MdFilledTonalIconButton extends IconButton {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];

  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'filled-tonal': true,
      'toggle-filled-tonal': this.toggle,
    };
  }
}


// ========== /filled-tonal-icon-button_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdFilledTonalIconButton} from './filled-tonal-icon-button.js';

describe('<md-filled-tonal-icon-button', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledTonalIconButton.styles);
  });
});


// ========== /icon-button.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {IconButton} from './internal/icon-button.js';
import {styles as sharedStyles} from './internal/shared-styles.js';
import {styles} from './internal/standard-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-icon-button': MdIconButton;
  }
}

/**
 * @summary Icon buttons help people take supplementary actions with a single
 * tap.
 *
 * @description
 * __Emphasis:__ Low emphasis – For optional or supplementary actions with the
 * least amount of prominence.
 *
 * __Rationale:__ The most compact and unobtrusive type of button, icon buttons
 * are used for optional supplementary actions such as "Bookmark" or "Star."
 *
 * __Example usages:__
 * - Add to Favorites
 * - Print
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-icon-button')
export class MdIconButton extends IconButton {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];

  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'standard': true,
    };
  }
}


// ========== /icon-button_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../icon/icon.js';
import './icon-button.js';

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createTokenTests} from '../testing/tokens.js';

import {IconButtonHarness} from './harness.js';
import {MdIconButton} from './icon-button.js';

const ICON_BUTTON_TEMPLATE = html`
  <md-icon-button aria-label="Star">
    <md-icon>star</md-icon>
  </md-icon-button>
`;
const LINK_ICON_BUTTON_TEMPLATE = html`
  <md-icon-button aria-label="Star" href="https://google.com">
    <md-icon>star</md-icon>
  </md-icon-button>
`;
const ICON_BUTTON_TOGGLE_TEMPLATE = html`
  <md-icon-button toggle aria-label="Star">
    <md-icon slot="onIcon">star</md-icon>
    <md-icon slot="offIcon">star_border</md-icon>
  </md-icon-button>
`;

interface IconButtonInternals {
  flipIcon: boolean;
}

describe('icon button tests', () => {
  const env = new Environment();

  describe('.styles', () => {
    createTokenTests(MdIconButton.styles);
  });

  describe('md-icon-button', () => {
    it(
      'setting `disabled` updates the disabled attribute on the native ' +
        'button element',
      async () => {
        const {element} = await setUpTest('button');
        const button = element.shadowRoot!.querySelector('button')!;

        element.disabled = true;
        await element.updateComplete;
        expect(button.hasAttribute('disabled')).toBeTrue();

        element.disabled = false;
        await element.updateComplete;
        expect(button.hasAttribute('disabled')).toBeFalse();
      },
    );

    it('should not be focusable when disabled', async () => {
      // Arrange
      const {element} = await setUpTest('button');
      element.disabled = true;
      await element.updateComplete;

      // Act
      element.focus();

      // Assert
      expect(document.activeElement)
        .withContext('disabled button should not be focused')
        .not.toBe(element);
    });

    it('should be focusable when soft-disabled', async () => {
      // Arrange
      const {element} = await setUpTest('button');
      element.softDisabled = true;
      await element.updateComplete;

      // Act
      element.focus();

      // Assert
      expect(document.activeElement)
        .withContext('soft-disabled button should be focused')
        .toBe(element);
    });

    it('should not be clickable when disabled', async () => {
      // Arrange
      const clickListener = jasmine.createSpy('clickListener');
      const {element} = await setUpTest('button');
      element.disabled = true;
      element.addEventListener('click', clickListener);
      await element.updateComplete;

      // Act
      element.click();

      // Assert
      expect(clickListener).not.toHaveBeenCalled();
    });

    it('should not be clickable when soft-disabled', async () => {
      // Arrange
      const clickListener = jasmine.createSpy('clickListener');
      const {element} = await setUpTest('button');
      element.softDisabled = true;
      element.addEventListener('click', clickListener);
      await element.updateComplete;

      // Act
      element.click();

      // Assert
      expect(clickListener).not.toHaveBeenCalled();
    });

    it(
      'setting `ariaLabel` updates the aria-label attribute on the native ' +
        'button element',
      async () => {
        const {element} = await setUpTest('button');
        const button = element.shadowRoot!.querySelector('button')!;

        element.ariaLabel = 'test';
        await element.updateComplete;
        expect(button.getAttribute('aria-label')).toBe('test');
      },
    );
  });

  describe('md-icon-button link', () => {
    it(
      'setting `ariaLabel` updates the aria-label attribute on the anchor' +
        'tag',
      async () => {
        const {element} = await setUpTest('link');
        const anchor = element.shadowRoot!.querySelector('a')!;
        expect(anchor).not.toBeNull();

        element.ariaLabel = 'test';
        await element.updateComplete;
        expect(anchor.getAttribute('aria-label')).toBe('test');
      },
    );
  });

  describe('md-icon-button toggle', () => {
    it(
      'setting `disabled` updates the disabled attribute on the native ' +
        'button element',
      async () => {
        const {element} = await setUpTest('toggle');
        const button = element.shadowRoot!.querySelector('button')!;

        element.disabled = true;
        await element.updateComplete;
        expect(button.hasAttribute('disabled')).toBeTrue();

        element.disabled = false;
        await element.updateComplete;
        expect(button.hasAttribute('disabled')).toBeFalse();
      },
    );

    it(
      'setting `ariaLabel` updates the aria-label attribute on the native ' +
        'button element',
      async () => {
        const {element} = await setUpTest('toggle');
        const button = element.shadowRoot!.querySelector('button')!;

        element.ariaLabel = 'test';
        await element.updateComplete;
        expect(button.getAttribute('aria-label')).toBe('test');
      },
    );

    it('toggles the `selected` state when button is clicked', async () => {
      const {element, harness} = await setUpTest('toggle');

      expect(element.selected).toBeFalse();
      await harness.clickWithMouse();
      expect(element.selected).toBeTrue();
      await harness.clickWithMouse();
      expect(element.selected).toBeFalse();
    });

    it('fires input and change events when clicked', async () => {
      const {element, harness} = await setUpTest('toggle');
      let changeEvent = false;
      let inputEvent = false;
      element.addEventListener('input', () => (inputEvent = true));
      element.addEventListener('change', () => (changeEvent = true));
      expect(element.selected).toBeFalse();
      await harness.clickWithMouse();
      expect(element.selected).toBeTrue();
      expect(inputEvent).toBeTrue();
      expect(changeEvent).toBeTrue();
    });

    it('setting `selected` updates the aria-pressed attribute on the native button element', async () => {
      const {element} = await setUpTest('toggle');

      element.selected = true;
      await element.updateComplete;
      const button = element.shadowRoot!.querySelector('button')!;
      expect(button.getAttribute('aria-pressed')).toEqual('true');

      element.selected = false;
      await element.updateComplete;
      expect(button.getAttribute('aria-pressed')).toEqual('false');
    });

    it('button with toggled aria label toggles aria label', async () => {
      const {element, harness} = await setUpTest('toggle');
      element.ariaLabelSelected = 'aria label on';
      element.ariaLabel = 'aria label off';
      await element.updateComplete;

      const button = element.shadowRoot!.querySelector('button')!;
      expect(element.selected).toBeFalse();
      expect(button.getAttribute('aria-label')).toEqual('aria label off');

      // Toggle
      await harness.clickWithMouse();
      await element.updateComplete;
      expect(element.selected).toBeTrue();
      expect(button.getAttribute('aria-label')).toEqual('aria label on');
    });

    it('if `flipsIconInRtl=true`, flips icon in an RTL context', async () => {
      const template = html` <div dir="rtl">
        <md-icon-button aria-label="Star" .flipIconInRtl="${true}">
          star
        </md-icon-button>
      </div>`;
      const element = env.render(template).querySelector('md-icon-button')!;
      await env.waitForStability();

      expect((element as unknown as IconButtonInternals).flipIcon).toBeTrue();
    });

    it('if `flipsIconInRtl=true`, does not flip icon in an LTR context', async () => {
      const template = html` <div dir="ltr">
        <md-icon-button aria-label="Star" .flipIconInRtl="${true}">
          star
        </md-icon-button>
      </div>`;
      const element = env.render(template).querySelector('md-icon-button')!;
      await env.waitForStability();

      expect((element as unknown as IconButtonInternals).flipIcon).toBeFalse();
    });

    it('should allow preventing toggle click event', async () => {
      const {element, harness} = await setUpTest('toggle');

      element.addEventListener('click', (event) => {
        event.preventDefault();
      });

      expect(element.selected).withContext('selected before click').toBeFalse();
      await harness.clickWithMouse();
      expect(element.selected)
        .withContext('selected after prevent default click')
        .toBeFalse();
    });
  });

  async function setUpTest(type: string) {
    let template;
    switch (type) {
      case 'button':
        template = ICON_BUTTON_TEMPLATE;
        break;
      case 'link':
        template = LINK_ICON_BUTTON_TEMPLATE;
        break;
      case 'toggle':
        template = ICON_BUTTON_TOGGLE_TEMPLATE;
        break;
      default:
        throw new Error('Invalid tag name: ' + type);
    }

    const element = env.render(template).querySelector('md-icon-button')!;
    await env.waitForStability();
    return {
      element,
      harness: new IconButtonHarness(element),
    };
  }
});


/* ========== /internal/_filled-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filled-icon-button-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-filled-icon-button-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-icon-button-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .icon-button {
    color: var(--_icon-color);

    &:hover {
      color: var(--_hover-icon-color);
    }

    &:focus {
      color: var(--_focus-icon-color);
    }

    &:active {
      color: var(--_pressed-icon-color);
    }

    &:is(:disabled, [aria-disabled='true']) {
      color: var(--_disabled-icon-color);
    }

    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .icon-button::before {
    // Background color, separate node for opacity changes
    background-color: var(--_container-color);
    border-radius: inherit;
    content: '';
    inset: 0;
    position: absolute;
    z-index: -1; // place behind content
  }

  .icon-button:is(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_disabled-container-color);
    opacity: var(--_disabled-container-opacity);
  }

  .icon-button:is(:disabled, [aria-disabled='true']) .icon {
    opacity: var(--_disabled-icon-opacity);
  }

  .toggle-filled {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_toggle-icon-color);

      &:hover {
        color: var(--_toggle-hover-icon-color);
      }

      &:focus {
        color: var(--_toggle-focus-icon-color);
      }

      &:active {
        color: var(--_toggle-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_toggle-hover-state-layer-color),
        pressed-color: var(--_toggle-pressed-state-layer-color),
      )
    );
  }

  .toggle-filled:not(:disabled, [aria-disabled='true'])::before {
    // Note: filled icon buttons have three container colors,
    // "container-color" for regular, then selected/unselected for toggle.
    background-color: var(--_unselected-container-color);
  }

  .selected {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_toggle-selected-icon-color);

      &:hover {
        color: var(--_toggle-selected-hover-icon-color);
      }

      &:focus {
        color: var(--_toggle-selected-focus-icon-color);
      }

      &:active {
        color: var(--_toggle-selected-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_toggle-selected-hover-state-layer-color),
        pressed-color: var(--_toggle-selected-pressed-state-layer-color),
      )
    );
  }

  .selected:not(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_selected-container-color);
  }
}


/* ========== /internal/_filled-tonal-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filled-tonal-icon-button-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-filled-tonal-icon-button-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-tonal-icon-button-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .icon-button {
    color: var(--_icon-color);

    &:hover {
      color: var(--_hover-icon-color);
    }

    &:focus {
      color: var(--_focus-icon-color);
    }

    &:active {
      color: var(--_pressed-icon-color);
    }

    &:is(:disabled, [aria-disabled='true']) {
      color: var(--_disabled-icon-color);
    }

    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .icon-button::before {
    // Background color, separate node for opacity changes
    background-color: var(--_container-color);
    border-radius: inherit;
    content: '';
    inset: 0;
    position: absolute;
    z-index: -1; // place behind content
  }

  .icon-button:is(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_disabled-container-color);
    opacity: var(--_disabled-container-opacity);
  }

  .icon-button:is(:disabled, [aria-disabled='true']) .icon {
    opacity: var(--_disabled-icon-opacity);
  }

  .toggle-filled-tonal {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_toggle-icon-color);

      &:hover {
        color: var(--_toggle-hover-icon-color);
      }

      &:focus {
        color: var(--_toggle-focus-icon-color);
      }

      &:active {
        color: var(--_toggle-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_toggle-hover-state-layer-color),
        pressed-color: var(--_toggle-pressed-state-layer-color),
      )
    );
  }

  .toggle-filled-tonal:not(:disabled, [aria-disabled='true'])::before {
    // Note: filled tonal icon buttons have three container colors,
    // "container-color" for regular, then selected/unselected for toggle.
    background-color: var(--_unselected-container-color);
  }

  .selected {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_toggle-selected-icon-color);

      &:hover {
        color: var(--_toggle-selected-hover-icon-color);
      }

      &:focus {
        color: var(--_toggle-selected-focus-icon-color);
      }

      &:active {
        color: var(--_toggle-selected-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_toggle-selected-hover-state-layer-color),
        pressed-color: var(--_toggle-selected-pressed-state-layer-color),
      )
    );
  }

  .selected:not(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_selected-container-color);
  }
}


/* ========== /internal/_icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-icon-button-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-icon-button-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-icon-button-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    // These custom properties are not used, so set defaults so token tests pass
    // for <md-icon-button>.
    --_container-shape-start-start: 0;
    --_container-shape-start-end: 0;
    --_container-shape-end-end: 0;
    --_container-shape-end-start: 0;
    --_container-height: 0;
    --_container-width: 0;

    height: var(--_state-layer-height);
    width: var(--_state-layer-width);
  }

  :host([touch-target='wrapper']) {
    margin: max(0px, (48px - var(--_state-layer-height))/2)
      max(0px, (48px - var(--_state-layer-width))/2);
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape-start-start': var(--_state-layer-shape),
        'shape-start-end': var(--_state-layer-shape),
        'shape-end-end': var(--_state-layer-shape),
        'shape-end-start': var(--_state-layer-shape),
      )
    );
  }

  .standard {
    background-color: transparent;
    color: var(--_icon-color);

    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );

    &:hover {
      color: var(--_hover-icon-color);
    }

    &:focus {
      color: var(--_focus-icon-color);
    }

    &:active {
      color: var(--_pressed-icon-color);
    }

    &:is(:disabled, [aria-disabled='true']) {
      color: var(--_disabled-icon-color);
    }
  }

  md-ripple {
    border-radius: var(--_state-layer-shape);
  }

  .standard:is(:disabled, [aria-disabled='true']) {
    opacity: var(--_disabled-icon-opacity);
  }

  .selected {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_selected-icon-color);

      &:hover {
        color: var(--_selected-hover-icon-color);
      }

      &:focus {
        color: var(--_selected-focus-icon-color);
      }

      &:active {
        color: var(--_selected-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_selected-hover-state-layer-color),
        hover-opacity: var(--_selected-hover-state-layer-opacity),
        pressed-color: var(--_selected-pressed-state-layer-color),
        pressed-opacity: var(--_selected-pressed-state-layer-opacity),
      )
    );
  }
}


/* ========== /internal/_outlined-icon-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../ripple/ripple';
@use '../../tokens';
@use './shared';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-outlined-icon-button-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-icon-button-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-icon-button-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'container-shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .outlined {
    background-color: transparent;
    color: var(--_icon-color);

    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );

    &::before {
      border-color: var(--_outline-color);
      border-width: var(--_outline-width);
    }

    &:hover {
      color: var(--_hover-icon-color);
    }

    &:focus {
      color: var(--_focus-icon-color);
    }

    &:active {
      color: var(--_pressed-icon-color);
    }

    &:is(:disabled, [aria-disabled='true']) {
      color: var(--_disabled-icon-color);

      &::before {
        border-color: var(--_disabled-outline-color);
        opacity: var(--_disabled-outline-opacity);
      }
    }
  }

  .outlined:is(:disabled, [aria-disabled='true']) .icon {
    opacity: var(--_disabled-icon-opacity);
  }

  .outlined::before {
    block-size: 100%;
    border-style: solid;
    border-radius: inherit;
    box-sizing: border-box;
    content: '';
    inline-size: 100%;
    inset: 0;
    pointer-events: none;
    position: absolute;
    z-index: -1; // place behind content
  }

  // Selected toggle buttons have no outline.
  .outlined.selected::before {
    border-width: 0;
  }

  // Selected icon button toggle.
  .selected {
    &:not(:disabled, [aria-disabled='true']) {
      color: var(--_selected-icon-color);

      &:hover {
        color: var(--_selected-hover-icon-color);
      }

      &:focus {
        color: var(--_selected-focus-icon-color);
      }

      &:active {
        color: var(--_selected-pressed-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_selected-hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_selected-pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .selected:not(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_selected-container-color);
  }

  .selected:is(:disabled, [aria-disabled='true'])::before {
    background-color: var(--_disabled-selected-container-color);
    opacity: var(--_disabled-selected-container-opacity);
  }

  @media (forced-colors: active) {
    :host(:is([disabled], [soft-disabled])) {
      --_disabled-outline-opacity: 1;
    }

    // Selected button in HCM has an outline.
    .selected {
      &::before {
        border-color: CanvasText;
        border-width: var(--_outline-width);
      }

      &:is(:disabled, [aria-disabled='true'])::before {
        border-color: GrayText;
        opacity: 1;
      }
    }
  }
}


/* ========== /internal/_shared.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// This file contains common static styles that are shared across icon button
// variants.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../focus/focus-ring';
@use '../../icon/icon';
@use '../../tokens';
// go/keep-sorted end

@mixin styles() {
  :host {
    display: inline-flex;
    outline: none;
    -webkit-tap-highlight-color: transparent;
    height: var(--_container-height);
    width: var(--_container-width);
    justify-content: center;
  }

  :host([touch-target='wrapper']) {
    margin: max(0px, (48px - var(--_container-height)) / 2)
      max(0px, (48px - var(--_container-width)) / 2);
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape-start-start': var(--_container-shape-start-start),
        'shape-start-end': var(--_container-shape-start-end),
        'shape-end-end': var(--_container-shape-end-end),
        'shape-end-start': var(--_container-shape-end-start),
      )
    );
  }

  :host(:is([disabled], [soft-disabled])) {
    pointer-events: none;
  }

  .icon-button {
    place-items: center;
    background: none;
    border: none;
    box-sizing: border-box;
    cursor: pointer;
    display: flex;
    place-content: center;
    outline: none;
    padding: 0;
    position: relative;
    text-decoration: none;
    user-select: none;
    z-index: 0;
    flex: 1;
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-start-radius: var(--_container-shape-end-start);
    border-end-end-radius: var(--_container-shape-end-end);
  }

  .icon {
    ::slotted(*) {
      font-size: var(--_icon-size);
      height: var(--_icon-size);
      width: var(--_icon-size);
      font-weight: inherit;
    }
  }

  md-ripple {
    z-index: -1; // Place behind content
    border-start-start-radius: var(--_container-shape-start-start);
    border-start-end-radius: var(--_container-shape-start-end);
    border-end-start-radius: var(--_container-shape-end-start);
    border-end-end-radius: var(--_container-shape-end-end);
  }

  .flip-icon .icon {
    transform: scaleX(-1);
  }

  .icon {
    display: inline-flex;
  }

  .link {
    display: grid;
    height: 100%;
    outline: none;
    place-items: center;
    position: absolute;
    width: 100%;
  }

  .touch {
    position: absolute;
    height: max(48px, 100%);
    width: max(48px, 100%);
  }

  :host([touch-target='none']) .touch {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:is([disabled], [soft-disabled])) {
      --_disabled-icon-color: GrayText;
      --_disabled-icon-opacity: 1;
    }
  }
}


/* ========== /internal/filled-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filled-icon-button';
// go/keep-sorted end

@include filled-icon-button.styles;


/* ========== /internal/filled-tonal-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filled-tonal-icon-button';
// go/keep-sorted end

@include filled-tonal-icon-button.styles;


// ========== /internal/icon-button.ts ==========
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, nothing} from 'lit';
import {property, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';
import {literal, html as staticHtml} from 'lit/static-html.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {
  FormSubmitter,
  setupFormSubmitter,
  type FormSubmitterType,
} from '../../internal/controller/form-submitter.js';
import {isRtl} from '../../internal/controller/is-rtl.js';
import {
  internals,
  mixinElementInternals,
} from '../../labs/behaviors/element-internals.js';

type LinkTarget = '_blank' | '_parent' | '_self' | '_top';

// Separate variable needed for closure.
const iconButtonBaseClass = mixinDelegatesAria(
  mixinElementInternals(LitElement),
);

/**
 * A button for rendering icons.
 *
 * @fires input {InputEvent} Dispatched when a toggle button toggles --bubbles
 * --composed
 * @fires change {Event} Dispatched when a toggle button toggles --bubbles
 */
export class IconButton extends iconButtonBaseClass implements FormSubmitter {
  static {
    setupFormSubmitter(IconButton);
  }

  /** @nocollapse */
  static readonly formAssociated = true;

  /** @nocollapse */
  static override shadowRootOptions: ShadowRootInit = {
    mode: 'open',
    delegatesFocus: true,
  };

  /**
   * Disables the icon button and makes it non-interactive.
   */
  @property({type: Boolean, reflect: true}) disabled = false;

  /**
   * "Soft-disables" the icon button (disabled but still focusable).
   *
   * Use this when an icon button needs increased visibility when disabled. See
   * https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_disabled_controls
   * for more guidance on when this is needed.
   */
  @property({type: Boolean, attribute: 'soft-disabled', reflect: true})
  softDisabled = false;

  /**
   * Flips the icon if it is in an RTL context at startup.
   */
  @property({type: Boolean, attribute: 'flip-icon-in-rtl'})
  flipIconInRtl = false;

  /**
   * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
   */
  @property() href = '';

  /**
   * The filename to use when downloading the linked resource.
   * If not specified, the browser will determine a filename.
   * This is only applicable when the icon button is used as a link (`href` is set).
   */
  @property() download = '';

  /**
   * Sets the underlying `HTMLAnchorElement`'s `target` attribute.
   */
  @property() target: LinkTarget | '' = '';

  /**
   * The `aria-label` of the button when the button is toggleable and selected.
   */
  @property({attribute: 'aria-label-selected'}) ariaLabelSelected = '';

  /**
   * When true, the button will toggle between selected and unselected
   * states
   */
  @property({type: Boolean}) toggle = false;

  /**
   * Sets the selected state. When false, displays the default icon. When true,
   * displays the selected icon, or the default icon If no `slot="selected"`
   * icon is provided.
   */
  @property({type: Boolean, reflect: true}) selected = false;

  /**
   * The default behavior of the button. May be "button", "reset", or "submit"
   * (default).
   */
  @property() type: FormSubmitterType = 'submit';

  /**
   * The value added to a form with the button's name when the button submits a
   * form.
   */
  @property({reflect: true}) value = '';

  get name() {
    return this.getAttribute('name') ?? '';
  }
  set name(name: string) {
    this.setAttribute('name', name);
  }

  /**
   * The associated form element with which this element's value will submit.
   */
  get form() {
    return this[internals].form;
  }

  /**
   * The labels this element is associated with.
   */
  get labels() {
    return this[internals].labels;
  }

  @state() private flipIcon = isRtl(this, this.flipIconInRtl);

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('click', this.handleClick.bind(this));
    }
  }

  protected override willUpdate() {
    // Link buttons cannot be disabled or soft-disabled.
    if (this.href) {
      this.disabled = false;
      this.softDisabled = false;
    }
  }

  protected override render() {
    const tag = this.href ? literal`div` : literal`button`;
    // Needed for closure conformance
    const {ariaLabel, ariaHasPopup, ariaExpanded} = this as ARIAMixinStrict;
    const hasToggledAriaLabel = ariaLabel && this.ariaLabelSelected;
    const ariaPressedValue = !this.toggle ? nothing : this.selected;
    let ariaLabelValue: string | null | typeof nothing = nothing;
    if (!this.href) {
      ariaLabelValue =
        hasToggledAriaLabel && this.selected
          ? this.ariaLabelSelected
          : ariaLabel;
    }
    return staticHtml`<${tag}
        class="icon-button ${classMap(this.getRenderClasses())}"
        id="button"
        aria-label="${ariaLabelValue || nothing}"
        aria-haspopup="${(!this.href && ariaHasPopup) || nothing}"
        aria-expanded="${(!this.href && ariaExpanded) || nothing}"
        aria-pressed="${ariaPressedValue}"
        aria-disabled=${(!this.href && this.softDisabled) || nothing}
        ?disabled="${!this.href && this.disabled}"
        @click="${this.handleClickOnChild}">
        ${this.renderFocusRing()}
        ${this.renderRipple()}
        ${!this.selected ? this.renderIcon() : nothing}
        ${this.selected ? this.renderSelectedIcon() : nothing}
        ${this.href ? this.renderLink() : this.renderTouchTarget()}
  </${tag}>`;
  }

  private renderLink() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <a
        class="link"
        id="link"
        href="${this.href}"
        download="${this.download || nothing}"
        target="${this.target || nothing}"
        aria-label="${ariaLabel || nothing}">
        ${this.renderTouchTarget()}
      </a>
    `;
  }

  protected getRenderClasses() {
    return {
      'flip-icon': this.flipIcon,
      'selected': this.toggle && this.selected,
    };
  }

  private renderIcon() {
    return html`<span class="icon"><slot></slot></span>`;
  }

  private renderSelectedIcon() {
    // Use default slot as fallback to not require specifying multiple icons
    return html`<span class="icon icon--selected"
      ><slot name="selected"><slot></slot></slot
    ></span>`;
  }

  private renderTouchTarget() {
    return html`<span class="touch"></span>`;
  }

  private renderFocusRing() {
    // TODO(b/310046938): use the same id for both elements
    return html`<md-focus-ring
      part="focus-ring"
      for=${this.href ? 'link' : 'button'}></md-focus-ring>`;
  }

  private renderRipple() {
    const isRippleDisabled = !this.href && (this.disabled || this.softDisabled);
    // TODO(b/310046938): use the same id for both elements
    return html`<md-ripple
      for=${this.href ? 'link' : nothing}
      ?disabled="${isRippleDisabled}"></md-ripple>`;
  }

  override connectedCallback() {
    this.flipIcon = isRtl(this, this.flipIconInRtl);
    super.connectedCallback();
  }

  /** Handles a click on this element. */
  private handleClick(event: MouseEvent) {
    // If the icon button is soft-disabled, we need to explicitly prevent the
    // click from propagating to other event listeners as well as prevent the
    // default action.
    if (!this.href && this.softDisabled) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }

  /**
   * Handles a click on the child <div> or <button> element within this
   * element's shadow DOM.
   */
  private async handleClickOnChild(event: Event) {
    // Allow the event to propagate
    await 0;
    if (
      !this.toggle ||
      this.disabled ||
      this.softDisabled ||
      event.defaultPrevented
    ) {
      return;
    }

    this.selected = !this.selected;
    this.dispatchEvent(
      new InputEvent('input', {bubbles: true, composed: true}),
    );
    // Bubbles but does not compose to mimic native browser <input> & <select>
    // Additionally, native change event is not an InputEvent.
    this.dispatchEvent(new Event('change', {bubbles: true}));
  }
}


/* ========== /internal/outlined-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-icon-button';
// go/keep-sorted end

@include outlined-icon-button.styles;


/* ========== /internal/shared-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


/* ========== /internal/standard-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './icon-button';
// go/keep-sorted end

@include icon-button.styles;


// ========== /outlined-icon-button.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {IconButton} from './internal/icon-button.js';
import {styles} from './internal/outlined-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-icon-button': MdOutlinedIconButton;
  }
}

/**
 * @summary Icon buttons help people take supplementary actions with a single
 * tap.
 *
 * @description
 * __Emphasis:__ Low emphasis – For optional or supplementary actions with the
 * least amount of prominence.
 *
 * __Rationale:__ The most compact and unobtrusive type of button, icon buttons
 * are used for optional supplementary actions such as "Bookmark" or "Star."
 *
 * __Example usages:__
 * - Add to Favorites
 * - Print
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-icon-button')
export class MdOutlinedIconButton extends IconButton {
  static override styles: CSSResultOrNative[] = [sharedStyles, styles];

  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'outlined': true,
    };
  }
}


// ========== /outlined-icon-button_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdOutlinedIconButton} from './outlined-icon-button.js';

describe('<md-outlined-icon-button>', () => {
  describe('.styles', () => {
    createTokenTests(MdOutlinedIconButton.styles);
  });
});