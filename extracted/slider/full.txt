/* ========== /_slider.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/slider' show theme;


/* ========== /internal/_slider.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/elevation';
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();
$_md-sys-shape: tokens.md-sys-shape-values();

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-slider-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-slider-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-slider-values();

  // The max clip is reduced by 1 full tick display which is 2x the container
  // size to account for always showing the active track on the outside
  // edge of the last tick.
  $_active-track-max-clip: calc(
    100% - var(--_with-tick-marks-container-size) * 2
  );
  // When the start fraction is !0, add clipping by the tick container size
  $_start-fraction-not-zero: min(var(--_start-fraction) * 1e9, 1);
  $_active-track-start-offset: calc(
    var(--_with-tick-marks-container-size) * $_start-fraction-not-zero
  );
  $_active-track-start-clip: calc(
    $_active-track-start-offset + $_active-track-max-clip *
      var(--_start-fraction)
  );

  // When the end fraction is !1, add clipping by the tick container size
  $_end-fraction-not-one: min((1 - var(--_end-fraction)) * 1e9, 1);
  $_active-track-end-offset: calc(
    var(--_with-tick-marks-container-size) * $_end-fraction-not-one
  );
  $_active-track-end-clip: calc(
    $_active-track-end-offset + $_active-track-max-clip *
      (1 - var(--_end-fraction))
  );

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    // Set these to avoid token test failures
    --_start-fraction: 0;
    --_end-fraction: 0;
    --_tick-count: 0;

    display: inline-flex;
    vertical-align: middle;
    min-inline-size: 200px;

    @include elevation.theme(
      (
        level: var(--_handle-elevation),
        shadow-color: var(--_handle-shadow-color),
      )
    );
  }

  md-focus-ring {
    height: 48px;
    inset: unset;
    width: 48px;
  }

  md-elevation {
    transition-duration: map.get($_md-sys-motion, 'duration-medium1');
    transition-timing-function: map.get($_md-sys-motion, 'emphasized-easing');
  }

  @media (prefers-reduced-motion) {
    .label {
      transition-duration: 0;
    }
  }

  // Note, opacity for active track and handle controlled via host.
  // This avoids bleed through from the handle to the track since they overlap.
  // It also means the inactive track opacity is calc'd to compensate.
  :host([disabled]) {
    opacity: var(--_disabled-active-track-opacity);

    @include elevation.theme(
      (
        level: var(--_disabled-handle-elevation),
      )
    );
  }

  .container {
    flex: 1;
    display: flex;
    align-items: center;
    position: relative;
    block-size: var(--_state-layer-size);
    // note, only the native inputs are interactive.
    pointer-events: none;
    // ensure scrolling is prevented on mobile.
    touch-action: none;
    user-select: none;
  }

  .track,
  .tickmarks {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
  }

  // inactive-track
  .track::before,
  .tickmarks::before,
  // active-track
  .track::after,
  .tickmarks::after {
    position: absolute;
    content: '';
    // pad the track inward by half the ripple size offset by the tick container size.
    $_track-padding: calc(
      (var(--_state-layer-size) / 2) - var(--_with-tick-marks-container-size)
    );
    inset-inline-start: $_track-padding;
    inset-inline-end: $_track-padding;

    // ticks size: set here since it does not change.
    background-size: calc(
        (100% - var(--_with-tick-marks-container-size) * 2) / var(--_tick-count)
      )
      100%;
  }

  // inactive-track
  .track::before,
  .tickmarks::before {
    block-size: var(--_inactive-track-height);
    border-radius: var(--_inactive-track-shape);
  }

  .track::before {
    background: var(--_inactive-track-color);
  }

  .tickmarks::before {
    background-image: _get-tick-image(
      var(--_with-tick-marks-inactive-container-color)
    );
  }

  :host([disabled]) .track::before {
    // Note, the active track opacity is applied to the entire host,
    // so the inactive track is calc'd to compensate.
    opacity: calc(
      (1 / var(--_disabled-active-track-opacity)) *
        var(--_disabled-inactive-track-opacity)
    );
    background: var(--_disabled-inactive-track-color);
  }

  // active-track
  .track::after,
  .tickmarks::after {
    block-size: var(--_active-track-height);
    border-radius: var(--_active-track-shape);
    clip-path: inset(0 $_active-track-end-clip 0 $_active-track-start-clip);
  }

  .track::after {
    background: var(--_active-track-color);
  }

  .tickmarks::after {
    background-image: _get-tick-image(
      var(--_with-tick-marks-active-container-color)
    );
  }

  // rtl for active track clipping
  .track:dir(rtl)::after {
    clip-path: inset(0 $_active-track-start-clip 0 $_active-track-end-clip);
  }

  .tickmarks:dir(rtl)::after {
    clip-path: inset(0 $_active-track-start-clip 0 $_active-track-end-clip);
  }

  :host([disabled]) .track::after {
    background: var(--_disabled-active-track-color);
  }

  :host([disabled]) .tickmarks::before {
    background-image: _get-tick-image(
      var(--_with-tick-marks-disabled-container-color)
    );
  }

  // container for the handle that is inset with padding to be
  // track-sized so that the handle container can be positioned with % only
  // and avoid a Safari issue with not being able to transition values that
  // are calced from different units.
  // TODO remove when https://bugs.webkit.org/show_bug.cgi?id=23775 is
  // addressed.
  .handleContainerPadded {
    position: relative;
    block-size: 100%;
    inline-size: 100%;
    padding-inline: calc(var(--_state-layer-size) / 2);
  }

  .handleContainerBlock {
    position: relative;
    block-size: 100%;
    inline-size: 100%;
  }

  .handleContainer {
    position: absolute;
    inset-block-start: 0;
    inset-block-end: 0;
    inset-inline-start: calc(100% * var(--_start-fraction));
    inline-size: calc(100% * (var(--_end-fraction) - var(--_start-fraction)));
  }

  // handle
  .handle {
    position: absolute;
    block-size: var(--_state-layer-size);
    inline-size: var(--_state-layer-size);
    border-radius: var(--_handle-shape);
    display: flex;
    place-content: center;
    place-items: center;
  }

  .handleNub {
    position: absolute;
    height: var(--_handle-height);
    width: var(--_handle-width);
    border-radius: var(--_handle-shape);
    background: var(--_handle-color);
  }

  :host([disabled]) .handleNub {
    background: var(--_disabled-handle-color);
  }

  input.end:focus ~ .handleContainerPadded .handle.end > .handleNub,
  input.start:focus ~ .handleContainerPadded .handle.start > .handleNub {
    background: var(--_focus-handle-color);
  }

  // prefix classes exist to overcome specificity of focus styling.
  .container > .handleContainerPadded .handle.hover > .handleNub {
    background: var(--_hover-handle-color);
  }

  :host(:not([disabled])) {
    input.end:active ~ .handleContainerPadded .handle.end > .handleNub,
    input.start:active ~ .handleContainerPadded .handle.start > .handleNub {
      background: var(--_pressed-handle-color);
    }
  }

  .onTop.isOverlapping {
    .label,
    .label::before {
      outline: var(--_with-overlap-handle-outline-color) solid
        var(--_with-overlap-handle-outline-width);
    }

    .handleNub {
      border: var(--_with-overlap-handle-outline-color) solid
        var(--_with-overlap-handle-outline-width);
    }
  }

  .handle.start {
    inset-inline-start: calc(0px - var(--_state-layer-size) / 2);
  }
  .handle.end {
    inset-inline-end: calc(0px - var(--_state-layer-size) / 2);
  }

  // label
  .label {
    position: absolute;
    box-sizing: border-box;
    display: flex;
    padding: 4px;
    place-content: center;
    place-items: center;
    border-radius: map.get($_md-sys-shape, 'corner-full');

    color: var(--_label-text-color);
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    line-height: var(--_label-text-line-height);
    font-weight: var(--_label-text-weight);

    inset-block-end: 100%;
    min-inline-size: var(--_label-container-height);
    min-block-size: var(--_label-container-height);
    background: var(--_label-container-color);
    transition: transform map.get($_md-sys-motion, 'duration-short2')
      map.get($_md-sys-motion, 'easing-emphasized');
    transform-origin: center bottom;
    transform: scale(0);
  }

  // note, `:has` needed only for Safari; it's wrapped in a "forgiving"
  // `:where` since the syntax isn't supported yet in Firefox.
  :host(:focus-within) .label,
  .handleContainer.hover .label,
  :where(:has(input:active)) .label {
    transform: scale(1);
  }

  .label::before,
  .label::after {
    position: absolute;
    display: block;
    content: '';
    background: inherit;
  }

  // triangle below label
  .label::before {
    // Note, sizing carefully estimated to create an ice cream cone shape.
    $_triangleSize: calc(var(--_label-container-height) / 2);
    inline-size: $_triangleSize;
    block-size: $_triangleSize;
    bottom: calc(var(--_label-container-height) / -10);
    transform: rotate(45deg);
  }

  // fits inside label and occludes top half of triangle.
  .label::after {
    inset: 0px;
    border-radius: inherit;
  }

  // must stack above the label's pseudo-elements.
  .labelContent {
    z-index: 1;
  }

  // native input styling
  // note, the input is what the user interacts with so it must render and
  // be clickable, but it is visually hidden via opacity: 0 and non-clickable
  // styled ui is shown instead and positioned accordingly.
  input[type='range'] {
    opacity: 0;
    -webkit-tap-highlight-color: transparent;
    position: absolute;
    box-sizing: border-box;
    // needed for firefox
    height: 100%;
    width: 100%;
    margin: 0;
    background: transparent;
    cursor: pointer;
    pointer-events: auto;
    appearance: none;
  }

  input[type='range']:focus {
    outline: none;
  }

  ::-webkit-slider-runnable-track {
    -webkit-appearance: none;
  }

  ::-moz-range-track {
    appearance: none;
  }

  ::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    // note, this is sized to align with thumb
    block-size: var(--_handle-height);
    inline-size: var(--_handle-width);
    opacity: 0;
    z-index: 2;
  }

  @include _get-safari-knob-translate('end');
  @include _get-safari-knob-translate('start');

  ::-moz-range-thumb {
    appearance: none;
    block-size: var(--_state-layer-size);
    inline-size: var(--_state-layer-size);
    transform: scaleX(0);
    opacity: 0;
    z-index: 2;
  }

  // Clip the inputs to the space left/right of the center point between the
  // values so the right input gets pointer events.
  $_clip-to-start: calc(
    var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) *
      (
        var(--_start-fraction) +
          ((var(--_end-fraction) - var(--_start-fraction)) / 2)
      )
  );

  $_clip-to-end: calc(100% - $_clip-to-start);

  // clip left side of "start" input
  .ranged input.start {
    clip-path: inset(0 $_clip-to-end 0 0);
  }

  // in 'rtl', clip right side of "lesser" input
  .ranged input.start:dir(rtl) {
    clip-path: inset(0 0 0 $_clip-to-end);
  }

  // clip right side of "end" input
  .ranged input.end {
    clip-path: inset(0 0 0 $_clip-to-start);
  }

  // in 'rtl', clip left side of "greater" input
  .ranged input.end:dir(rtl) {
    clip-path: inset(0 $_clip-to-start 0 0);
  }

  .onTop {
    z-index: 1;
  }

  // Ripple
  .handle {
    @include ripple.theme(
      (
        hover-color: var(--_hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  md-ripple {
    border-radius: 50%;
    height: var(--_state-layer-size);
    width: var(--_state-layer-size);
  }
}

// Returns a background-image with sized circular ticks of the given color.
@function _get-tick-image($color) {
  @return radial-gradient(
    circle at var(--_with-tick-marks-container-size) center,
    #{$color} 0,
    #{$color} calc(var(--_with-tick-marks-container-size) / 2),
    transparent calc(var(--_with-tick-marks-container-size) / 2)
  );
}

// Webkit on iOS requires _some_ size on the thumb. We want to make this the
// same as --_handle-size but also be centered on the handle.
//
// the layout is similar to this:
// [()---[()===========]----]
//
// where - is the native input and the == is the material track.
// at 0 we want to shift the native knob right (padding + knob-size / 2):
// [----[(())===========]----]
//
// at the end we want to shift the native knob left by the same amount:
// [----[===========(())]----]
//
// Therefore we can do `layout-shift - 2 * `percent-fraction` * `layout-shift`
// and in RTL we want to do the the same * -1
@mixin _get-safari-knob-translate($start-or-end) {
  input.#{$start-or-end}::-webkit-slider-thumb {
    // AKA `layout-shift` in the equations above
    --_track-and-knob-padding: calc(
      (var(--_state-layer-size) - var(--_handle-width)) / 2
    );
    --_x-translate: calc(
      var(--_track-and-knob-padding) - 2 * var(--_#{$start-or-end}-fraction) *
        var(--_track-and-knob-padding)
    );
    transform: translateX(var(--_x-translate));
  }

  input.#{$start-or-end}:dir(rtl)::-webkit-slider-thumb {
    transform: translateX(calc(-1 * var(--_x-translate)));
  }
}


/* ========== /internal/forced-colors-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './slider';
// go/keep-sorted end

@media (forced-colors: active) {
  :host {
    $container-color: CanvasText; // white
    $color: Canvas; // black
    $disabled-color: GrayText;
    @include slider.theme(
      (
        active-track-color: $container-color,
        disabled-active-track-color: $disabled-color,
        disabled-active-track-opacity: 1,
        disabled-handle-color: $disabled-color,
        disabled-inactive-track-color: $disabled-color,
        disabled-inactive-track-opacity: 1,
        focus-handle-color: $container-color,
        handle-color: $container-color,
        handle-shadow-color: $color,
        hover-handle-color: $container-color,
        hover-state-layer-color: $color,
        hover-state-layer-opacity: 1,
        inactive-track-color: $color,
        label-container-color: $color,
        label-text-color: $container-color,
        pressed-handle-color: $container-color,
        pressed-state-layer-color: $color,
        pressed-state-layer-opacity: 1,
        with-overlap-handle-outline-color: $container-color,
      )
    );
  }

  .label,
  .label::before {
    border: var(--_with-overlap-handle-outline-color) solid
      var(--_with-overlap-handle-outline-width);
  }

  // inactive track
  :host(:not([disabled])) .track::before {
    border: 1px solid var(--_active-track-color);
  }

  // inactive-track
  .tickmarks::before {
    // A url must be used when forced-colors is active as it's the only value
    // that is respected. The radial-gradient is not displayed. This is a
    // stop-gap solution so ticks are displayed at all when forced-colors is
    // active.
    // Note:
    // * The SVG has no viewBox which lets the svg take its dimensions from
    //   background-size.
    // * The fill is set directly. Using currentColor does not seem to work,
    //   hence the duplication of background-image.
    // * This approach does not respect tick sizes. Instead they will always be
    //   1px wide. This is a limitation of using the url, as I'm not sure how
    //   to pass in a custom property to change the `r` attribute.
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    // stylelint-disable function-url-quotes -- SVG data URI
    // SVG is optimized for data URI (https://codepen.io/tigt/post/optimizing-svgs-in-data-uris)
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }

  // active-track
  .tickmarks::after {
    // See inactive-track documentation for background-image.
    // stylelint-disable function-url-quotes -- SVG data URI
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }

  :host([disabled]) .tickmarks::before {
    // TODO(b/298051946): Tick marks cannot be resized in HCM
    // stylelint-disable function-url-quotes -- SVG data URI
    // SVG is optimized for data URI (https://codepen.io/tigt/post/optimizing-svgs-in-data-uris)
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E");
    // stylelint-enable function-url-quotes
  }
}


/* ========== /internal/slider-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@use './slider';

@include slider.styles;


// ========== /internal/slider.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, nothing, PropertyValues} from 'lit';
import {property, query, queryAsync, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';
import {when} from 'lit/directives/when.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {
  dispatchActivationClick,
  isActivationClick,
} from '../../internal/events/form-label-activation.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';
import {mixinElementInternals} from '../../labs/behaviors/element-internals.js';
import {
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {MdRipple} from '../../ripple/ripple.js';

// Disable warning for classMap with destructuring
// tslint:disable:no-implicit-dictionary-conversion

// Separate variable needed for closure.
const sliderBaseClass = mixinDelegatesAria(
  mixinFormAssociated(mixinElementInternals(LitElement)),
);

/**
 * Slider component.
 *
 *
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 */
export class Slider extends sliderBaseClass {
  /** @nocollapse */
  static override shadowRootOptions: ShadowRootInit = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * The slider minimum value
   */
  @property({type: Number}) min = 0;

  /**
   * The slider maximum value
   */
  @property({type: Number}) max = 100;

  /**
   * The slider value displayed when range is false.
   */
  @property({type: Number}) value?: number;

  /**
   * The slider start value displayed when range is true.
   */
  @property({type: Number, attribute: 'value-start'}) valueStart?: number;

  /**
   * The slider end value displayed when range is true.
   */
  @property({type: Number, attribute: 'value-end'}) valueEnd?: number;

  /**
   * An optional label for the slider's value displayed when range is
   * false; if not set, the label is the value itself.
   */
  @property({attribute: 'value-label'}) valueLabel = '';

  /**
   * An optional label for the slider's start value displayed when
   * range is true; if not set, the label is the valueStart itself.
   */
  @property({attribute: 'value-label-start'}) valueLabelStart = '';

  /**
   * An optional label for the slider's end value displayed when
   * range is true; if not set, the label is the valueEnd itself.
   */
  @property({attribute: 'value-label-end'}) valueLabelEnd = '';

  /**
   * Aria label for the slider's start handle displayed when
   * range is true.
   */
  @property({attribute: 'aria-label-start'}) ariaLabelStart = '';

  /**
   * Aria value text for the slider's start value displayed when
   * range is true.
   */
  @property({attribute: 'aria-valuetext-start'}) ariaValueTextStart = '';

  /**
   * Aria label for the slider's end handle displayed when
   * range is true.
   */
  @property({attribute: 'aria-label-end'}) ariaLabelEnd = '';

  /**
   * Aria value text for the slider's end value displayed when
   * range is true.
   */
  @property({attribute: 'aria-valuetext-end'}) ariaValueTextEnd = '';

  /**
   * The step between values.
   */
  @property({type: Number}) step = 1;

  /**
   * Whether or not to show tick marks.
   */
  @property({type: Boolean}) ticks = false;

  /**
   * Whether or not to show a value label when activated.
   */
  @property({type: Boolean}) labeled = false;

  /**
   * Whether or not to show a value range. When false, the slider displays
   * a slideable handle for the value property; when true, it displays
   * slideable handles for the valueStart and valueEnd properties.
   */
  @property({type: Boolean}) range = false;

  /**
   * The HTML name to use in form submission for a range slider's starting
   * value. Use `name` instead if both the start and end values should use the
   * same name.
   */
  get nameStart() {
    return this.getAttribute('name-start') ?? this.name;
  }
  set nameStart(name: string) {
    this.setAttribute('name-start', name);
  }

  /**
   * The HTML name to use in form submission for a range slider's ending value.
   * Use `name` instead if both the start and end values should use the same
   * name.
   */
  get nameEnd() {
    return this.getAttribute('name-end') ?? this.nameStart;
  }
  set nameEnd(name: string) {
    this.setAttribute('name-end', name);
  }

  @query('input.start') private readonly inputStart!: HTMLInputElement | null;
  @query('.handle.start') private readonly handleStart!: HTMLDivElement | null;
  @queryAsync('md-ripple.start')
  private readonly rippleStart!: Promise<MdRipple | null>;

  @query('input.end') private readonly inputEnd!: HTMLInputElement | null;
  @query('.handle.end') private readonly handleEnd!: HTMLDivElement | null;
  @queryAsync('md-ripple.end')
  private readonly rippleEnd!: Promise<MdRipple | null>;

  // handle hover/pressed states are set manually since the handle
  // does not receive pointer events so that the native inputs are
  // interaction targets.
  @state() private handleStartHover = false;
  @state() private handleEndHover = false;

  @state() private startOnTop = false;
  @state() private handlesOverlapping = false;

  @state() private renderValueStart?: number;
  @state() private renderValueEnd?: number;

  // Note: start aria-* properties are only applied when range=true, which is
  // why they do not need to handle both cases.
  private get renderAriaLabelStart() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return (
      this.ariaLabelStart ||
      (ariaLabel && `${ariaLabel} start`) ||
      this.valueLabelStart ||
      String(this.valueStart)
    );
  }

  private get renderAriaValueTextStart() {
    return (
      this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart)
    );
  }

  // Note: end aria-* properties are applied for single and range sliders, which
  // is why it needs to handle `this.range` (while start aria-* properties do
  // not).
  private get renderAriaLabelEnd() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    if (this.range) {
      return (
        this.ariaLabelEnd ||
        (ariaLabel && `${ariaLabel} end`) ||
        this.valueLabelEnd ||
        String(this.valueEnd)
      );
    }

    return ariaLabel || this.valueLabel || String(this.value);
  }

  private get renderAriaValueTextEnd() {
    if (this.range) {
      return (
        this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd)
      );
    }

    // Needed for conformance
    const {ariaValueText} = this as ARIAMixinStrict;
    return ariaValueText || this.valueLabel || String(this.value);
  }

  // used in synthetic events generated to control ripple hover state.
  private ripplePointerId = 1;

  // flag to prevent processing of re-dispatched input event.
  private isRedispatchingEvent = false;

  private action?: Action;

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('click', (event: MouseEvent) => {
        if (!isActivationClick(event) || !this.inputEnd) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.inputEnd);
      });
    }
  }

  override focus() {
    this.inputEnd?.focus();
  }

  protected override willUpdate(changed: PropertyValues) {
    this.renderValueStart = changed.has('valueStart')
      ? this.valueStart
      : this.inputStart?.valueAsNumber;
    const endValueChanged =
      (changed.has('valueEnd') && this.range) || changed.has('value');
    this.renderValueEnd = endValueChanged
      ? this.range
        ? this.valueEnd
        : this.value
      : this.inputEnd?.valueAsNumber;
    // manually handle ripple hover state since the handle is pointer events
    // none.
    if (changed.get('handleStartHover') !== undefined) {
      this.toggleRippleHover(this.rippleStart, this.handleStartHover);
    } else if (changed.get('handleEndHover') !== undefined) {
      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);
    }
  }

  protected override updated(changed: PropertyValues) {
    // Validate input rendered value and re-render if necessary. This ensures
    // the rendred handle stays in sync with the input thumb which is used for
    // interaction. These can get out of sync if a supplied value does not
    // map to an exactly stepped value between min and max.
    if (this.range) {
      this.renderValueStart = this.inputStart!.valueAsNumber;
    }
    this.renderValueEnd = this.inputEnd!.valueAsNumber;
    // update values if they are unset
    // when using a range, default to equi-distant between
    // min - valueStart - valueEnd - max
    if (this.range) {
      const segment = (this.max - this.min) / 3;
      if (this.valueStart === undefined) {
        this.inputStart!.valueAsNumber = this.min + segment;
        // read actual value from input
        const v = this.inputStart!.valueAsNumber;
        this.valueStart = this.renderValueStart = v;
      }
      if (this.valueEnd === undefined) {
        this.inputEnd!.valueAsNumber = this.min + 2 * segment;
        // read actual value from input
        const v = this.inputEnd!.valueAsNumber;
        this.valueEnd = this.renderValueEnd = v;
      }
    } else {
      this.value ??= this.renderValueEnd;
    }
    if (
      changed.has('range') ||
      changed.has('renderValueStart') ||
      changed.has('renderValueEnd') ||
      this.isUpdatePending
    ) {
      // Only check if the handle nubs are overlapping, as the ripple touch
      // target extends subtantially beyond the boundary of the handle nub.
      const startNub = this.handleStart?.querySelector('.handleNub');
      const endNub = this.handleEnd?.querySelector('.handleNub');
      this.handlesOverlapping = isOverlapping(startNub, endNub);
    }
    // called to finish the update imediately;
    // note, this is a no-op unless an update is scheduled
    this.performUpdate();
  }

  protected override render() {
    const step = this.step === 0 ? 1 : this.step;
    const range = Math.max(this.max - this.min, step);
    const startFraction = this.range
      ? ((this.renderValueStart ?? this.min) - this.min) / range
      : 0;
    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;
    const containerStyles = {
      // for clipping inputs and active track.
      '--_start-fraction': String(startFraction),
      '--_end-fraction': String(endFraction),
      // for generating tick marks
      '--_tick-count': String(range / step),
    };
    const containerClasses = {ranged: this.range};

    // optional label values to show in place of the value.
    const labelStart = this.valueLabelStart || String(this.renderValueStart);
    const labelEnd =
      (this.range ? this.valueLabelEnd : this.valueLabel) ||
      String(this.renderValueEnd);

    const inputStartProps = {
      start: true,
      value: this.renderValueStart,
      ariaLabel: this.renderAriaLabelStart,
      ariaValueText: this.renderAriaValueTextStart,
      ariaMin: this.min,
      ariaMax: this.valueEnd ?? this.max,
    };

    const inputEndProps = {
      start: false,
      value: this.renderValueEnd,
      ariaLabel: this.renderAriaLabelEnd,
      ariaValueText: this.renderAriaValueTextEnd,
      ariaMin: this.range ? this.valueStart ?? this.min : this.min,
      ariaMax: this.max,
    };

    const handleStartProps = {
      start: true,
      hover: this.handleStartHover,
      label: labelStart,
    };

    const handleEndProps = {
      start: false,
      hover: this.handleEndHover,
      label: labelEnd,
    };

    const handleContainerClasses = {
      hover: this.handleStartHover || this.handleEndHover,
    };

    return html` <div
      class="container ${classMap(containerClasses)}"
      style=${styleMap(containerStyles)}>
      ${when(this.range, () => this.renderInput(inputStartProps))}
      ${this.renderInput(inputEndProps)} ${this.renderTrack()}
      <div class="handleContainerPadded">
        <div class="handleContainerBlock">
          <div class="handleContainer ${classMap(handleContainerClasses)}">
            ${when(this.range, () => this.renderHandle(handleStartProps))}
            ${this.renderHandle(handleEndProps)}
          </div>
        </div>
      </div>
    </div>`;
  }

  private renderTrack() {
    return html`
      <div class="track"></div>
      ${this.ticks ? html`<div class="tickmarks"></div>` : nothing}
    `;
  }

  private renderLabel(value: string) {
    return html`<div class="label" aria-hidden="true">
      <span class="labelContent" part="label">${value}</span>
    </div>`;
  }

  private renderHandle({
    start,
    hover,
    label,
  }: {
    start: boolean;
    hover: boolean;
    label: string;
  }) {
    const onTop = !this.disabled && start === this.startOnTop;
    const isOverlapping = !this.disabled && this.handlesOverlapping;
    const name = start ? 'start' : 'end';
    return html`<div
      class="handle ${classMap({
        [name]: true,
        hover,
        onTop,
        isOverlapping,
      })}">
      <md-focus-ring part="focus-ring" for=${name}></md-focus-ring>
      <md-ripple
        for=${name}
        class=${name}
        ?disabled=${this.disabled}></md-ripple>
      <div class="handleNub">
        <md-elevation part="elevation"></md-elevation>
      </div>
      ${when(this.labeled, () => this.renderLabel(label))}
    </div>`;
  }

  private renderInput({
    start,
    value,
    ariaLabel,
    ariaValueText,
    ariaMin,
    ariaMax,
  }: {
    start: boolean;
    value?: number;
    ariaLabel: string;
    ariaValueText: string;
    ariaMin: number;
    ariaMax: number;
  }) {
    // Slider requires min/max set to the overall min/max for both inputs.
    // This is reported to screen readers, which is why we need aria-valuemin
    // and aria-valuemax.
    const name = start ? `start` : `end`;
    return html`<input
      type="range"
      class="${classMap({
        start,
        end: !start,
      })}"
      @focus=${this.handleFocus}
      @pointerdown=${this.handleDown}
      @pointerup=${this.handleUp}
      @pointerenter=${this.handleEnter}
      @pointermove=${this.handleMove}
      @pointerleave=${this.handleLeave}
      @keydown=${this.handleKeydown}
      @keyup=${this.handleKeyup}
      @input=${this.handleInput}
      @change=${this.handleChange}
      id=${name}
      .disabled=${this.disabled}
      .min=${String(this.min)}
      aria-valuemin=${ariaMin}
      .max=${String(this.max)}
      aria-valuemax=${ariaMax}
      .step=${String(this.step)}
      .value=${String(value)}
      .tabIndex=${start ? 1 : 0}
      aria-label=${ariaLabel || nothing}
      aria-valuetext=${ariaValueText} />`;
  }

  private async toggleRippleHover(
    ripple: Promise<MdRipple | null>,
    hovering: boolean,
  ) {
    const rippleEl = await ripple;
    if (!rippleEl) {
      return;
    }
    // TODO(b/269799771): improve slider ripple connection
    if (hovering) {
      rippleEl.handlePointerenter(
        new PointerEvent('pointerenter', {
          isPrimary: true,
          pointerId: this.ripplePointerId,
        }),
      );
    } else {
      rippleEl.handlePointerleave(
        new PointerEvent('pointerleave', {
          isPrimary: true,
          pointerId: this.ripplePointerId,
        }),
      );
    }
  }

  private handleFocus(event: Event) {
    this.updateOnTop(event.target as HTMLInputElement);
  }

  private startAction(event: Event) {
    const target = event.target as HTMLInputElement;
    const fixed =
      target === this.inputStart ? this.inputEnd! : this.inputStart!;
    this.action = {
      canFlip: event.type === 'pointerdown',
      flipped: false,
      target,
      fixed,
      values: new Map([
        [target, target.valueAsNumber],
        [fixed, fixed?.valueAsNumber],
      ]),
    };
  }

  private finishAction(event: Event) {
    this.action = undefined;
  }

  private handleKeydown(event: KeyboardEvent) {
    this.startAction(event);
  }

  private handleKeyup(event: KeyboardEvent) {
    this.finishAction(event);
  }

  private handleDown(event: PointerEvent) {
    this.startAction(event);
    this.ripplePointerId = event.pointerId;
    const isStart = (event.target as HTMLInputElement) === this.inputStart;
    // Since handle moves to pointer on down and there may not be a move,
    // it needs to be considered hovered..
    this.handleStartHover =
      !this.disabled && isStart && Boolean(this.handleStart);
    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);
  }

  private async handleUp(event: PointerEvent) {
    if (!this.action) {
      return;
    }

    const {target, values, flipped} = this.action;
    //  Async here for Firefox because input can be after pointerup
    //  when value is calmped.
    await new Promise(requestAnimationFrame);
    if (target !== undefined) {
      // Ensure Safari focuses input so label renders.
      // Ensure any flipped input is focused so the tab order is right.
      target.focus();
      // When action is flipped, change must be fired manually since the
      // real event target did not change.
      if (flipped && target.valueAsNumber !== values.get(target)!) {
        target.dispatchEvent(new Event('change', {bubbles: true}));
      }
    }
    this.finishAction(event);
  }

  /**
   * The move handler tracks handle hovering to facilitate proper ripple
   * behavior on the slider handle. This is needed because user interaction with
   * the native input is leveraged to position the handle. Because the separate
   * displayed handle element has pointer events disabled (to allow interaction
   * with the input) and the input's handle is a pseudo-element, neither can be
   * the ripple's interactive element. Therefore the input is the ripple's
   * interactive element and has a `ripple` directive; however the ripple
   * is gated on the handle being hovered. In addition, because the ripple
   * hover state is being specially handled, it must be triggered independent
   * of the directive. This is done based on the hover state when the
   * slider is updated.
   */
  private handleMove(event: PointerEvent) {
    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);
    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);
  }

  private handleEnter(event: PointerEvent) {
    this.handleMove(event);
  }

  private handleLeave() {
    this.handleStartHover = false;
    this.handleEndHover = false;
  }

  private updateOnTop(input: HTMLInputElement) {
    this.startOnTop = input.classList.contains('start');
  }

  private needsClamping() {
    if (!this.action) {
      return false;
    }

    const {target, fixed} = this.action;
    const isStart = target === this.inputStart;
    return isStart
      ? target.valueAsNumber > fixed.valueAsNumber
      : target.valueAsNumber < fixed.valueAsNumber;
  }

  // if start/end start coincident and the first drag input would e.g. move
  // start > end, avoid clamping and "flip" to use the other input
  // as the action target.
  private isActionFlipped() {
    const {action} = this;
    if (!action) {
      return false;
    }

    const {target, fixed, values} = action;
    if (action.canFlip) {
      const coincident = values.get(target) === values.get(fixed);
      if (coincident && this.needsClamping()) {
        action.canFlip = false;
        action.flipped = true;
        action.target = fixed;
        action.fixed = target;
      }
    }
    return action.flipped;
  }

  // when flipped, apply the drag input to the flipped target and reset
  // the actual target.
  private flipAction() {
    if (!this.action) {
      return false;
    }

    const {target, fixed, values} = this.action;
    const changed = target.valueAsNumber !== fixed.valueAsNumber;
    target.valueAsNumber = fixed.valueAsNumber;
    fixed.valueAsNumber = values.get(fixed)!;
    return changed;
  }

  // clamp such that start does not move beyond end and visa versa.
  private clampAction() {
    if (!this.needsClamping() || !this.action) {
      return false;
    }
    const {target, fixed} = this.action;
    target.valueAsNumber = fixed.valueAsNumber;
    return true;
  }

  private handleInput(event: InputEvent) {
    // avoid processing a re-dispatched event
    if (this.isRedispatchingEvent) {
      return;
    }
    let stopPropagation = false;
    let redispatch = false;
    if (this.range) {
      if (this.isActionFlipped()) {
        stopPropagation = true;
        redispatch = this.flipAction();
      }
      if (this.clampAction()) {
        stopPropagation = true;
        redispatch = false;
      }
    }
    const target = event.target as HTMLInputElement;
    this.updateOnTop(target);
    // update value only on interaction
    if (this.range) {
      this.valueStart = this.inputStart!.valueAsNumber;
      this.valueEnd = this.inputEnd!.valueAsNumber;
    } else {
      this.value = this.inputEnd!.valueAsNumber;
    }
    // control external visibility of input event
    if (stopPropagation) {
      event.stopPropagation();
    }
    // ensure event path is correct when flipped.
    if (redispatch) {
      this.isRedispatchingEvent = true;
      redispatchEvent(target, event);
      this.isRedispatchingEvent = false;
    }
  }

  private handleChange(event: Event) {
    // prevent keyboard triggered changes from dispatching for
    // clamped values; note, this only occurs for keyboard
    const changeTarget = event.target as HTMLInputElement;
    const {target, values} = this.action ?? {};
    const squelch =
      target && target.valueAsNumber === values!.get(changeTarget)!;
    if (!squelch) {
      redispatchEvent(this, event);
    }
    // ensure keyboard triggered change clears action.
    this.finishAction(event);
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    if (this.range) {
      const data = new FormData();
      data.append(this.nameStart, String(this.valueStart));
      data.append(this.nameEnd, String(this.valueEnd));
      return data;
    }

    return String(this.value);
  }

  override formResetCallback() {
    if (this.range) {
      const valueStart = this.getAttribute('value-start');
      this.valueStart = valueStart !== null ? Number(valueStart) : undefined;
      const valueEnd = this.getAttribute('value-end');
      this.valueEnd = valueEnd !== null ? Number(valueEnd) : undefined;
      return;
    }
    const value = this.getAttribute('value');
    this.value = value !== null ? Number(value) : undefined;
  }

  override formStateRestoreCallback(
    state: string | Array<[string, string]> | null,
  ) {
    if (Array.isArray(state)) {
      const [[, valueStart], [, valueEnd]] = state;
      this.valueStart = Number(valueStart);
      this.valueEnd = Number(valueEnd);
      this.range = true;
      return;
    }

    this.value = Number(state);
    this.range = false;
  }
}

function inBounds({x, y}: PointerEvent, element?: HTMLElement | null) {
  if (!element) {
    return false;
  }
  const {top, left, bottom, right} = element.getBoundingClientRect();
  return x >= left && x <= right && y >= top && y <= bottom;
}

function isOverlapping(
  elA: Element | null | undefined,
  elB: Element | null | undefined,
) {
  if (!(elA && elB)) {
    return false;
  }
  const a = elA.getBoundingClientRect();
  const b = elB.getBoundingClientRect();
  return !(
    a.top > b.bottom ||
    a.right < b.left ||
    a.bottom < b.top ||
    a.left > b.right
  );
}

interface Action {
  canFlip: boolean;
  flipped: boolean;
  target: HTMLInputElement;
  fixed: HTMLInputElement;
  values: Map<HTMLInputElement | undefined, number | undefined>;
}


// ========== /slider.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {styles as forcedColorsStyles} from './internal/forced-colors-styles.js';
import {Slider} from './internal/slider.js';
import {styles} from './internal/slider-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-slider': MdSlider;
  }
}

/**
 * @summary Sliders allow users to view and select a value (or range) along
 * a track.
 *
 * @description
 * Changes made with sliders are immediate, allowing the user to make slider
 * adjustments while determining a selection. Sliders shouldnâ€™t be used to
 * adjust settings with any delay in providing user feedback. Sliders reflect
 * the current state of the settings they control.
 *
 * __Example usages:__
 * - Sliders are ideal for adjusting settings such as volume and brightness, or
 * for applying image filters.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-slider')
export class MdSlider extends Slider {
  static override styles: CSSResultOrNative[] = [styles, forcedColorsStyles];
}


// ========== /slider_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createFormTests} from '../testing/forms.js';
import {createTokenTests} from '../testing/tokens.js';

import {SliderHarness} from './harness.js';
import {MdSlider} from './slider.js';

interface SliderTestProps {
  range?: boolean;
  value?: number;
  valueStart?: number;
  valueEnd?: number;
  step?: number;
  min?: number;
  max?: number;
}

function getSliderTemplate(props?: SliderTestProps) {
  return html` <md-slider
    .range=${props?.range ?? false}
    .value=${props?.value}
    .valueStart=${props?.valueStart}
    .valueEnd=${props?.valueEnd}
    .step=${props?.step ?? 1}
    .min=${props?.min ?? 0}
    .max=${props?.max ?? 100}></md-slider>`;
}

describe('<md-slider>', () => {
  const env = new Environment();

  async function setupTest(
    props?: SliderTestProps,
    template = getSliderTemplate,
  ) {
    const root = env.render(template(props));
    await env.waitForStability();
    const slider = root.querySelector<MdSlider>('md-slider')!;
    const harness = new SliderHarness(slider);
    return {harness, root};
  }

  describe('.styles', () => {
    createTokenTests(MdSlider.styles);
  });

  describe('rendering value', () => {
    it('updates via interaction', async () => {
      const {harness} = await setupTest();
      await harness.simulateValueInteraction(1);
      expect(harness.element.value).toEqual(1);
      await harness.simulateValueInteraction(9);
      expect(harness.element.value).toEqual(9);
    });

    it('not validated when set', async () => {
      const {harness} = await setupTest();
      harness.element.value = -1000;
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(-1000);
    });

    it('validated on interaction', async () => {
      const {harness} = await setupTest();
      harness.element.value = -1000;
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(-1000);
      await harness.simulateValueInteraction(1);
      expect(harness.element.value).toEqual(1);
    });

    it('setting min validates only after interaction', async () => {
      const {harness} = await setupTest({value: 1});
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(1);
      harness.element.min = 2;
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(1);
      await harness.simulateValueInteraction(0);
      expect(harness.element.value).toEqual(2);
    });

    it('setting max validates only after interaction', async () => {
      const {harness} = await setupTest({value: 9});
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(9);
      harness.element.max = 8;
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(9);
      await harness.simulateValueInteraction(111);
      expect(harness.element.value).toEqual(8);
    });

    it('setting step validates only after interaction', async () => {
      const {harness} = await setupTest({value: 5});
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(5);
      harness.element.step = 2;
      await harness.element.updateComplete;
      expect(harness.element.value).toEqual(5);
      await harness.simulateValueInteraction(3);
      expect(harness.element.value).toEqual(4);
    });

    it('step rounds values from min', async () => {
      const props = {value: 2, min: 1, step: 5};
      const {harness} = await setupTest(props);
      expect(harness.element.value).toEqual(2);
      await harness.simulateValueInteraction(3);
      expect(harness.element.value).toEqual(1);
      await harness.simulateValueInteraction(4);
      expect(harness.element.value).toEqual(6);
    });

    it('step can be non-integer', async () => {
      const props = {value: 2, step: 0.1};
      const {harness} = await setupTest(props);
      expect(harness.element.value).toEqual(2);
      await harness.simulateValueInteraction(3.2);
      expect(harness.element.value).toEqual(3.2);
      await harness.simulateValueInteraction(70.55);
      expect(harness.element.value).toEqual(70.6);
    });
  });

  describe('rendering valueStart/valueEnd (range = true)', () => {
    it('renders inputs and handles', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      await harness.element.updateComplete;
      const inputs = harness.getInputs();
      expect(inputs[0]).not.toBeNull();
      expect(inputs[1]).not.toBeNull();
      const handles = harness.getHandles();
      expect(handles[0]).not.toBeNull();
      expect(handles[1]).not.toBeNull();
    });

    it('update via interaction', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      const [endInput, startInput] = harness.getInputs();
      await harness.simulateValueInteraction(7, endInput);
      expect(harness.element.valueStart).toEqual(2);
      expect(harness.element.valueEnd).toEqual(7);
      await harness.simulateValueInteraction(1, startInput);
      expect(harness.element.valueStart).toEqual(1);
      expect(harness.element.valueEnd).toEqual(7);
    });

    it('not validated when set', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      const testValueStart = -1000;
      const testValueEnd = -900;
      harness.element.valueStart = testValueStart;
      harness.element.valueEnd = testValueEnd;
      await harness.element.updateComplete;
      expect(harness.element.valueStart).toEqual(testValueStart);
      expect(harness.element.valueEnd).toEqual(testValueEnd);
    });

    it('validated on interaction', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      const testValueStart = -1000;
      const testValueEnd = -900;
      harness.element.valueStart = testValueStart;
      harness.element.valueEnd = testValueEnd;
      await harness.element.updateComplete;
      await harness.simulateValueInteraction(1000);
      expect(harness.element.valueStart).toEqual(harness.element.min);
      expect(harness.element.valueEnd).toEqual(harness.element.max);
    });

    it('setting min validates only after interaction', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      harness.element.min = 3;
      await harness.element.updateComplete;
      expect(harness.element.valueStart).toEqual(2);
      expect(harness.element.valueEnd).toEqual(6);
      const startInput = harness.getInputs()[1];
      await harness.simulateValueInteraction(0, startInput);
      expect(harness.element.valueStart).toEqual(3);
      expect(harness.element.valueEnd).toEqual(6);
    });

    it('setting max validates only after interaction', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      harness.element.max = 5;
      await harness.element.updateComplete;
      expect(harness.element.valueStart).toEqual(2);
      expect(harness.element.valueEnd).toEqual(6);
      await harness.simulateValueInteraction(111);
      expect(harness.element.valueStart).toEqual(2);
      expect(harness.element.valueEnd).toEqual(5);
    });

    it('setting step validates only after interaction', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      harness.element.step = 2;
      await harness.element.updateComplete;
      const [endInput, startInput] = harness.getInputs();
      await harness.simulateValueInteraction(7, endInput);
      await harness.simulateValueInteraction(5, startInput);
      expect(harness.element.valueStart).toEqual(6);
      expect(harness.element.valueEnd).toEqual(8);
    });

    it('clamps moving start > end and end < start', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      await harness.element.updateComplete;
      const [endInput, startInput] = harness.getInputs();
      await harness.simulateValueInteraction(7, startInput);
      expect(harness.element.valueStart).toEqual(6);
      await harness.simulateValueInteraction(4, startInput);
      expect(harness.element.valueStart).toEqual(4);
      await harness.simulateValueInteraction(3, endInput);
      expect(harness.element.valueEnd).toEqual(4);
    });

    it('when starting coincident, can move start > end and end < start', async () => {
      const props = {range: true, valueStart: 2, valueEnd: 6};
      const {harness} = await setupTest(props);
      await harness.element.updateComplete;
      const [endInput, startInput] = harness.getInputs();
      await harness.simulateValueInteraction(6, startInput);
      expect(harness.element.valueStart).toEqual(6);
      await harness.simulateValueInteraction(8, startInput);
      expect(harness.element.valueStart).toEqual(6);
      expect(harness.element.valueEnd).toEqual(8);
      await harness.simulateValueInteraction(8, startInput);
      expect(harness.element.valueStart).toEqual(8);
      expect(harness.element.valueEnd).toEqual(8);
      await harness.simulateValueInteraction(4, endInput);
      expect(harness.element.valueStart).toEqual(4);
      expect(harness.element.valueEnd).toEqual(8);
    });
  });

  describe('dispatches input and change events', () => {
    it('when range = false', async () => {
      const {harness} = await setupTest();
      await harness.element.updateComplete;
      const inputHandler = jasmine.createSpy('input');
      const changeHandler = jasmine.createSpy('change');
      harness.element.addEventListener('input', inputHandler);
      harness.element.addEventListener('change', changeHandler);
      await harness.simulateValueInteraction(8);
      expect(inputHandler).toHaveBeenCalledTimes(1);
      expect(changeHandler).toHaveBeenCalledTimes(1);
      await harness.simulateValueInteraction(80);
      expect(inputHandler).toHaveBeenCalledTimes(2);
      expect(changeHandler).toHaveBeenCalledTimes(2);
    });

    it('when range = true', async () => {
      const {harness} = await setupTest({range: true});
      await harness.element.updateComplete;
      const inputHandler = jasmine.createSpy('input');
      const changeHandler = jasmine.createSpy('change');
      harness.element.addEventListener('input', inputHandler);
      harness.element.addEventListener('change', changeHandler);
      const [endInput, startInput] = harness.getInputs();
      await harness.simulateValueInteraction(8, startInput);
      await harness.simulateValueInteraction(80, endInput);
      expect(inputHandler).toHaveBeenCalledTimes(2);
      expect(changeHandler).toHaveBeenCalledTimes(2);
      // input of start > end should be prevented,
      // but change to end value should occur
      await harness.simulateValueInteraction(85, startInput);
      expect(inputHandler).toHaveBeenCalledTimes(2);
      expect(changeHandler).toHaveBeenCalledTimes(3);
      // starting coincident, so input should now be ok.
      await harness.simulateValueInteraction(85, startInput);
      expect(inputHandler).toHaveBeenCalledTimes(3);
      expect(changeHandler).toHaveBeenCalledTimes(4);
      // validate same on end side
      await harness.simulateValueInteraction(40, endInput);
      expect(inputHandler).toHaveBeenCalledTimes(3);
      expect(changeHandler).toHaveBeenCalledTimes(5);
      await harness.simulateValueInteraction(40, endInput);
      expect(inputHandler).toHaveBeenCalledTimes(4);
      expect(changeHandler).toHaveBeenCalledTimes(6);
    });
  });

  describe('value label', () => {
    it('shows on focus when labeled is true', async () => {
      const {harness} = await setupTest();
      harness.element.labeled = true;
      await harness.element.updateComplete;
      harness.element.focus();
      expect(harness.isLabelShowing()).toBeTrue();
    });

    it('does now show when labeled is false', async () => {
      const {harness} = await setupTest();
      await harness.element.updateComplete;
      harness.element.focus();
      expect(harness.isLabelShowing()).toBeFalse();
    });

    it('hides after blur', async () => {
      const {harness} = await setupTest();
      harness.element.labeled = true;
      await harness.element.updateComplete;
      harness.element.focus();
      expect(harness.isLabelShowing()).toBeTrue();
      harness.element.blur();
      expect(harness.isLabelShowing()).toBeFalse();
    });

    it('shows value label on hover', async () => {
      const {harness} = await setupTest();
      harness.element.labeled = true;
      await harness.element.updateComplete;
      await harness.startHover();
      expect(harness.isLabelShowing()).toBeTrue();
      await harness.endHover();
      expect(harness.isLabelShowing()).toBeFalse();
    });
  });

  describe('focus', () => {
    it('focuses on the end input by default', async () => {
      const {harness} = await setupTest({value: 5});
      await harness.element.updateComplete;
      harness.element.focus();
      const input = harness.getInputs()[0];
      expect(input.matches(':focus')).toBe(true);
    });
  });

  describe('default values', () => {
    it('defaults value to midway between min/max', async () => {
      const {harness} = await setupTest({min: -100, max: -40});
      await harness.element.updateComplete;
      expect(harness.element.value).toBe(-70);
    });

    it('defaults valueStart/End to equidistant between min/max', async () => {
      const {harness} = await setupTest({range: true, min: 80, max: 100});
      await harness.element.updateComplete;
      expect(harness.element.valueStart).toBe(87);
      expect(harness.element.valueEnd).toBe(93);
    });
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-slider'),
      valueTests: [
        {
          name: 'unnamed',
          render: () => html`<md-slider></md-slider>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'single value',
          render: () => html`<md-slider name="slider" value="10"></md-slider>`,
          assertValue(formData) {
            expect(formData.get('slider')).toBe('10');
          },
        },
        {
          name: 'multiple values same name',
          render: () =>
            html`<md-slider
              range
              name="slider"
              value-start="0"
              value-end="10"></md-slider>`,
          assertValue(formData) {
            expect(formData.getAll('slider')).toEqual(['0', '10']);
          },
        },
        {
          name: 'multiple values different names',
          render: () =>
            html`<md-slider
              range
              name-start="slider-start"
              name-end="slider-end"
              value-start="0"
              value-end="10"></md-slider>`,
          assertValue(formData) {
            expect(formData.get('slider-start')).toBe('0');
            expect(formData.get('slider-end')).toBe('10');
          },
        },
        {
          name: 'single default value',
          render: () => html`<md-slider name="slider"></md-slider>`,
          assertValue(formData) {
            expect(formData.get('slider')).toBe('50');
          },
        },
        {
          name: 'single default value with min/max',
          render: () =>
            html`<md-slider name="slider" min="100" max="300"></md-slider>`,
          assertValue(formData) {
            expect(formData.get('slider')).toBe('200');
          },
        },
        {
          name: 'multiple default values',
          render: () => html`<md-slider range name="slider"></md-slider>`,
          assertValue(formData) {
            expect(formData.getAll('slider')).toEqual(['33', '67']);
          },
        },
        {
          name: 'multiple default values with min/max',
          render: () =>
            html`<md-slider
              range
              name="slider"
              min="100"
              max="300"></md-slider>`,
          assertValue(formData) {
            expect(formData.getAll('slider')).toEqual(['167', '233']);
          },
        },
        {
          name: 'disabled',
          render: () =>
            html`<md-slider name="slider" value="10" disabled></md-slider>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset single value',
          render: () => html`<md-slider name="slider" value="10"></md-slider>`,
          change(slider) {
            slider.value = 100;
          },
          assertReset(slider) {
            expect(slider.value)
              .withContext('slider.value after reset')
              .toBe(10);
          },
        },
        {
          name: 'reset multiple values same name',
          render: () =>
            html`<md-slider
              range
              name="slider"
              value-start="0"
              value-end="10"></md-slider>`,
          change(slider) {
            slider.valueStart = 5;
            slider.valueEnd = 5;
          },
          assertReset(slider) {
            expect(slider.valueStart)
              .withContext('slider.valueStart after reset')
              .toEqual(0);
            expect(slider.valueEnd)
              .withContext('slider.valueEnd after reset')
              .toEqual(10);
          },
        },
        {
          name: 'reset multiple values different names',
          render: () =>
            html`<md-slider
              range
              name-start="slider-start"
              name-end="slider-end"
              value-start="0"
              value-end="10"></md-slider>`,
          change(slider) {
            slider.valueStart = 5;
            slider.valueEnd = 5;
          },
          assertReset(slider) {
            expect(slider.valueStart)
              .withContext('slider.valueStart after reset')
              .toEqual(0);
            expect(slider.valueEnd)
              .withContext('slider.valueEnd after reset')
              .toEqual(10);
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore single value',
          render: () => html`<md-slider name="checkbox" value="1"></md-slider>`,
          assertRestored(slider) {
            expect(slider.value)
              .withContext('slider.value after restore')
              .toBe(1);
          },
        },
        {
          name: 'restore multiple values same name',
          render: () =>
            html`<md-slider
              range
              name="slider"
              value-start="0"
              value-end="10"></md-slider>`,
          assertRestored(slider) {
            expect(slider.valueStart)
              .withContext('slider.valueStart after restore')
              .toEqual(0);
            expect(slider.valueEnd)
              .withContext('slider.valueEnd after restore')
              .toEqual(10);
          },
        },
        {
          name: 'restore multiple values different names',
          render: () =>
            html`<md-slider
              range
              name-start="slider-start"
              name-end="slider-end"
              value-start="0"
              value-end="10"></md-slider>`,
          assertRestored(slider) {
            expect(slider.valueStart)
              .withContext('slider.valueStart after restore')
              .toEqual(0);
            expect(slider.valueEnd)
              .withContext('slider.valueEnd after restore')
              .toEqual(10);
          },
        },
      ],
    });
  });
});