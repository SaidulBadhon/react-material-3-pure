/* ========== /_list-item.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/listitem/list-item' show theme;


/* ========== /_list.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/list' show theme;


/* ========== /internal/_list.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../tokens';
@use './listitem/list-item';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-list-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-list-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-list-values();

  :host {
    background: map.get($tokens, 'container-color');
    color: unset;
    display: flex;
    flex-direction: column;
    outline: none;
    padding: 8px 0;
    // Add position so the elevation overlay (which is absolutely positioned)
    // can be positioned relative to the list root.
    position: relative;
  }
}


// ========== /internal/list-controller.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  activateFirstItem,
  activateLastItem,
  activateNextItem,
  activatePreviousItem,
  getActiveItem,
  getFirstActivatableItem,
  ListItem,
} from './list-navigation-helpers.js';

// TODO: move this file to List and make List use this

/**
 * Default keys that trigger navigation.
 */
// tslint:disable:enforce-name-casing Following Enum style
export const NavigableKeys = {
  ArrowDown: 'ArrowDown',
  ArrowLeft: 'ArrowLeft',
  ArrowUp: 'ArrowUp',
  ArrowRight: 'ArrowRight',
  Home: 'Home',
  End: 'End',
} as const;
// tslint:enable:enforce-name-casing

/**
 * Default set of navigable keys.
 */
export type NavigableKeys = (typeof NavigableKeys)[keyof typeof NavigableKeys];

/**
 * The configuration object to customize the behavior of the List Controller
 */
export interface ListControllerConfig<Item extends ListItem> {
  /**
   * A function that determines whether or not the given element is an Item
   */
  isItem: (item: HTMLElement) => item is Item;
  /**
   * A function that returns an array of elements to consider as items. For
   * example, all the slotted elements.
   */
  getPossibleItems: () => HTMLElement[];
  /**
   * A function that returns whether or not the list is in an RTL context.
   */
  isRtl: () => boolean;
  /**
   * Deactivates an item such as setting the tabindex to -1 and or sets selected
   * to false.
   */
  deactivateItem: (item: Item) => void;
  /**
   * Activates an item such as setting the tabindex to 1 and or sets selected to
   * true (but does not focus).
   */
  activateItem: (item: Item) => void;
  /**
   * Whether or not the key should be handled by the list for navigation.
   */
  isNavigableKey: (key: string) => boolean;
  /**
   * Whether or not the item can be activated. Defaults to items that are not
   * disabled.
   */
  isActivatable?: (item: Item) => boolean;
  /**
   * Whether or not navigating past the end of the list wraps to the beginning
   * and vice versa. Defaults to true.
   */
  wrapNavigation?: () => boolean;
}

/**
 * A controller that handles list keyboard navigation and item management.
 */
export class ListController<Item extends ListItem> {
  isItem: (item: HTMLElement) => item is Item;
  private readonly getPossibleItems: () => HTMLElement[];
  private readonly isRtl: () => boolean;
  private readonly deactivateItem: (item: Item) => void;
  private readonly activateItem: (item: Item) => void;
  private readonly isNavigableKey: (key: string) => boolean;
  private readonly isActivatable?: (item: Item) => boolean;
  private readonly wrapNavigation: () => boolean;

  constructor(config: ListControllerConfig<Item>) {
    const {
      isItem,
      getPossibleItems,
      isRtl,
      deactivateItem,
      activateItem,
      isNavigableKey,
      isActivatable,
      wrapNavigation,
    } = config;
    this.isItem = isItem;
    this.getPossibleItems = getPossibleItems;
    this.isRtl = isRtl;
    this.deactivateItem = deactivateItem;
    this.activateItem = activateItem;
    this.isNavigableKey = isNavigableKey;
    this.isActivatable = isActivatable;
    this.wrapNavigation = wrapNavigation ?? (() => true);
  }

  /**
   * The items being managed by the list. Additionally, attempts to see if the
   * object has a sub-item in the `.item` property.
   */
  get items(): Item[] {
    const maybeItems = this.getPossibleItems();
    const items: Item[] = [];

    for (const itemOrParent of maybeItems) {
      const isItem = this.isItem(itemOrParent);
      // if the item is a list item, add it to the list of items
      if (isItem) {
        items.push(itemOrParent);
        continue;
      }

      // If the item exposes an `item` property check if it is a list item.
      const subItem = (itemOrParent as HTMLElement & {item?: Item}).item;
      if (subItem && this.isItem(subItem)) {
        items.push(subItem);
      }
    }

    return items;
  }

  /**
   * Handles keyboard navigation. Should be bound to the node that will act as
   * the List.
   */
  handleKeydown = (event: KeyboardEvent) => {
    const key = event.key;
    if (event.defaultPrevented || !this.isNavigableKey(key)) {
      return;
    }
    // do not use this.items directly in upcoming calculations so we don't
    // re-query the DOM unnecessarily
    const items = this.items;

    if (!items.length) {
      return;
    }

    const activeItemRecord = getActiveItem(items, this.isActivatable);

    event.preventDefault();

    const isRtl = this.isRtl();
    const inlinePrevious = isRtl
      ? NavigableKeys.ArrowRight
      : NavigableKeys.ArrowLeft;
    const inlineNext = isRtl
      ? NavigableKeys.ArrowLeft
      : NavigableKeys.ArrowRight;

    let nextActiveItem: Item | null = null;
    switch (key) {
      // Activate the next item
      case NavigableKeys.ArrowDown:
      case inlineNext:
        nextActiveItem = activateNextItem(
          items,
          activeItemRecord,
          this.isActivatable,
          this.wrapNavigation(),
        );
        break;

      // Activate the previous item
      case NavigableKeys.ArrowUp:
      case inlinePrevious:
        nextActiveItem = activatePreviousItem(
          items,
          activeItemRecord,
          this.isActivatable,
          this.wrapNavigation(),
        );
        break;

      // Activate the first item
      case NavigableKeys.Home:
        nextActiveItem = activateFirstItem(items, this.isActivatable);
        break;

      // Activate the last item
      case NavigableKeys.End:
        nextActiveItem = activateLastItem(items, this.isActivatable);
        break;

      default:
        break;
    }

    if (
      nextActiveItem &&
      activeItemRecord &&
      activeItemRecord.item !== nextActiveItem
    ) {
      // If a new item was activated, remove the tabindex of the previous
      // activated item.
      activeItemRecord.item.tabIndex = -1;
    }
  };

  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem(): Item | null {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activateNextItem(
      items,
      activeItemRecord,
      this.isActivatable,
      this.wrapNavigation(),
    );
  }

  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem(): Item | null {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activatePreviousItem(
      items,
      activeItemRecord,
      this.isActivatable,
      this.wrapNavigation(),
    );
  }

  /**
   * Listener to be bound to the `deactivate-items` item event.
   */
  onDeactivateItems = () => {
    const items = this.items;

    for (const item of items) {
      this.deactivateItem(item);
    }
  };

  /**
   * Listener to be bound to the `request-activation` item event..
   */
  onRequestActivation = (event: Event) => {
    this.onDeactivateItems();
    const target = event.target as Item;
    this.activateItem(target);
    target.focus();
  };

  /**
   * Listener to be bound to the `slotchange` event for the slot that renders
   * the items.
   */
  onSlotchange = () => {
    const items = this.items;
    // Whether we have encountered an item that has been activated
    let encounteredActivated = false;

    for (const item of items) {
      const isActivated = !item.disabled && item.tabIndex > -1;

      if (isActivated && !encounteredActivated) {
        encounteredActivated = true;
        item.tabIndex = 0;
        continue;
      }

      // Deactivate the rest including disabled
      item.tabIndex = -1;
    }

    if (encounteredActivated) {
      return;
    }

    const firstActivatableItem = getFirstActivatableItem(
      items,
      this.isActivatable,
    );

    if (!firstActivatableItem) {
      return;
    }

    firstActivatableItem.tabIndex = 0;
  };
}


// ========== /internal/list-navigation-helpers.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

export interface ListItem extends HTMLElement {
  disabled: boolean;
}

/**
 * A record that describes a list item in a list with metadata such a reference
 * to the item and its index in the list.
 */
export interface ItemRecord<Item extends ListItem> {
  item: Item;
  index: number;
}

/**
 * Activates the first non-disabled item of a given array of items.
 *
 * @param items {Array<ListItem>} The items from which to activate the
 *     first item.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 */
export function activateFirstItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  // NOTE: These selector functions are static and not on the instance such
  // that multiple operations can be chained and we do not have to re-query
  // the DOM
  const firstItem = getFirstActivatableItem(items, isActivatable);
  if (firstItem) {
    firstItem.tabIndex = 0;
    firstItem.focus();
  }
  return firstItem;
}

/**
 * Activates the last non-disabled item of a given array of items.
 *
 * @param items {Array<ListItem>} The items from which to activate the
 *     last item.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @nocollapse
 */
export function activateLastItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  const lastItem = getLastActivatableItem(items, isActivatable);
  if (lastItem) {
    lastItem.tabIndex = 0;
    lastItem.focus();
  }
  return lastItem;
}

/**
 * Deactivates the currently active item of a given array of items.
 *
 * @param items {Array<ListItem>} The items from which to deactivate the
 *     active item.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @return A record of the deleselcted activated item including the item and
 *     the index of the item or `null` if none are deactivated.
 * @nocollapse
 */
export function deactivateActiveItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  const activeItem = getActiveItem(items, isActivatable);
  if (activeItem) {
    activeItem.item.tabIndex = -1;
  }
  return activeItem;
}

/**
 * Retrieves the first activated item of a given array of items.
 *
 * @param items {Array<ListItem>} The items to search.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @return A record of the first activated item including the item and the
 *     index of the item or `null` if none are activated.
 * @nocollapse
 */
export function getActiveItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item.tabIndex === 0 && isActivatable(item)) {
      return {
        item,
        index: i,
      } as ItemRecord<Item>;
    }
  }
  return null;
}

/**
 * Retrieves the first non-disabled item of a given array of items. This
 * the first item that is not disabled.
 *
 * @param items {Array<ListItem>} The items to search.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @return The first activatable item or `null` if none are activatable.
 * @nocollapse
 */
export function getFirstActivatableItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  for (const item of items) {
    if (isActivatable(item)) {
      return item;
    }
  }

  return null;
}

/**
 * Retrieves the last non-disabled item of a given array of items.
 *
 * @param items {Array<ListItem>} The items to search.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @return The last activatable item or `null` if none are activatable.
 * @nocollapse
 */
export function getLastActivatableItem<Item extends ListItem>(
  items: Item[],
  isActivatable = isItemNotDisabled<Item>,
) {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    if (isActivatable(item)) {
      return item;
    }
  }

  return null;
}

/**
 * Retrieves the next non-disabled item of a given array of items.
 *
 * @param items {Array<ListItem>} The items to search.
 * @param index {{index: number}} The index to search from.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @param wrap If true, then the next item at the end of the list is the first
 *     item. Defaults to true.
 * @return The next activatable item or `null` if none are activatable.
 */
export function getNextItem<Item extends ListItem>(
  items: Item[],
  index: number,
  isActivatable = isItemNotDisabled<Item>,
  wrap = true,
) {
  for (let i = 1; i < items.length; i++) {
    const nextIndex = (i + index) % items.length;
    if (nextIndex < index && !wrap) {
      // Return if the index loops back to the beginning and not wrapping.
      return null;
    }

    const item = items[nextIndex];
    if (isActivatable(item)) {
      return item;
    }
  }

  return items[index] ? items[index] : null;
}

/**
 * Retrieves the previous non-disabled item of a given array of items.
 *
 * @param items {Array<ListItem>} The items to search.
 * @param index {{index: number}} The index to search from.
 * @param isActivatable Function to determine if an item can be  activated.
 *     Defaults to non-disabled items.
 * @param wrap If true, then the previous item at the beginning of the list is
 *     the last item. Defaults to true.
 * @return The previous activatable item or `null` if none are activatable.
 */
export function getPrevItem<Item extends ListItem>(
  items: Item[],
  index: number,
  isActivatable = isItemNotDisabled<Item>,
  wrap = true,
) {
  for (let i = 1; i < items.length; i++) {
    const prevIndex = (index - i + items.length) % items.length;
    if (prevIndex > index && !wrap) {
      // Return if the index loops back to the end and not wrapping.
      return null;
    }

    const item = items[prevIndex];

    if (isActivatable(item)) {
      return item;
    }
  }

  return items[index] ? items[index] : null;
}

/**
 * Activates the next item and focuses it. If nothing is currently activated,
 * activates the first item.
 */
export function activateNextItem<Item extends ListItem>(
  items: Item[],
  activeItemRecord: null | ItemRecord<Item>,
  isActivatable = isItemNotDisabled<Item>,
  wrap = true,
): Item | null {
  if (activeItemRecord) {
    const next = getNextItem(
      items,
      activeItemRecord.index,
      isActivatable,
      wrap,
    );

    if (next) {
      next.tabIndex = 0;
      next.focus();
    }

    return next;
  } else {
    return activateFirstItem(items, isActivatable);
  }
}

/**
 * Activates the previous item and focuses it. If nothing is currently
 * activated, activates the last item.
 */
export function activatePreviousItem<Item extends ListItem>(
  items: Item[],
  activeItemRecord: null | ItemRecord<Item>,
  isActivatable = isItemNotDisabled<Item>,
  wrap = true,
): Item | null {
  if (activeItemRecord) {
    const prev = getPrevItem(
      items,
      activeItemRecord.index,
      isActivatable,
      wrap,
    );
    if (prev) {
      prev.tabIndex = 0;
      prev.focus();
    }
    return prev;
  } else {
    return activateLastItem(items, isActivatable);
  }
}

/**
 * Creates an event that requests the parent md-list to deactivate all other
 * items.
 */
export function createDeactivateItemsEvent() {
  return new Event('deactivate-items', {bubbles: true, composed: true});
}

/**
 * The type of the event that requests the parent md-list to deactivate all
 * other items.
 */
export type DeactivateItemsEvent = ReturnType<
  typeof createDeactivateItemsEvent
>;

/**
 * Creates an event that requests the menu to set `tabindex=0` on the item and
 * focus it. We use this pattern because List keeps track of what element is
 * active in the List by maintaining tabindex. We do not want list items
 * to set tabindex on themselves or focus themselves so that we can organize all
 * that logic in the parent List and Menus, and list item stays as dumb as
 * possible.
 */
export function createRequestActivationEvent() {
  return new Event('request-activation', {bubbles: true, composed: true});
}

/**
 * The type of the event that requests the list activates and focuses the item.
 */
export type RequestActivationEvent = ReturnType<
  typeof createRequestActivationEvent
>;

/**
 * The default `isActivatable` function, which checks if an item is not
 * disabled.
 *
 * @param item The item to check.
 * @return true if `item.disabled` is `false.
 */
function isItemNotDisabled<Item extends ListItem>(item: Item) {
  return !item.disabled;
}


/* ========== /internal/list-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './list';
// go/keep-sorted end

@include list.styles;


// ========== /internal/list.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, isServer, LitElement} from 'lit';
import {queryAssignedElements} from 'lit/decorators.js';

import {ListController, NavigableKeys} from './list-controller.js';
import {ListItem as SharedListItem} from './list-navigation-helpers.js';

const NAVIGABLE_KEY_SET = new Set<string>(Object.values(NavigableKeys));

interface ListItem extends SharedListItem {
  type: 'text' | 'button' | 'link';
}

// tslint:disable-next-line:enforce-comments-on-exported-symbols
export class List extends LitElement {
  /**
   * An array of activatable and disableable list items. Queries every assigned
   * element that has the `md-list-item` attribute.
   *
   * _NOTE:_ This is a shallow, flattened query via
   * `HTMLSlotElement.queryAssignedElements` and thus will _only_ include direct
   * children / directly slotted elements.
   */
  @queryAssignedElements({flatten: true})
  protected slotItems!: Array<ListItem | (HTMLElement & {item?: ListItem})>;

  /** @export */
  get items() {
    return this.listController.items;
  }

  private readonly listController = new ListController<ListItem>({
    isItem: (item: HTMLElement): item is ListItem =>
      item.hasAttribute('md-list-item'),
    getPossibleItems: () => this.slotItems,
    isRtl: () => getComputedStyle(this).direction === 'rtl',
    deactivateItem: (item) => {
      item.tabIndex = -1;
    },
    activateItem: (item) => {
      item.tabIndex = 0;
    },
    isNavigableKey: (key) => NAVIGABLE_KEY_SET.has(key),
    isActivatable: (item) => !item.disabled && item.type !== 'text',
  });

  private readonly internals =
    // Cast needed for closure
    (this as HTMLElement).attachInternals();

  constructor() {
    super();
    if (!isServer) {
      this.internals.role = 'list';
      this.addEventListener('keydown', this.listController.handleKeydown);
    }
  }

  protected override render() {
    return html`
      <slot
        @deactivate-items=${this.listController.onDeactivateItems}
        @request-activation=${this.listController.onRequestActivation}
        @slotchange=${this.listController.onSlotchange}>
      </slot>
    `;
  }

  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem(): ListItem | null {
    return this.listController.activateNextItem();
  }

  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem(): ListItem | null {
    return this.listController.activatePreviousItem();
  }
}


/* ========== /internal/listitem/_list-item.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../focus/focus-ring';
@use '../../../icon/icon';
@use '../../../ripple/ripple';
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-list-item-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-list-item-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-list-item-values();

  :host {
    border-radius: map.get($tokens, 'container-shape');
    display: flex;
    -webkit-tap-highlight-color: transparent;

    @include ripple.theme(
      (
        hover-color: map.get($tokens, 'hover-state-layer-color'),
        hover-opacity: map.get($tokens, 'hover-state-layer-opacity'),
        pressed-color: map.get($tokens, 'pressed-state-layer-color'),
        pressed-opacity: map.get($tokens, 'pressed-state-layer-opacity'),
      )
    );
  }

  :host(:is([type='button']:not([disabled]), [type='link'])) {
    cursor: pointer;
  }

  md-focus-ring {
    z-index: 1;

    @include focus-ring.theme(
      (
        'shape': 8px,
      )
    );
  }

  a,
  button,
  li {
    // Resets. These can be removed once we're no longer use these tags
    background: none;
    border: none;
    cursor: inherit;
    padding: 0;
    margin: 0;
    text-align: unset;
    text-decoration: none;
  }

  .list-item {
    border-radius: inherit;
    display: flex;
    flex: 1;
    max-width: inherit;
    min-width: inherit;
    outline: none;
    // hide android tap color since we have ripple
    -webkit-tap-highlight-color: transparent;
    width: 100%;
  }

  .list-item.interactive {
    cursor: pointer;
  }

  .list-item.disabled {
    opacity: map.get($tokens, 'disabled-opacity');
    pointer-events: none;
  }

  [slot='container'] {
    pointer-events: none;
  }

  md-ripple {
    border-radius: inherit;
  }

  md-item {
    border-radius: inherit;
    flex: 1;
    height: 100%;
    color: map.get($tokens, 'label-text-color');
    font-family: map.get($tokens, 'label-text-font');
    font-size: map.get($tokens, 'label-text-size');
    line-height: map.get($tokens, 'label-text-line-height');
    font-weight: map.get($tokens, 'label-text-weight');
    min-height: map.get($tokens, 'one-line-container-height');
    padding-top: map.get($tokens, 'top-space');
    padding-bottom: map.get($tokens, 'bottom-space');
    padding-inline-start: map.get($tokens, 'leading-space');
    padding-inline-end: map.get($tokens, 'trailing-space');
  }

  md-item[multiline] {
    min-height: map.get($tokens, 'two-line-container-height');
  }

  [slot='supporting-text'] {
    color: map.get($tokens, 'supporting-text-color');
    font-family: map.get($tokens, 'supporting-text-font');
    font-size: map.get($tokens, 'supporting-text-size');
    line-height: map.get($tokens, 'supporting-text-line-height');
    font-weight: map.get($tokens, 'supporting-text-weight');
  }

  [slot='trailing-supporting-text'] {
    color: map.get($tokens, 'trailing-supporting-text-color');
    font-family: map.get($tokens, 'trailing-supporting-text-font');
    font-size: map.get($tokens, 'trailing-supporting-text-size');
    line-height: map.get($tokens, 'trailing-supporting-text-line-height');
    font-weight: map.get($tokens, 'trailing-supporting-text-weight');
  }

  :is([slot='start'], [slot='end'])::slotted(*) {
    fill: currentColor;
  }

  [slot='start'] {
    color: map.get($tokens, 'leading-icon-color');
  }

  [slot='end'] {
    color: map.get($tokens, 'trailing-icon-color');
  }

  @media (forced-colors: active) {
    .disabled slot {
      color: GrayText;
    }

    .list-item.disabled {
      color: GrayText;
      opacity: 1;
    }
  }
}


/* ========== /internal/listitem/list-item-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './list-item';
// go/keep-sorted end

@include list-item.styles;


// ========== /internal/listitem/list-item.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../focus/md-focus-ring.js';
import '../../../labs/item/item.js';
import '../../../ripple/ripple.js';

import {html, LitElement, nothing, PropertyValues, TemplateResult} from 'lit';
import {property, query} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';
import {literal, html as staticHtml, StaticValue} from 'lit/static-html.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';
import {
  createRequestActivationEvent,
  ListItem,
} from '../list-navigation-helpers.js';

/**
 * Supported behaviors for a list item.
 */
export type ListItemType = 'text' | 'button' | 'link';

// Separate variable needed for closure.
const listItemBaseClass = mixinDelegatesAria(LitElement);

/**
 * @fires request-activation {Event} Requests the list to set `tabindex=0` on
 * the item and focus it. --bubbles --composed
 */
export class ListItemEl extends listItemBaseClass implements ListItem {
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Disables the item and makes it non-selectable and non-interactive.
   */
  @property({type: Boolean, reflect: true}) disabled = false;

  /**
   * Sets the behavior of the list item, defaults to "text". Change to "link" or
   * "button" for interactive items.
   */
  @property({reflect: true}) type: ListItemType = 'text';

  /**
   * READONLY. Sets the `md-list-item` attribute on the element.
   */
  @property({type: Boolean, attribute: 'md-list-item', reflect: true})
  isListItem = true;

  /**
   * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
   */
  @property() href = '';

  /**
   * Sets the underlying `HTMLAnchorElement`'s `target` attribute when `href` is
   * set.
   */
  @property() target: '_blank' | '_parent' | '_self' | '_top' | '' = '';

  @query('.list-item') protected readonly listItemRoot!: HTMLElement | null;

  private get isDisabled() {
    return this.disabled && this.type !== 'link';
  }

  protected override willUpdate(changed: PropertyValues<ListItemEl>) {
    if (this.href) {
      this.type = 'link';
    }

    super.willUpdate(changed);
  }

  protected override render() {
    return this.renderListItem(html`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }

  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  protected renderListItem(content: unknown) {
    const isAnchor = this.type === 'link';
    let tag: StaticValue;
    switch (this.type) {
      case 'link':
        tag = literal`a`;
        break;
      case 'button':
        tag = literal`button`;
        break;
      default:
      case 'text':
        tag = literal`li`;
        break;
    }

    const isInteractive = this.type !== 'text';
    // TODO(b/265339866): announce "button"/"link" inside of a list item. Until
    // then all are "listitem" roles for correct announcement.
    const target = isAnchor && !!this.target ? this.target : nothing;
    return staticHtml`
      <${tag}
        id="item"
        tabindex="${this.isDisabled || !isInteractive ? -1 : 0}"
        ?disabled=${this.isDisabled}
        role="listitem"
        aria-selected=${(this as ARIAMixinStrict).ariaSelected || nothing}
        aria-checked=${(this as ARIAMixinStrict).ariaChecked || nothing}
        aria-expanded=${(this as ARIAMixinStrict).ariaExpanded || nothing}
        aria-haspopup=${(this as ARIAMixinStrict).ariaHasPopup || nothing}
        class="list-item ${classMap(this.getRenderClasses())}"
        href=${this.href || nothing}
        target=${target}
        @focus=${this.onFocus}
      >${content}</${tag}>
    `;
  }

  /**
   * Handles rendering of the ripple element.
   */
  protected renderRipple(): TemplateResult | typeof nothing {
    if (this.type === 'text') {
      return nothing;
    }

    return html` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.isDisabled}></md-ripple>`;
  }

  /**
   * Handles rendering of the focus ring.
   */
  protected renderFocusRing(): TemplateResult | typeof nothing {
    if (this.type === 'text') {
      return nothing;
    }

    return html` <md-focus-ring
      @visibility-changed=${this.onFocusRingVisibilityChanged}
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }

  protected onFocusRingVisibilityChanged(e: Event) {}

  /**
   * Classes applied to the list item root.
   */
  protected getRenderClasses(): ClassInfo {
    return {'disabled': this.isDisabled};
  }

  /**
   * Handles rendering the headline and supporting text.
   */
  protected renderBody() {
    return html`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }

  protected onFocus() {
    if (this.tabIndex !== -1) {
      return;
    }
    // Handles the case where the user clicks on the element and then tabs.
    this.dispatchEvent(createRequestActivationEvent());
  }

  override focus() {
    // TODO(b/300334509): needed for some cases where delegatesFocus doesn't
    // work programmatically like in FF and select-option
    this.listItemRoot?.focus();
  }

  override click() {
    if (!this.listItemRoot) {
      // If the element has not finished rendering, call super to ensure click
      // events are dispatched.
      super.click();
      return;
    }

    // Forward click to the element to ensure link <a>.click() works correctly.
    this.listItemRoot.click();
  }
}


// ========== /list-item.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {ListItemEl as ListItem} from './internal/listitem/list-item.js';
import {styles} from './internal/listitem/list-item-styles.js';

export {type ListItemType} from './internal/listitem/list-item.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-list-item': MdListItem;
  }
}

/**
 * @summary
 * Lists are continuous, vertical indexes of text or images. Items are placed
 * inside the list.
 *
 * @description
 * Lists consist of one or more list items, and can contain actions represented
 * by icons and text. List items come in three sizes: one-line, two-line, and
 * three-line.
 *
 * __Takeaways:__
 *
 * - Lists should be sorted in logical ways that make content easy to scan, such
 *   as alphabetical, numerical, chronological, or by user preference.
 * - Lists present content in a way that makes it easy to identify a specific
 *   item in a collection and act on it.
 * - Lists should present icons, text, and actions in a consistent format.
 *
 * Acceptable slot child variants are:
 *
 * - `img[slot=end]`
 * - `img[slot=start]`
 *
 *  @example
 * ```html
 * <md-list-item
 *     headline="User Name"
 *     supportingText="user@name.com">
 *   <md-icon slot="start">account_circle</md-icon>
 *   <md-icon slot="end">check</md-icon>
 * </md-list-item>
 * ```
 *
 * @example
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-list-item')
export class MdListItem extends ListItem {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /list-item_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../testing/tokens.js';

import {MdListItem} from './list-item.js';

describe('<md-list-item>', () => {
  describe('.styles', () => {
    createTokenTests(MdListItem.styles);
  });
});


// ========== /list.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {List} from './internal/list.js';
import {styles} from './internal/list-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-list': MdList;
  }
}

/**
 * @summary Lists are continuous, vertical indexes of text or images.
 *
 * @description
 * Lists consist of one or more list items, and can contain actions represented
 * by icons and text. List items come in three sizes: one-line, two-line, and
 * three-line.
 *
 * __Takeaways:__
 *
 * - Lists should be sorted in logical ways that make content easy to scan, such
 *   as alphabetical, numerical, chronological, or by user preference.
 * - Lists present content in a way that makes it easy to identify a specific
 *   item in a collection and act on it.
 * - Lists should present icons, text, and actions in a consistent format.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-list')
export class MdList extends List {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /list_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)
import './list.js';
import './list-item.js';

import {html} from 'lit';

import {Environment} from '../testing/environment.js';
import {createTokenTests} from '../testing/tokens.js';

import {ListHarness, ListItemHarness} from './harness.js';
import {MdList} from './list.js';
import {MdListItem} from './list-item.js';

describe('<md-list>', () => {
  const env = new Environment();

  describe('.styles', () => {
    createTokenTests(MdList.styles);
  });

  describe('keyboard navigation', () => {
    it('non-nagivable key does nothing', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);

      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.keypress('k');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
    });

    it('ArrowDown activates the next item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);

      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowDown');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
    });

    it('ArrowRight in LTR activates the next item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);

      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowRight');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
    });

    it('ArrowLeft in RTL activates the next item', async () => {
      const root = env.render(html` <md-list dir="rtl">
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);

      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowLeft');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
    });

    it('ArrowDown will loop around', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('ArrowDown');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
    });

    it('ArrowDown will do nothing if nothing is selectable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second] = Array.from(root.querySelectorAll('md-list-item'));

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowDown');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
    });

    it('ArrowDown does not activate disabled items', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowDown');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(third);
    });

    it('ArrowDown will select itself if its the only activatable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const first = root.querySelector('md-list-item')!;

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('ArrowDown');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(first);
    });

    it('ArrowUp activates the previous item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowUp');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(first);
    });

    it('ArrowLeft in LTR activates the previous item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowLeft');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
    });

    it('ArrowRight in RTL activates the previous item', async () => {
      const root = env.render(html` <md-list dir="rtl">
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowRight');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
    });

    it('activatePreviousItem will loop around', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowUp');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(third);
    });

    it('ArrowUp will return null if nothing is selectable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second] = Array.from(root.querySelectorAll('md-list-item'));

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('ArrowUp');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
    });

    it('ArrowUp does not activate disabled items', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('ArrowUp');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(first);
    });

    it('ArrowUp will select itself if its the only activatable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const first = root.querySelector('md-list-item')!;

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('ArrowUp');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(first);
    });

    it('Home will select the first item if something is already selected', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('Home');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(first);
    });

    it('Home will select the first activatable item if first is non-activatable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('Home');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(second);
    });

    it('Home will select the first item if it is already selected', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('Home');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(first);
    });

    it('End will select the last item if something is already selected', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('End');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(third);
    });

    it('End will select the last activatable item if last is non-activatable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      await listHarness.pressHandledKey('End');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(second);
    });

    it('End will select the last item if it is already selected', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const listHarness = new ListHarness(listEl);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      await listHarness.pressHandledKey('End');
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(document.activeElement).toEqual(third);
    });

    it('Clicking on an item will activate it', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      const secondHarness = new ListItemHarness(second);

      await secondHarness.clickWithMouse();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
    });
  });

  describe('activate items methods', () => {
    it('List will activate only first item by default', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(document.body);
    });

    it('List will activate only first activatable item by default', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(document.body);
    });

    it('List will activate first activatable item if all are tabindex -1', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(document.body);
    });

    it('List will activate first activatable item if defined by user', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="2"></md-list-item>
        <md-list-item type="button" tabindex="1"></md-list-item>
      </md-list>`);
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);
      expect(document.activeElement).toEqual(document.body);
    });

    it('activateNextItem activates the next item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      const nextItem = listEl.activateNextItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(nextItem).toEqual(third);
      expect(document.activeElement).toEqual(third);
    });

    it('activateNextItem will loop around', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      const nextItem = listEl.activateNextItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(nextItem).toEqual(first);
      expect(document.activeElement).toEqual(first);
    });

    it('activateNextItem will return null if nothing is selectable', async () => {
      const root = env.render(html` <md-list> </md-list>`);
      const listEl = root.querySelector('md-list')!;

      await env.waitForStability();

      const nextItem = listEl.activateNextItem();
      await env.waitForStability();

      expect(nextItem).toBeNull();
    });

    it('activateNextItem does not activate disabled items', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      const nextItem = listEl.activateNextItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(nextItem).toEqual(third);
      expect(document.activeElement).toEqual(third);
    });

    it('activateNextItem will return itself if it is the only activatable item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const first = root.querySelector('md-list-item')!;

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);

      const nextItem = listEl.activateNextItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(nextItem).toEqual(first);
      expect(document.activeElement).toEqual(first);
    });

    it('activatePreviousItem activates the previous item', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
        <md-list-item type="button" tabindex="-1"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(0);
      expect(third.tabIndex).toEqual(-1);

      const nextItem = listEl.activatePreviousItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(nextItem).toEqual(first);
      expect(document.activeElement).toEqual(first);
    });

    it('activatePreviousItem will loop around', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);

      const nextItem = listEl.activatePreviousItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);
      expect(nextItem).toEqual(third);
      expect(document.activeElement).toEqual(third);
    });

    it('activatePreviousItem will return null if nothing is selectable', async () => {
      const root = env.render(html` <md-list> </md-list>`);
      const listEl = root.querySelector('md-list')!;

      await env.waitForStability();

      const nextItem = listEl.activatePreviousItem();
      await env.waitForStability();

      expect(nextItem).toBeNull();
      expect(document.activeElement).toEqual(document.body);
    });

    it('activatePreviousItem does not activate disabled items', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button" tabindex="-1"></md-list-item>
        <md-list-item type="button" disabled></md-list-item>
        <md-list-item type="button" tabindex="0"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const [first, second, third] = Array.from(
        root.querySelectorAll('md-list-item'),
      );

      await env.waitForStability();

      expect(first.tabIndex).toEqual(-1);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(0);

      const nextItem = listEl.activatePreviousItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(second.tabIndex).toEqual(-1);
      expect(third.tabIndex).toEqual(-1);
      expect(nextItem).toEqual(first);
      expect(document.activeElement).toEqual(first);
    });

    it('activatePreviousItem will return itself if its activatable', async () => {
      const root = env.render(html` <md-list>
        <md-list-item type="button"></md-list-item>
      </md-list>`);
      const listEl = root.querySelector('md-list')!;
      const first = root.querySelector('md-list-item')!;

      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);

      const nextItem = listEl.activatePreviousItem();
      await env.waitForStability();

      expect(first.tabIndex).toEqual(0);
      expect(nextItem).toEqual(first);
      expect(document.activeElement).toEqual(first);
    });
  });

  describe('aria', () => {
    it('Sets default role to list', async () => {
      const root = env.render(html`<md-list></md-list>`);
      const listEl = root.querySelector('md-list')!;
      await env.waitForStability();
      const internals = (
        listEl as unknown as {internals: {role: string | null}}
      ).internals;

      expect(internals.role).toEqual('list');
    });

    it('Does not override user given role attribute', async () => {
      const root = env.render(html`<md-list role="listbox"></md-list>`);
      const listEl = root.querySelector('md-list')!;
      await env.waitForStability();

      expect(listEl.getAttribute('role')).toBe('listbox');
    });

    it('Does not override user given role property', async () => {
      const root = env.render(html`<md-list .role=${'listbox'}></md-list>`);
      const listEl = root.querySelector('md-list')!;
      await env.waitForStability();

      expect(listEl.role).toBe('listbox');
    });
  });
});

describe('<md-list-item>', () => {
  const env = new Environment();

  describe('.styles', () => {
    createTokenTests(MdListItem.styles);
  });

  describe('rendering', () => {
    it('self-describes as a list-item', async () => {
      const root = env.render(html` <md-list-item> </md-list-item>`);

      const listItemEl = root.querySelector('md-list-item')!;

      await env.waitForStability();

      expect(listItemEl.hasAttribute('md-list-item')).toBeTrue();
    });
  });

  it('disabled overrides tabIndex', async () => {
    const root = env.render(html`<md-list-item type="button"></md-list-item>`);

    const listItem = root.querySelector('md-list-item')!;

    await env.waitForStability();

    const internalRoot = listItem.renderRoot.querySelector(
      '#item',
    ) as HTMLElement;

    expect(internalRoot.tabIndex).toBe(0);

    listItem.disabled = true;

    await env.waitForStability();

    expect(listItem.disabled).toBeTrue();
    expect(internalRoot.tabIndex).toBe(-1);
  });

  it('ripple and focus ring rendered on interactive', async () => {
    const root = env.render(html`<md-list-item></md-list-item>`);

    const listItem = root.querySelector('md-list-item')!;

    await env.waitForStability();

    let rippleEl = listItem.renderRoot.querySelector('md-ripple');
    let focusRingEl = listItem.renderRoot.querySelector('md-focus-ring');

    expect(rippleEl).toBeNull();
    expect(focusRingEl).toBeNull();

    listItem.type = 'button';

    await env.waitForStability();

    rippleEl = listItem.renderRoot.querySelector('md-ripple');
    focusRingEl = listItem.renderRoot.querySelector('md-focus-ring');

    expect(rippleEl).toBeTruthy();
    expect(focusRingEl).toBeTruthy();
  });
});

describe('<md-list-item> link', () => {
  const env = new Environment();

  describe('.styles', () => {
    createTokenTests(MdListItem.styles);
  });

  it('setting href renders an anchor tag', async () => {
    const root = env.render(
      html`<md-list-item href="https://google.com"></md-list-item>`,
    );

    const listItem = root.querySelector('md-list-item')!;

    await env.waitForStability();

    const internalRoot = listItem.renderRoot.querySelector(
      '#item',
    ) as HTMLElement;

    expect(internalRoot.tagName).toBe('A');
  });

  it('setting target without href renders nothing', async () => {
    const root = env.render(
      html`<md-list-item target="_blank"></md-list-item>`,
    );

    const listItem = root.querySelector('md-list-item')!;

    await env.waitForStability();

    const internalRoot = listItem.renderRoot.querySelector(
      '#item',
    ) as HTMLElement;

    expect(internalRoot.hasAttribute('target')).toBe(false);
  });
});


// ========== /test/assets.ts ==========
/** @license Googler-authored internal-only code. */

/**
 * User avatar as a dataurl.
 */
export const AVATAR_URL =
  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAAAAADH8yjkAAABsklEQVR4Ae3WBaLjMAxF0dn/np4hVEY3cQqOupNh/i4oVT76buAUEkmfzgOXgAS8QiABCUhAAg71dlsfhgJOc4vv2flpAICWGr/TS5IGQoV/qoIs0OX4r7wTBcZ40lgSqBGplgMoQ6SMxACPaF4MmCPaXAwoEa0UAyyiWTFAIZoSAwyiGTGgQLRCDJgh2kwMaBCtEQPIIpIluVnkEMkJDjuq8KSKJMd1eDLusiC70U45/ik/Se/kbqbwOzXrBrgqDtOfhJoeBrqLyLvl0nlKp2MCXi1Ap1Prndv59iQOdPVqkqu/J9FoWQcp4LguES1f7B8HaJPhStk6PASElcGN9CL0B9YKd6TWPYFjgTsrjn2ARuPudMMHdgqM1I4LtAqsVMsDyIKZJRawBLslC7BgZzlAQI8CA+gM2JmOAZy9AjPleY/pAswWZx5AFVhVxATOVIJRSfxZRAXurqA+07Qb4c5GXb99QAvc1YJ6bzSncTPtHtnJYYwbjcODV0WT40p5I3C21AUQr6iFDi8/M5HZM/OSp2O7HP+FmPGyHeD4Db5x261rfEjnewISkIAEJODDAV8A/z6x+ahJu3sAAAAASUVORK5CYII=';

/**
 * Example image as a dataurl.
 */
export const IMAGE_URL =
  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABwCAYAAADG4PRLAAAK4GlDQ1BJQ0MgUHJvZmlsZQAASImVlwdUk8kWgOf/00NCgNClhN6RTgApoYciSAdRCUkgoYSYEBDEzuIKrgoiIqCu4EpTcHUpshbEggVRbNgXRBTUdbFgQ2V/4BF295333nn3nPnnO/e/c+fee2bOuQMA2Z8lFKbBcgCkCzJFYX6etJjYOBruKcABWUAFENBnscVCRmhoEEBkdv67vL+N2CFyw2LK17///6+iwOGK2QBA8QgncsTsdIQ7kfGcLRRlAoA6iOj1sjOFU3wNYUUREiDCT6Y4eYY/TnHiNKNJ0zYRYV4I0wDAk1gsUTIAJHNET8tiJyN+SFM5WAk4fAHCeQi7sXksDsLHETZPT8+Y4hGEjRF7IQBkpDqAnvgXn8l/858o9c9iJUt5Jq9pwXvzxcI0Vs7/WZr/Lelpktk9DJFB4on8w6ZqitTvTmpGoJQFiQtDZpnPman7FPMk/pGzzBZ7xc0yh+UdKF2btjBolpP4vkypn0xmxCxzxT7hsyzKCJPulSTyYswySzS3ryQ1UqrncZlS/7m8iOhZzuJHLZxlcWp44JyNl1QvkoRJ4+cK/Dzn9vWV5p4u/ku+fKZ0bSYvwl+aO2sufq6AMedTHCONjcP19pmziZTaCzM9pXsJ00Kl9tw0P6lenBUuXZuJHM65taHSGqawAkJnGQQBP0AD/sAbhCGzHUCyz+SuyJxKxCtDmCPiJ/MyaQzktnFpTAHb0pxmY2VjA8DU3Z05Dm/Dpu8kpHxyTpexHznG75H7UjynSywFoK0AANV7czr9PQBQ8gFo7WJLRFkzOvTUBwOIgAIUgRrQAnrAGFgAG+AAXIAH8AEBIAREgFiwFLABD6QDEcgGeWAdKABFYBvYASrAXlAD6sAhcAS0gePgNDgPLoNr4Ba4DwbAMHgBxsB7MAFBEA4iQ1RIDdKGDCAzyAaiQ26QDxQEhUGxUAKUDAkgCZQHbYCKoBKoAtoH1UM/Q8eg09BFqA+6Cw1Co9Ab6DOMgkmwIqwJG8LzYTrMgAPhCHgJnAwvh3PhfHgLXA5XwwfhVvg0fBm+BQ/AL+BxFEDJoJRROigLFB3lhQpBxaGSUCLUalQhqgxVjWpCdaC6UTdQA6iXqE9oLJqKpqEt0C5of3Qkmo1ejl6N3oyuQNehW9Fn0TfQg+gx9DcMGaOBMcM4Y5iYGEwyJhtTgCnDHMC0YM5hbmGGMe+xWKwy1gjriPXHxmJTsCuxm7G7sc3YTmwfdgg7jsPh1HBmOFdcCI6Fy8QV4HbhDuJO4a7jhnEf8TJ4bbwN3hcfhxfg1+PL8A34k/jr+Gf4CYIcwYDgTAghcAg5hK2E/YQOwlXCMGGCKE80IroSI4gpxHXEcmIT8RzxAfGtjIyMroyTzCIZvsxamXKZwzIXZAZlPpEUSKYkL1I8SULaQqoldZLukt6SyWRDsgc5jpxJ3kKuJ58hPyJ/lKXKWsoyZTmya2QrZVtlr8u+ohAoBhQGZSkll1JGOUq5SnkpR5AzlPOSY8mtlquUOybXLzcuT5W3lg+RT5ffLN8gf1F+RAGnYKjgo8BRyFeoUTijMERFUfWoXlQ2dQN1P/UcdVgRq2ikyFRMUSxSPKTYqzimpKBkpxSltEKpUumE0oAyStlQmamcprxV+YjybeXPKpoqDBWuyiaVJpXrKh9U56l6qHJVC1WbVW+pflajqfmopaoVq7WpPVRHq5uqL1LPVt+jfk795TzFeS7z2PMK5x2Zd08D1jDVCNNYqVGj0aMxrqml6acp1NyleUbzpZaylodWilap1kmtUW2qtps2X7tU+5T2c5oSjUFLo5XTztLGdDR0/HUkOvt0enUmdI10I3XX6zbrPtQj6tH1kvRK9br0xvS19YP18/Qb9e8ZEAzoBjyDnQbdBh8MjQyjDTcathmOGKkaMY1yjRqNHhiTjd2NlxtXG980wZrQTVJNdptcM4VN7U15ppWmV81gMwczvtlusz5zjLmTucC82rzfgmTBsMiyaLQYtFS2DLJcb9lm+Wq+/vy4+cXzu+d/s7K3SrPab3XfWsE6wHq9dYf1GxtTG7ZNpc1NW7Ktr+0a23bb13Zmdly7PXZ37Kn2wfYb7bvsvzo4OogcmhxGHfUdExyrHPvpivRQ+mb6BSeMk6fTGqfjTp+cHZwznY84/+Fi4ZLq0uAyssBoAXfB/gVDrrquLNd9rgNuNLcEtx/dBtx13Fnu1e6PPfQ8OB4HPJ4xTBgpjIOMV55WniLPFs8PXs5eq7w6vVHeft6F3r0+Cj6RPhU+j3x1fZN9G33H/Oz9Vvp1+mP8A/2L/fuZmkw2s545FuAYsCrgbCApMDywIvBxkGmQKKgjGA4OCN4e/GChwULBwrYQEMIM2R7yMNQodHnor4uwi0IXVS56GmYdlhfWHU4NXxbeEP4+wjNia8T9SONISWRXFCUqPqo+6kO0d3RJ9EDM/JhVMZdj1WP5se1xuLiouANx44t9Fu9YPBxvH18Qf3uJ0ZIVSy4uVV+atvTEMsoy1rKjCZiE6ISGhC+sEFY1azyRmViVOMb2Yu9kv+B4cEo5o1xXbgn3WZJrUknSSLJr8vbkUZ47r4z3ku/Fr+C/TvFP2ZvyITUktTZ1Mi06rTkdn56QfkygIEgVnM3QyliR0Sc0ExYIB5Y7L9+xfEwUKDoghsRLxO2ZikiT1CMxlnwnGcxyy6rM+pgdlX10hfwKwYqeHNOcTTnPcn1zf1qJXsle2ZWnk7cub3AVY9W+1dDqxNVda/TW5K8ZXuu3tm4dcV3quivrrdaXrH+3IXpDR75m/tr8oe/8vmsskC0QFfRvdNm493v09/zvezfZbtq16Vshp/BSkVVRWdGXzezNl36w/qH8h8ktSVt6tzps3bMNu02w7Xaxe3FdiXxJbsnQ9uDtraW00sLSdzuW7bhYZle2dydxp2TnQHlQefsu/V3bdn2p4FXcqvSsbK7SqNpU9WE3Z/f1PR57mvZq7i3a+/lH/o939vnta602rC6rwdZk1TzdH7W/+yf6T/UH1A8UHfhaK6gdqAurO1vvWF/foNGwtRFulDSOHow/eO2Q96H2Joumfc3KzUWHwWHJ4ec/J/x8+0jgka6j9KNNvxj8UtVCbSlshVpzWsfaeG0D7bHtfccCjnV1uHS0/Gr5a+1xneOVJ5RObD1JPJl/cvJU7qnxTmHny9PJp4e6lnXdPxNz5ubZRWd7zwWeu3De9/yZbkb3qQuuF45fdL547BL9Uttlh8utPfY9LVfsr7T0OvS2XnW82n7N6VpH34K+k9fdr5++4X3j/E3mzcu3Ft7qux15+05/fP/AHc6dkbtpd1/fy7o3cX/tA8yDwodyD8seaTyq/s3kt+YBh4ETg96DPY/DH98fYg+9eCJ+8mU4/yn5adkz7Wf1IzYjx0d9R689X/x8+IXwxcTLgt/lf696Zfzqlz88/ugZixkbfi16Pflm81u1t7Xv7N51jYeOP3qf/n7iQ+FHtY91n+ifuj9Hf342kf0F96X8q8nXjm+B3x5Mpk9OClki1nQrgEIGnJQEwJtapDeOBYCK9OXExTO99bRAM++BaQL/iWf672lxAKCmH4CIlQAEXQFgVwXSziL+KcibIJSC6F0AbGsrHf8ScZKtzYwvkjvSmjycnHxrDACuGICvxZOTEzWTk19rkGDvA9CZM9PTT4kW8r7IxgH8xif38ne/Av+QmX7/Lzn+cwZTEdiBf85/AsPlG21SePNzAAAAXGVYSWZNTQAqAAAACAAEAQYAAwAAAAEAAgAAARIAAwAAAAEAAQAAASgAAwAAAAEAAgAAh2kABAAAAAEAAAA+AAAAAAACoAIABAAAAAEAAABwoAMABAAAAAEAAABwAAAAAAzs/hgAAAK2aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA2LjAuMCI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+MTEyPC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjExMjwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgqSz/U6AAAH10lEQVR4Ae2d+0/bSBDHJ0+SAAmEV4uOQum1V+lOp7v74f7/P+GkU6WWKyWEvENCQkLeCTdft0EgIDj22t61dyWUYK93x/PxrHd3Zjehk6+5W9JJVQ3MwqpKruX+rgENUPEnQQPUABXXgOLiawvUABXXgOLiawvUABXXgOLiawvUABXXgOLiawvUABXXgOLiawvUABXXgOLiawvUABXXgOLiawvUABXXgOLiRxWX/0nxOzc9+nLyH4XDYfrz998oFAo9mc8PB33XhN7e3lK5UqHuzQ1ddzpUu7wkHPNr8h3Aq1abavXGHa98oUjD4ejuf7998RXA6XRKF8UiTSbjO0433JyWq1XfWqGvAJarNWq1O3fw5l9KlSq1rx8fn59X+dM3AEejERVLZba02SMe4/GYCnxuOn187lFmxQ74BmChVKL+YPCs+lttvBvrz55X9YQvAHa4t1mq1BYymEwmVK7VCNbop6Q8QDSL+UKJOy6TF7l0Ol0qlisv5lMpg/IA640GXTabpnSO8SB6qYuaWlMFSZRJaYAY3xWKpaWGCLDYs/M8zWb+6NAoDbBYLhszLssaRLN5RVfcqfFDUhZgr9c3hgZWIEx4wJ9jKzTz3rRSvpvXKAkQzR/eZXaawU73hqo+GFYoCbDVvubpscXDBjNWkDu/oMGCsaOZMrzOoxzAwWBIufyFEL2NeegBS1bZW6EUQCga7qFOtysEIAopV+vsdhJXnjDBTBakFMBef0DVWl2oxRjvU3Y5qTpPqhTAfKFAN72eyWfTfDZMBNTZslVMygBsXrWo0TA342IFBLwVKnZolACId18uz+M2Hr85lRCCUeJQjNlMrfALJQAiTMKNjobRoemq5fiVHiDcP99y504Z3oNyUVfJcAqrY4VSA/zuPShZmu98QGaJfy55nrQiYJJgiSptZZUaIGZcMO5zM2FYkefBPQKkVEjSAkRnAp0KzLy4nfo83qzweFOFDo20AOGohQV6lS6MeFL3H55l71dKgGjGihyk5GX8ymA45PCLsi2Px7IwrOSXEiAmq+Hu8TpVOAiqfe1dK2Dm/qUDCKuDq0gGD8FkMuWAqSK3BC8HTJlRthN5pAOICWuZPOUjhjedygtQuuVl6fU1+vXjL9JAjK/EaWVlxQnjEVKmdACxlm97Kyvk5oJQiHRNaBCULvIeNUCR2vSgLA3QA6WLrFIDFKlND8rSAD1QusgqNUCR2vSgLA3QA6WLrFIDFKlND8rSAD1QusgqpZuJEXlzIsvC5PqQN1KAg3k8Ht0FAkeiEYrHYpTg6bZ4PO76rlAa4ALKgNbv96nO8agNjpXByt4Zh1rM+PjcWxIKhRkaUSQcoUQiTq/39mgjk6FkMuEKTGEA4XJxc9Y+EolSLCZM/AcYAQeWhoUvlwxvtGBjBGxrwtkNx++4O2Y/5jdKJZPGfO7+qz2GmnhQtuh/QicCfj8QPrx//v3kSNj7czecSqXo77/+eO605eOA0eBQ+5PTb4S9Z+wkyHh8eMAwt+wUs+haMb8fiIUhTqxZWCR5z4E1EnDgnuZy9OnzF9vwIDtk/PT5hE7Pco4FSDnTBi3SvKTnAA8BxAijmL/fRIiKsrC1CdxkR2/e8BaYYre+1MMIpgQl5y4uDHh2lm0/BxxlYvHMOdch8uFAfRogK+GSQxirHIfjBLw5VJRdYku8arXmh4R8Bh4g3t+nZ+eE5dZOJ9SBukQ+KIEGiB4nmjXEgLqV0NlDpJuopjTQAAfDgetrL/CgYHsTu0OU+QMXaIBYd+jV2ov2tZiNFQILEAtXMMviVWpdt4U0o4EFiH21vVwTj0G+iI5TYAEi4nrRHKfTltmHV2Nkf/PZwAKcztirwGMzrxLmj0UsIg0swFuG5yVA1D17YoP2ZR+owAJcVlGy5g8sQPyuEv68SrFolCKRiO3qvbsD26LbKyDGYRBRAQq0KkWEAYp4gIILMBrjZWNxq/q3fV0iwTE0Mfv1BxZglIOR1tfWbIOwWkCa64YMdlNgAUJxCHXw6rcFs5sbQuoONMBMep3W1lbtGsHS129ns8KsP9AA0Qs82N9fGoDdC37afy2kBwo5Ag0QCsBy7s0NMc0ZynspbWU3KZNJv5TN9PnAA0RX/t3RoSs9UgT7vj9+K+TdNycceIBQBN6DRwcH3Ct0LkgPY87jw0Phgb4a4I9H+dXeLn14d+zI4B7wPn54Tzvb4gN8nXvk5jbu0KcT3f/dnW2W9pbOeKsv7FgoIiVTSfr48zvKpMW99+7LJQRgJBKmvd0dV/cVy6yv378PYd93tncovZ6mk6+nxg9kWQ0+wrqN7MYmHXFofdLB9RFC1kYI055EBQEcYjhz+YLxe/RmRUPLkN3cpP1Xu8anEy3FPVlmQizwXoG++ToHgSEG9m9rXjWNjdcRFoiIMoTiI2E6LLGSoNXVFA/OV2k7u8UdFfe25tIAX3jkAHKV32Op5L7hAP7uiOX1gT+8+VgfiPUOYe6ohDmvwxb3SFoN8JFKnj4AMJi5EeHDe7oGa0f1MMKa3qS5SgOUBoU1QTRAa3qT5ioNUBoU1gTRAK3pTZqrNEBpUFgTRAO0pjdprtIApUFhTRAN0JrepLlKA5QGhTVBNEBrepPmKg1QGhTWBNEArelNmqs0QGlQWBNEA7SmN2mugj/Qu3XGzqhB7G5yzsgorNT/AQI1K7I2zvkPAAAAAElFTkSuQmCC';

/**
 * One frame of the color blue in webm as a dataurl.
 *
 * Generated with
 * ffmpeg -f lavfi -i color=blue:s=1280x720 -vframes 1 ~/out.webm
 * cat ~/out.webm | base64 | tr -d '\n'
 */
export const VIDEO_URL =
  'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAJrEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHYTbuMU6uEElTDZ1OsggEgTbuMU6uEHFO7a1OsggJV7AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmsirXsYMPQkBNgI1MYXZmNTkuMjcuMTAwV0GNTGF2ZjU5LjI3LjEwMESJiEBEAAAAAAAAFlSua8OuAQAAAAAAADrXgQFzxYjFaDr5zFhASZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDgi7CCBQC6ggLQmoECElTDZ0CBc3OgY8CAZ8iaRaOHRU5DT0RFUkSHjUxhdmY1OS4yNy4xMDBzc9tjwItjxYjFaDr5zFhASWfIpUWjh0VOQ09ERVJEh5hMYXZjNTkuMzcuMTAwIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dUCo54EAo0CigQAAgIJJg0IAT/As9gA4JBwYShgAQGIMw/o6+kdo6+kAuaP9KgAAAAAcZw5Vl/m2cRY6ymCqlMFVJYKqSwVSleqUBBBCAAAAABxnDlWX+bZxFjrKYKqUwVUlgqpLBVKV6pQEEEIAAAAAHGcOVZf5tnEWOspgqpTBVSWCqksFUpXqlAQQQgBnDlWX+bZxFjrKYKqUwVUlgqpLBVKV6pQEEEIAHFO7a5G7j7OBALeK94EB8YIBp/CBAw==';