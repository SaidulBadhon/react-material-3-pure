/* ========== /badge/_badge.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/badge' show theme;


// ========== /badge/badge.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Badge} from './internal/badge.js';
import {styles} from './internal/badge-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-badge': MdBadge;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-badge')
export class MdBadge extends Badge {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /badge/badge_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../../testing/tokens.js';

import {MdBadge} from './badge.js';

describe('<md-badge>', () => {
  describe('.styles', () => {
    createTokenTests(MdBadge.styles);
  });
});


/* ========== /badge/internal/_badge.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  // $supported-tokens: tokens.$md-comp-badge-supported-tokens;

  @each $token, $value in $tokens {
    // @if list.index($supported-tokens, $token) == null {
    //   @error 'Token `#{$token}` is not a supported token.';
    // }

    @if $value {
      --md-badge-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-badge-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .md3-badge {
    inset-inline-start: 50%;
    margin-inline-start: 6px;
    margin-block-start: 4px;
    position: absolute;
    inset-block-start: 0px;
    background-color: var(--_color);
    border-radius: var(--_shape);
    height: var(--_size);

    &:not(.md3-badge--large) {
      // Separate selector since large uses min-width
      width: var(--_size);
    }

    &.md3-badge--large {
      display: flex;
      flex-direction: column;
      justify-content: center;
      margin-inline-start: 2px;
      margin-block-start: 1px;
      background-color: var(--_large-color);
      border-radius: var(--_large-shape);
      height: var(--_large-size);
      min-width: var(--_large-size);
      color: var(--_large-label-text-color);

      .md3-badge__value {
        padding: 0px 4px;
        text-align: center;
      }
    }
  }

  .md3-badge__value {
    font-family: var(--_large-label-text-font);
    font-size: var(--_large-label-text-size);
    line-height: var(--_large-label-text-line-height);
    font-weight: var(--_large-label-text-weight);
  }
}


/* ========== /badge/internal/badge-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './badge';
// go/keep-sorted end

@include badge.styles;


// ========== /badge/internal/badge.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, LitElement} from 'lit';
import {property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

/**
 * b/265340196 - add docs
 */
export class Badge extends LitElement {
  @property() value = '';

  protected override render() {
    const classes = {'md3-badge--large': this.value};

    return html`<div class="md3-badge ${classMap(classes)}">
      <p class="md3-badge__value">${this.value}</p>
    </div>`;
  }
}


// ========== /behaviors/constraint-validation.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {isServer, LitElement, PropertyDeclaration, PropertyValues} from 'lit';

import {internals, WithElementInternals} from './element-internals.js';
import {FormAssociated} from './form-associated.js';
import {MixinBase, MixinReturn} from './mixin.js';
import {Validator} from './validators/validator.js';

/**
 * A form associated element that provides constraint validation APIs.
 *
 * https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation
 */
export interface ConstraintValidation extends FormAssociated {
  /**
   * Returns a ValidityState object that represents the validity states of the
   * element.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/ValidityState
   */
  readonly validity: ValidityState;

  /**
   * Returns a validation error message or an empty string if the element is
   * valid.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/validationMessage
   */
  readonly validationMessage: string;

  /**
   * Returns whether an element will successfully validate based on forms
   * validation rules and constraints.
   *
   * Disabled and readonly elements will not validate.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/willValidate
   */
  readonly willValidate: boolean;

  /**
   * Checks the element's constraint validation and returns true if the element
   * is valid or false if not.
   *
   * If invalid, this method will dispatch an `invalid` event.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/checkValidity
   *
   * @return true if the element is valid, or false if not.
   */
  checkValidity(): boolean;

  /**
   * Checks the element's constraint validation and returns true if the element
   * is valid or false if not.
   *
   * If invalid, this method will dispatch a cancelable `invalid` event. If not
   * canceled, a the current `validationMessage` will be reported to the user.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals/reportValidity
   *
   * @return true if the element is valid, or false if not.
   */
  reportValidity(): boolean;

  /**
   * Sets the element's constraint validation error message. When set to a
   * non-empty string, `validity.customError` will be true and
   * `validationMessage` will display the provided error.
   *
   * Use this method to customize error messages reported.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setCustomValidity
   *
   * @param error The error message to display, or an empty string.
   */
  setCustomValidity(error: string): void;

  /**
   * Creates and returns a `Validator` that is used to compute and cache
   * validity for the element.
   *
   * A validator that caches validity is important since constraint validation
   * must be computed synchronously and frequently in response to constraint
   * validation property changes.
   */
  [createValidator](): Validator<unknown>;

  /**
   * Returns shadow DOM child that is used as the anchor for the platform
   * `reportValidity()` popup. This is often the root element or the inner
   * focus-delegated element.
   */
  [getValidityAnchor](): HTMLElement | null;
}

/**
 * A symbol property used to create a constraint validation `Validator`.
 * Required for all `mixinConstraintValidation()` elements.
 */
export const createValidator = Symbol('createValidator');

/**
 * A symbol property used to return an anchor for constraint validation popups.
 * Required for all `mixinConstraintValidation()` elements.
 */
export const getValidityAnchor = Symbol('getValidityAnchor');

// Private symbol members, used to avoid name clashing.
const privateValidator = Symbol('privateValidator');
const privateSyncValidity = Symbol('privateSyncValidity');
const privateCustomValidationMessage = Symbol('privateCustomValidationMessage');

/**
 * Mixes in constraint validation APIs for an element.
 *
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation
 * for more details.
 *
 * Implementations must provide a validator to cache and compute its validity,
 * along with a shadow root element to anchor validation popups to.
 *
 * @example
 * ```ts
 * const baseClass = mixinConstraintValidation(
 *   mixinFormAssociated(mixinElementInternals(LitElement))
 * );
 *
 * class MyCheckbox extends baseClass {
 *   \@property({type: Boolean}) checked = false;
 *   \@property({type: Boolean}) required = false;
 *
 *   [createValidator]() {
 *     return new CheckboxValidator(() => this);
 *   }
 *
 *   [getValidityAnchor]() {
 *     return this.renderRoot.querySelector('.root');
 *   }
 * }
 * ```
 *
 * @param base The class to mix functionality into.
 * @return The provided class with `ConstraintValidation` mixed in.
 */
export function mixinConstraintValidation<
  T extends MixinBase<LitElement & FormAssociated & WithElementInternals>,
>(base: T): MixinReturn<T, ConstraintValidation> {
  abstract class ConstraintValidationElement
    extends base
    implements ConstraintValidation
  {
    get validity() {
      this[privateSyncValidity]();
      return this[internals].validity;
    }

    get validationMessage() {
      this[privateSyncValidity]();
      return this[internals].validationMessage;
    }

    get willValidate() {
      this[privateSyncValidity]();
      return this[internals].willValidate;
    }

    /**
     * A validator instance created from `[createValidator]()`.
     */
    [privateValidator]?: Validator<unknown>;

    /**
     * Needed for Safari, see https://bugs.webkit.org/show_bug.cgi?id=261432
     * Replace with this[internals].validity.customError when resolved.
     */
    [privateCustomValidationMessage] = '';

    checkValidity() {
      this[privateSyncValidity]();
      return this[internals].checkValidity();
    }

    reportValidity() {
      this[privateSyncValidity]();
      return this[internals].reportValidity();
    }

    setCustomValidity(error: string) {
      this[privateCustomValidationMessage] = error;
      this[privateSyncValidity]();
    }

    override requestUpdate(
      name?: PropertyKey,
      oldValue?: unknown,
      options?: PropertyDeclaration,
    ) {
      super.requestUpdate(name, oldValue, options);
      this[privateSyncValidity]();
    }

    override firstUpdated(changed: PropertyValues) {
      super.firstUpdated(changed);
      // Sync the validity again when the element first renders, since the
      // validity anchor is now available.
      //
      // Elements that `delegatesFocus: true` to an `<input>` will throw an
      // error in Chrome and Safari when a form tries to submit or call
      // `form.reportValidity()`:
      // "An invalid form control with name='' is not focusable"
      //
      // The validity anchor MUST be provided in `internals.setValidity()` and
      // MUST be the `<input>` element rendered.
      //
      // See https://lit.dev/playground/#gist=6c26e418e0010f7a5aac15005cde8bde
      // for a reproduction.
      this[privateSyncValidity]();
    }

    [privateSyncValidity]() {
      if (isServer) {
        return;
      }

      if (!this[privateValidator]) {
        this[privateValidator] = this[createValidator]();
      }

      const {validity, validationMessage: nonCustomValidationMessage} =
        this[privateValidator].getValidity();

      const customError = !!this[privateCustomValidationMessage];
      const validationMessage =
        this[privateCustomValidationMessage] || nonCustomValidationMessage;

      this[internals].setValidity(
        {...validity, customError},
        validationMessage,
        this[getValidityAnchor]() ?? undefined,
      );
    }

    [createValidator](): Validator<unknown> {
      throw new Error('Implement [createValidator]');
    }

    [getValidityAnchor](): HTMLElement | null {
      throw new Error('Implement [getValidityAnchor]');
    }
  }

  return ConstraintValidationElement;
}


// ========== /behaviors/constraint-validation_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from './constraint-validation.js';
import {mixinElementInternals} from './element-internals.js';
import {getFormValue, mixinFormAssociated} from './form-associated.js';
import {CheckboxValidator} from './validators/checkbox-validator.js';

describe('mixinConstraintValidation()', () => {
  const baseClass = mixinConstraintValidation(
    mixinFormAssociated(mixinElementInternals(LitElement)),
  );

  @customElement('test-constraint-validation')
  class TestConstraintValidation extends baseClass {
    @property({type: Boolean}) checked = false;
    @property({type: Boolean}) required = false;

    override render() {
      return html`<div id="root"></div>`;
    }

    override [createValidator]() {
      return new CheckboxValidator(() => this);
    }

    override [getValidityAnchor]() {
      return this.shadowRoot?.querySelector<HTMLElement>('#root') ?? null;
    }

    override [getFormValue]() {
      return String(this.checked);
    }
  }

  describe('validity', () => {
    it('should return a ValidityState value', () => {
      const control = new TestConstraintValidation();
      expect(control.validity).toBeInstanceOf(ValidityState);
    });

    it('should update synchronously when validation properties change', () => {
      const control = new TestConstraintValidation();

      expect(control.validity.valid)
        .withContext('validity.valid before changing required')
        .toBeTrue();
      control.required = true;
      expect(control.validity.valid)
        .withContext('validity.valid after changing required')
        .toBeFalse();
    });
  });

  describe('validationMessage', () => {
    it('should be an empty string when valid', () => {
      const control = new TestConstraintValidation();
      expect(control.validationMessage).toBe('');
    });

    it('should have an error message when invalid', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      expect(control.validationMessage).not.toBe('');
    });
  });

  describe('willValidate', () => {
    it('should validate by default', () => {
      const control = new TestConstraintValidation();
      expect(control.willValidate).withContext('willValidate').toBeTrue();
    });

    it('should not validate when a disabled attribute is present', () => {
      const control = new TestConstraintValidation();
      control.toggleAttribute('disabled', true);
      expect(control.willValidate).withContext('willValidate').toBeFalse();
    });

    it('should not validate when a readonly attribute is present', () => {
      const control = new TestConstraintValidation();
      control.toggleAttribute('readonly', true);
      expect(control.willValidate).withContext('willValidate').toBeFalse();
    });
  });

  describe('checkValidity()', () => {
    it('should return true when element is valid', () => {
      const control = new TestConstraintValidation();
      expect(control.checkValidity())
        .withContext('checkValidity() return')
        .toBeTrue();
    });

    it('should return false when element is invalid', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      expect(control.checkValidity())
        .withContext('checkValidity() return')
        .toBeFalse();
    });

    it('should dispatch invalid event when invalid', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      const invalidListener = jasmine.createSpy('invalidListener');
      control.addEventListener('invalid', invalidListener);
      control.checkValidity();
      expect(invalidListener).toHaveBeenCalledWith(jasmine.any(Event));
    });
  });

  describe('reportValidity()', () => {
    it('should return true when element is valid', () => {
      const control = new TestConstraintValidation();
      expect(control.reportValidity())
        .withContext('reportValidity() return')
        .toBeTrue();
    });

    it('should return false when element is invalid', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      expect(control.reportValidity())
        .withContext('reportValidity() return')
        .toBeFalse();
    });

    it('should dispatch invalid event when invalid', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      const invalidListener = jasmine.createSpy('invalidListener');
      control.addEventListener('invalid', invalidListener);
      control.reportValidity();
      expect(invalidListener).toHaveBeenCalledWith(jasmine.any(Event));
    });
  });

  describe('setCustomValidity()', () => {
    it('should set customError to true when given a non-empty string', () => {
      const control = new TestConstraintValidation();
      control.setCustomValidity('Error');
      expect(control.validity.customError)
        .withContext('validity.customError')
        .toBeTrue();
    });

    it('should set customError to false when set to an empty string', () => {
      const control = new TestConstraintValidation();
      control.setCustomValidity('');
      expect(control.validity.customError)
        .withContext('validity.customError')
        .toBeFalse();
    });

    it('should report custom validation message over other validation messages', () => {
      const control = new TestConstraintValidation();
      control.required = true;
      control.setCustomValidity('Error');
      expect(control.validationMessage)
        .withContext('validationMessage')
        .toBe('Error');
    });
  });
});


// ========== /behaviors/custom-state-set.ts ==========
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement} from 'lit';

import {internals, WithElementInternals} from './element-internals.js';
import {MixinBase, MixinReturn} from './mixin.js';

/**
 * A unique symbol used to check if an element's `CustomStateSet` has a state.
 *
 * Provides compatibility with legacy dashed identifier syntax (`:--state`) used
 * by the element-internals-polyfill for Chrome extension support.
 *
 * @example
 * ```ts
 * const baseClass = mixinCustomStateSet(mixinElementInternals(LitElement));
 *
 * class MyElement extends baseClass {
 *   get checked() {
 *     return this[hasState]('checked');
 *   }
 *   set checked(value: boolean) {
 *     this[toggleState]('checked', value);
 *   }
 * }
 * ```
 */
export const hasState = Symbol('hasState');

/**
 * A unique symbol used to add or delete a state from an element's
 * `CustomStateSet`.
 *
 * Provides compatibility with legacy dashed identifier syntax (`:--state`) used
 * by the element-internals-polyfill for Chrome extension support.
 *
 * @example
 * ```ts
 * const baseClass = mixinCustomStateSet(mixinElementInternals(LitElement));
 *
 * class MyElement extends baseClass {
 *   get checked() {
 *     return this[hasState]('checked');
 *   }
 *   set checked(value: boolean) {
 *     this[toggleState]('checked', value);
 *   }
 * }
 * ```
 */
export const toggleState = Symbol('toggleState');

/**
 * An instance with `[hasState]()` and `[toggleState]()` symbol functions that
 * provide compatibility with `CustomStateSet` legacy dashed identifier syntax,
 * used by the element-internals-polyfill and needed for Chrome extension
 * compatibility.
 */
export interface WithCustomStateSet {
  /**
   * Checks if the state is active, returning true if the element matches
   * `:state(customstate)`.
   *
   * @param customState the `CustomStateSet` state to check. Do not use the
   *     `--customstate` dashed identifier syntax.
   * @return true if the custom state is active, or false if not.
   */
  [hasState](customState: string): boolean;

  /**
   * Toggles the state to be active or inactive based on the provided value.
   * When active, the element matches `:state(customstate)`.
   *
   * @param customState the `CustomStateSet` state to check. Do not use the
   *     `--customstate` dashed identifier syntax.
   * @param isActive true to add the state, or false to delete it.
   */
  [toggleState](customState: string, isActive: boolean): void;
}

// Private symbols
const privateUseDashedIdentifier = Symbol('privateUseDashedIdentifier');
const privateGetStateIdentifier = Symbol('privateGetStateIdentifier');

/**
 * Mixes in compatibility functions for access to an element's `CustomStateSet`.
 *
 * Use this mixin's `[hasState]()` and `[toggleState]()` symbol functions for
 * compatibility with `CustomStateSet` legacy dashed identifier syntax.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomStateSet#compatibility_with_dashed-ident_syntax.
 *
 * The dashed identifier syntax is needed for element-internals-polyfill, a
 * requirement for Chome extension compatibility.
 *
 * @example
 * ```ts
 * const baseClass = mixinCustomStateSet(mixinElementInternals(LitElement));
 *
 * class MyElement extends baseClass {
 *   get checked() {
 *     return this[hasState]('checked');
 *   }
 *   set checked(value: boolean) {
 *     this[toggleState]('checked', value);
 *   }
 * }
 * ```
 *
 * @param base The class to mix functionality into.
 * @return The provided class with `[hasState]()` and `[toggleState]()`
 *     functions mixed in.
 */
export function mixinCustomStateSet<
  T extends MixinBase<LitElement & WithElementInternals>,
>(base: T): MixinReturn<T, WithCustomStateSet> {
  abstract class WithCustomStateSetElement
    extends base
    implements WithCustomStateSet
  {
    [hasState](state: string) {
      state = this[privateGetStateIdentifier](state);
      return this[internals].states.has(state);
    }

    [toggleState](state: string, isActive: boolean) {
      state = this[privateGetStateIdentifier](state);
      if (isActive) {
        this[internals].states.add(state);
      } else {
        this[internals].states.delete(state);
      }
    }

    [privateUseDashedIdentifier]: boolean | null = null;

    [privateGetStateIdentifier](state: string) {
      if (this[privateUseDashedIdentifier] === null) {
        // Check if `--state-string` needs to be used. See
        // https://developer.mozilla.org/en-US/docs/Web/API/CustomStateSet#compatibility_with_dashed-ident_syntax
        try {
          const testState = '_test';
          this[internals].states.add(testState);
          this[internals].states.delete(testState);
          this[privateUseDashedIdentifier] = false;
        } catch {
          this[privateUseDashedIdentifier] = true;
        }
      }

      return this[privateUseDashedIdentifier] ? `--${state}` : state;
    }
  }

  return WithCustomStateSetElement;
}


// ========== /behaviors/custom-state-set_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {LitElement} from 'lit';
import {customElement} from 'lit/decorators.js';

import {hasState, mixinCustomStateSet, toggleState} from './custom-state-set.js';
import {mixinElementInternals} from './element-internals.js';

// A more reliable test would use `forceElementInternalsPolyfill()` from
// `element-internals-polyfill`, but our GitHub test build doesn't
// support it since the polyfill changes global types.

/* A simplified version of element-internals-polyfill CustomStateSet. */
class PolyfilledCustomStateSet extends Set<string> {
  constructor(private readonly ref: HTMLElement) {
    super();
  }

  override add(state: string) {
    if (!/^--/.test(state) || typeof state !== 'string') {
      throw new DOMException(
        `Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`,
      );
    }
    const result = super.add(state);
    this.ref.toggleAttribute(`state${state}`, true);
    return result;
  }

  override clear() {
    for (const [entry] of this.entries()) {
      this.delete(entry);
    }
    super.clear();
  }

  override delete(state: string) {
    const result = super.delete(state);
    this.ref.toggleAttribute(`state${state}`, false);
    return result;
  }
}

@customElement('test-custom-state-set')
class TestCustomStateSet extends mixinCustomStateSet(
  mixinElementInternals(LitElement),
) {
  static testWithPolyfill = false;

  override attachInternals() {
    const internals = super.attachInternals();
    if (TestCustomStateSet.testWithPolyfill) {
      Object.defineProperty(internals, 'states', {
        enumerable: true,
        configurable: true,
        value: new PolyfilledCustomStateSet(this),
      });
    }
    return internals;
  }
}

for (const testWithPolyfill of [false, true]) {
  const describeSuffix = testWithPolyfill
    ? ' (with element-internals-polyfill)'
    : '';

  describe(`mixinCustomStateSet()${describeSuffix}`, () => {
    beforeAll(() => {
      TestCustomStateSet.testWithPolyfill = testWithPolyfill;
    });

    describe('[hasState]()', () => {
      it('returns false when the state is not active', () => {
        // Arrange
        const element = new TestCustomStateSet();

        // Assert
        expect(element[hasState]('foo'))
          .withContext("[hasState]('foo')")
          .toBeFalse();
      });

      it('returns true when the state is active', () => {
        // Arrange
        const element = new TestCustomStateSet();

        // Act
        element[toggleState]('foo', true);

        // Assert
        expect(element[hasState]('foo'))
          .withContext("[hasState]('foo')")
          .toBeTrue();
      });

      it('returns false when the state is deactivated', () => {
        // Arrange
        const element = new TestCustomStateSet();
        element[toggleState]('foo', true);

        // Act
        element[toggleState]('foo', false);

        // Assert
        expect(element[hasState]('foo'))
          .withContext("[hasState]('foo')")
          .toBeFalse();
      });
    });

    describe('[toggleState]()', () => {
      const fooStateSelector = testWithPolyfill
        ? `[state--foo]`
        : ':state(foo)';

      it(`matches '${fooStateSelector}' when the state is active`, () => {
        // Arrange
        const element = new TestCustomStateSet();

        // Act
        element[toggleState]('foo', true);

        // Assert
        expect(element.matches(fooStateSelector))
          .withContext(`element.matches('${fooStateSelector}')`)
          .toBeTrue();
      });

      it(`does not match '${fooStateSelector}' when the state is deactivated`, () => {
        // Arrange
        const element = new TestCustomStateSet();
        element[toggleState]('foo', true);

        // Act
        element[toggleState]('foo', false);

        // Assert
        expect(element.matches(fooStateSelector))
          .withContext(`element.matches('${fooStateSelector}')`)
          .toBeFalse();
      });

      it(`does not match '${fooStateSelector}' by default`, () => {
        // Arrange
        const element = new TestCustomStateSet();

        // Assert
        expect(element.matches(fooStateSelector))
          .withContext(`element.matches('${fooStateSelector}')`)
          .toBeFalse();
      });
    });
  });
}


// ========== /behaviors/element-internals.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement} from 'lit';

import {MixinBase, MixinReturn} from './mixin.js';

/**
 * A unique symbol used for protected access to an instance's
 * `ElementInternals`.
 *
 * @example
 * ```ts
 * class MyElement extends mixinElementInternals(LitElement) {
 *   constructor() {
 *     super();
 *     this[internals].role = 'button';
 *   }
 * }
 * ```
 */
export const internals = Symbol('internals');

/**
 * An instance with an `internals` symbol property for the component's
 * `ElementInternals`.
 *
 * Use this when protected access is needed for an instance's `ElementInternals`
 * from other files. A unique symbol is used to access the internals.
 */
export interface WithElementInternals {
  /**
   * An instance's `ElementInternals`.
   */
  [internals]: ElementInternals;
}

// Private symbols
const privateInternals = Symbol('privateInternals');

/**
 * Mixes in an attached `ElementInternals` instance.
 *
 * This mixin is only needed when other shared code needs access to a
 * component's `ElementInternals`, such as form-associated mixins.
 *
 * @param base The class to mix functionality into.
 * @return The provided class with `WithElementInternals` mixed in.
 */
export function mixinElementInternals<T extends MixinBase<LitElement>>(
  base: T,
): MixinReturn<T, WithElementInternals> {
  abstract class WithElementInternalsElement
    extends base
    implements WithElementInternals
  {
    get [internals]() {
      // Create internals in getter so that it can be used in methods called on
      // construction in `ReactiveElement`, such as `requestUpdate()`.
      if (!this[privateInternals]) {
        // Cast needed for closure
        this[privateInternals] = (this as HTMLElement).attachInternals();
      }

      return this[privateInternals];
    }

    // In preparation for ES2022, we need to declare this property to guard
    // against the base class calling [internals] in its constructor prematurely
    // setting this field. Without declare, once this field is defined, it would
    // initialize to undefined and `attachInternals()` could be called again.
    declare [privateInternals]?: ElementInternals;
  }

  return WithElementInternalsElement;
}


// ========== /behaviors/element-internals_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html, LitElement} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';

import {internals, mixinElementInternals} from './element-internals.js';

describe('mixinElementInternals()', () => {
  @customElement('test-element-internals')
  class TestElementInternals extends mixinElementInternals(LitElement) {}

  const env = new Environment();

  async function setupTest() {
    const root = env.render(
      html`<test-element-internals></test-element-internals>`,
    );
    const element = root.querySelector(
      'test-element-internals',
    ) as TestElementInternals;
    await env.waitForStability();
    return element;
  }

  it('should provide an `ElementInternals` instance', async () => {
    const element = await setupTest();
    expect(element[internals]).toBeInstanceOf(ElementInternals);
  });
});


// ========== /behaviors/focusable.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement} from 'lit';
import {property} from 'lit/decorators.js';

import {MixinBase, MixinReturn} from './mixin.js';

/**
 * An element that can enable and disable `tabindex` focusability.
 */
export interface Focusable {
  /**
   * Whether or not the element can be focused. Defaults to true. Set to false
   * to disable focusing (unless a user has set a `tabindex`).
   */
  [isFocusable]: boolean;
}

/**
 * A property symbol that indicates whether or not a `Focusable` element can be
 * focused.
 */
export const isFocusable = Symbol('isFocusable');

const privateIsFocusable = Symbol('privateIsFocusable');
const externalTabIndex = Symbol('externalTabIndex');
const isUpdatingTabIndex = Symbol('isUpdatingTabIndex');
const updateTabIndex = Symbol('updateTabIndex');

/**
 * Mixes in focusable functionality for a class.
 *
 * Elements can enable and disable their focusability with the `isFocusable`
 * symbol property. Changing `tabIndex` will trigger a lit render, meaning
 * `this.tabIndex` can be used in template expressions.
 *
 * This mixin will preserve externally-set tabindices. If an element turns off
 * focusability, but a user sets `tabindex="0"`, it will still be focusable.
 *
 * To remove user overrides and restore focusability control to the element,
 * remove the `tabindex` attribute.
 *
 * @param base The class to mix functionality into.
 * @return The provided class with `Focusable` mixed in.
 */
export function mixinFocusable<T extends MixinBase<LitElement>>(
  base: T,
): MixinReturn<T, Focusable> {
  abstract class FocusableElement extends base implements Focusable {
    @property({noAccessor: true})
    declare tabIndex: number;

    get [isFocusable]() {
      return this[privateIsFocusable];
    }

    set [isFocusable](value: boolean) {
      if (this[isFocusable] === value) {
        return;
      }

      this[privateIsFocusable] = value;
      this[updateTabIndex]();
    }

    [privateIsFocusable] = true;
    [externalTabIndex]: number | null = null;
    [isUpdatingTabIndex] = false;

    override connectedCallback() {
      super.connectedCallback();
      this[updateTabIndex]();
    }

    override attributeChangedCallback(
      name: string,
      old: string | null,
      value: string | null,
    ) {
      if (name !== 'tabindex') {
        super.attributeChangedCallback(name, old, value);
        return;
      }

      this.requestUpdate('tabIndex', Number(old ?? -1));
      if (this[isUpdatingTabIndex]) {
        // Not an externally-initiated update.
        return;
      }

      if (!this.hasAttribute('tabindex')) {
        // User removed the attribute, can now use internal tabIndex
        this[externalTabIndex] = null;
        this[updateTabIndex]();
        return;
      }

      this[externalTabIndex] = this.tabIndex;
    }

    [updateTabIndex]() {
      const internalTabIndex = this[isFocusable] ? 0 : -1;
      const computedTabIndex = this[externalTabIndex] ?? internalTabIndex;

      this[isUpdatingTabIndex] = true;
      this.tabIndex = computedTabIndex;
      this[isUpdatingTabIndex] = false;
    }
  }

  return FocusableElement;
}


// ========== /behaviors/focusable_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html, LitElement} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';

import {isFocusable, mixinFocusable} from './focusable.js';

describe('mixinFocusable()', () => {
  // tslint:disable-next-line:enforce-name-casing MixinClassCase
  const FocusableLitElement = mixinFocusable(LitElement);
  @customElement('test-focusable')
  class TestFocusable extends FocusableLitElement {}

  const env = new Environment();

  async function setupTest() {
    const root = env.render(html`<test-focusable></test-focusable>`);
    const element = root.querySelector('test-focusable') as TestFocusable;
    await env.waitForStability();
    return element;
  }

  it('isFocusable should be true by default', async () => {
    const element = await setupTest();
    expect(element[isFocusable]).withContext('isFocusable').toBeTrue();
  });

  it('should set tabindex="0" when isFocusable is true', async () => {
    const element = await setupTest();
    element[isFocusable] = true;
    expect(element.tabIndex).withContext('tabIndex').toBe(0);
    expect(element.getAttribute('tabindex'))
      .withContext('tabindex attribute')
      .toBe('0');
  });

  it('should set tabindex="-1" when isFocusable is false', async () => {
    const element = await setupTest();
    element[isFocusable] = false;
    expect(element.tabIndex).withContext('tabIndex').toBe(-1);
    expect(element.getAttribute('tabindex'))
      .withContext('tabindex attribute')
      .toBe('-1');
  });

  it('should re-render when tabIndex changes', async () => {
    const element = await setupTest();
    spyOn(element, 'requestUpdate').and.callThrough();
    element.tabIndex = 2;
    expect(element.requestUpdate).toHaveBeenCalled();
  });

  it('should not override user-set tabindex="0" when isFocusable is false', async () => {
    const element = await setupTest();
    element[isFocusable] = false;
    element.tabIndex = 0;
    expect(element[isFocusable]).withContext('isFocusable').toBeFalse();
    expect(element.tabIndex).withContext('tabIndex').toBe(0);
    expect(element.getAttribute('tabindex'))
      .withContext('tabindex attribute')
      .toBe('0');
  });

  it('should not override user-set tabindex="-1" when isFocusable is true', async () => {
    const element = await setupTest();
    element.tabIndex = -1;
    expect(element[isFocusable]).withContext('isFocusable').toBeTrue();
    expect(element.tabIndex).withContext('tabIndex').toBe(-1);
    expect(element.getAttribute('tabindex'))
      .withContext('tabindex attribute')
      .toBe('-1');
  });

  it('should restore default tabindex when user-set tabindex attribute is removed', async () => {
    const element = await setupTest();
    element.tabIndex = -1;
    element.removeAttribute('tabindex');
    expect(element.tabIndex).withContext('tabIndex').toBe(0);
    expect(element.getAttribute('tabindex'))
      .withContext('tabindex attribute')
      .toBe('0');
  });

  it('should not throw attribute hydration errors on construction', () => {
    expect(() => {
      // We do not need to assign a variable to test construction.
      // tslint:disable-next-line:no-unused-expression
      new TestFocusable();
    }).not.toThrow();
  });

  it('should not add tabindex until after the element is connected', async () => {
    const element = new TestFocusable();

    expect(element.hasAttribute('tabindex'))
      .withContext('has tabindex attribute synchronously after construction')
      .toBeFalse();

    await env.waitForStability();

    // To avoid attribute hydration errors, we wait until the element is
    // connected before we update the tabindex.
    expect(element.hasAttribute('tabindex'))
      .withContext('has tabindex attribute after task but before connected')
      .toBeFalse();

    env.render(html`${element}`);

    expect(element.isConnected).withContext('element.isConnected').toBeTrue();
    expect(element.hasAttribute('tabindex'))
      .withContext('has tabindex attribute after connected to dom')
      .toBeTrue();
  });
});


// ========== /behaviors/form-associated.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement, PropertyDeclaration} from 'lit';
import {property} from 'lit/decorators.js';

import {internals, WithElementInternals} from './element-internals.js';
import {MixinBase, MixinReturn} from './mixin.js';

/**
 * A form-associated element.
 *
 * IMPORTANT: Requires declares for lit-analyzer
 * @example
 * ```ts
 * const base = mixinFormAssociated(mixinElementInternals(LitElement));
 * class MyControl extends base {
 *   // Writable mixin properties for lit-html binding, needed for lit-analyzer
 *   declare disabled: boolean;
 *   declare name: string;
 * }
 * ```
 */
export interface FormAssociated {
  /**
   * The associated form element with which this element's value will submit.
   */
  readonly form: HTMLFormElement | null;

  /**
   * The labels this element is associated with.
   */
  readonly labels: NodeList;

  /**
   * The HTML name to use in form submission.
   */
  name: string;

  /**
   * Whether or not the element is disabled.
   */
  disabled: boolean;

  /**
   * Gets the current form value of a component.
   *
   * @return The current form value.
   */
  [getFormValue](): FormValue | null;

  /**
   * Gets the current form state of a component. Defaults to the component's
   * `[formValue]`.
   *
   * Use this when the state of an element is different from its value, such as
   * checkboxes (internal boolean state and a user string value).
   *
   * @return The current form state, defaults to the form value.
   */
  [getFormState](): FormValue | null;

  /**
   * A callback for when a form component should be disabled or enabled. This
   * can be called in a variety of situations, such as disabled `<fieldset>`s.
   *
   * @param disabled Whether or not the form control should be disabled.
   */
  formDisabledCallback(disabled: boolean): void;

  /**
   * A callback for when the form requests to reset its value. Typically, the
   * default value that is reset is represented in the attribute of an element.
   *
   * This means the attribute used for the value should not update as the value
   * changes. For example, a checkbox should not change its default `checked`
   * attribute when selected. Ensure form values do not reflect.
   */
  formResetCallback(): void;

  /**
   * A callback for when the form restores the state of a component. For
   * example, when a page is reloaded or forms are autofilled.
   *
   * @param state The state to restore, or null to reset the form control's
   *     value.
   * @param reason The reason state was restored, either `'restore'` or
   *   `'autocomplete'`.
   */
  formStateRestoreCallback(
    state: FormRestoreState | null,
    reason: FormRestoreReason,
  ): void;

  /**
   * An optional callback for when the associated form changes.
   *
   * @param form The new associated form, or `null` if there is none.
   */
  formAssociatedCallback?(form: HTMLFormElement | null): void;
}

/**
 * The constructor of a `FormAssociated` element.
 */
export interface FormAssociatedConstructor {
  /**
   * Indicates that an element is participating in form association.
   */
  readonly formAssociated: true;
}

/**
 * A symbol property to retrieve the form value for an element.
 */
export const getFormValue = Symbol('getFormValue');

/**
 * A symbol property to retrieve the form state for an element.
 */
export const getFormState = Symbol('getFormState');

/**
 * Mixes in form-associated behavior for a class. This allows an element to add
 * values to `<form>` elements.
 *
 * Implementing classes should provide a `[formValue]` to return the current
 * value of the element, as well as reset and restore callbacks.
 *
 * @example
 * ```ts
 * const base = mixinFormAssociated(mixinElementInternals(LitElement));
 *
 * class MyControl extends base {
 *   \@property()
 *   value = '';
 *
 *   override [getFormValue]() {
 *     return this.value;
 *   }
 *
 *   override formResetCallback() {
 *     const defaultValue = this.getAttribute('value');
 *     this.value = defaultValue;
 *   }
 *
 *   override formStateRestoreCallback(state: string) {
 *     this.value = state;
 *   }
 * }
 * ```
 *
 * Elements may optionally provide a `[formState]` if their values do not
 * represent the state of the component.
 *
 * @example
 * ```ts
 * const base = mixinFormAssociated(mixinElementInternals(LitElement));
 *
 * class MyCheckbox extends base {
 *   \@property()
 *   value = 'on';
 *
 *   \@property({type: Boolean})
 *   checked = false;
 *
 *   override [getFormValue]() {
 *     return this.checked ? this.value : null;
 *   }
 *
 *   override [getFormState]() {
 *     return String(this.checked);
 *   }
 *
 *   override formResetCallback() {
 *     const defaultValue = this.hasAttribute('checked');
 *     this.checked = defaultValue;
 *   }
 *
 *   override formStateRestoreCallback(state: string) {
 *     this.checked = Boolean(state);
 *   }
 * }
 * ```
 *
 * IMPORTANT: Requires declares for lit-analyzer
 * @example
 * ```ts
 * const base = mixinFormAssociated(mixinElementInternals(LitElement));
 * class MyControl extends base {
 *   // Writable mixin properties for lit-html binding, needed for lit-analyzer
 *   declare disabled: boolean;
 *   declare name: string;
 * }
 * ```
 *
 * @param base The class to mix functionality into. The base class must use
 *     `mixinElementInternals()`.
 * @return The provided class with `FormAssociated` mixed in.
 */
export function mixinFormAssociated<
  T extends MixinBase<LitElement & WithElementInternals>,
>(base: T): MixinReturn<T & FormAssociatedConstructor, FormAssociated> {
  abstract class FormAssociatedElement extends base implements FormAssociated {
    /** @nocollapse */
    static readonly formAssociated = true;

    get form() {
      return this[internals].form;
    }

    get labels() {
      return this[internals].labels;
    }

    // Use @property for the `name` and `disabled` properties to add them to the
    // `observedAttributes` array and trigger `attributeChangedCallback()`.
    //
    // We don't use Lit's default getter/setter (`noAccessor: true`) because
    // the attributes need to be updated synchronously to work with synchronous
    // form APIs, and Lit updates attributes async by default.
    @property({noAccessor: true})
    get name() {
      return this.getAttribute('name') ?? '';
    }
    set name(name: string) {
      // Note: setting name to null or empty does not remove the attribute.
      this.setAttribute('name', name);
      // We don't need to call `requestUpdate()` since it's called synchronously
      // in `attributeChangedCallback()`.
    }

    @property({type: Boolean, noAccessor: true})
    get disabled() {
      return this.hasAttribute('disabled');
    }
    set disabled(disabled: boolean) {
      this.toggleAttribute('disabled', disabled);
      // We don't need to call `requestUpdate()` since it's called synchronously
      // in `attributeChangedCallback()`.
    }

    override attributeChangedCallback(
      name: string,
      old: string | null,
      value: string | null,
    ) {
      // Manually `requestUpdate()` for `name` and `disabled` when their
      // attribute or property changes.
      // The properties update their attributes, so this callback is invoked
      // immediately when the properties are set. We call `requestUpdate()` here
      // instead of letting Lit set the properties from the attribute change.
      // That would cause the properties to re-set the attribute and invoke this
      // callback again in a loop. This leads to stale state when Lit tries to
      // determine if a property changed or not.
      if (name === 'name' || name === 'disabled') {
        // Disabled's value is only false if the attribute is missing and null.
        const oldValue = name === 'disabled' ? old !== null : old;
        // Trigger a lit update when the attribute changes.
        this.requestUpdate(name, oldValue);
        return;
      }

      super.attributeChangedCallback(name, old, value);
    }

    override requestUpdate(
      name?: PropertyKey,
      oldValue?: unknown,
      options?: PropertyDeclaration,
    ) {
      super.requestUpdate(name, oldValue, options);
      // If any properties change, update the form value, which may have changed
      // as well.
      // Update the form value synchronously in `requestUpdate()` rather than
      // `update()` or `updated()`, which are async. This is necessary to ensure
      // that form data is updated in time for synchronous event listeners.
      this[internals].setFormValue(this[getFormValue](), this[getFormState]());
    }

    [getFormValue](): FormValue | null {
      // Closure does not allow abstract symbol members, so a default
      // implementation is needed.
      throw new Error('Implement [getFormValue]');
    }

    [getFormState](): FormValue | null {
      return this[getFormValue]();
    }

    formDisabledCallback(disabled: boolean) {
      this.disabled = disabled;
    }

    abstract formResetCallback(): void;

    abstract formStateRestoreCallback(
      state: FormRestoreState | null,
      reason: FormRestoreReason,
    ): void;
  }

  return FormAssociatedElement;
}

/**
 * A value that can be provided for form submission and state.
 */
export type FormValue = File | string | FormData;

/**
 * A value to be restored for a component's form value. If a component's form
 * state is a `FormData` object, its entry list of name and values will be
 * provided.
 */
export type FormRestoreState =
  | File
  | string
  | Array<[string, FormDataEntryValue]>;

/**
 * The reason a form component is being restored for, either `'restore'` for
 * browser restoration or `'autocomplete'` for restoring user values.
 */
export type FormRestoreReason = 'restore' | 'autocomplete';


// ========== /behaviors/form-associated_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {LitElement, html, render} from 'lit';
import {customElement, property} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';

import {internals, mixinElementInternals} from './element-internals.js';
import {
  getFormState,
  getFormValue,
  mixinFormAssociated,
} from './form-associated.js';

describe('mixinFormAssociated()', () => {
  @customElement('test-form-associated')
  class TestFormAssociated extends mixinFormAssociated(
    mixinElementInternals(LitElement),
  ) {
    @property() value = '';
    get state(): 'populated' | 'empty' {
      return this.value ? 'populated' : 'empty';
    }

    useCustomGetFormStateImpl = true;

    override [getFormValue]() {
      return this.value;
    }

    override [getFormState]() {
      if (this.useCustomGetFormStateImpl) {
        return this.state;
      }

      return super[getFormState]();
    }

    // These behaviors are specific to individual components
    override formResetCallback() {}
    override formStateRestoreCallback() {}
  }

  const env = new Environment();

  // Form APIs should be synchronous
  function setupTestWithoutForm() {
    const root = env.render(
      html`<test-form-associated></test-form-associated>`,
    );

    const element = root.querySelector(
      'test-form-associated',
    ) as TestFormAssociated;

    return {root, element};
  }

  function setupTestWithForm() {
    const root = env.render(
      html`<form><test-form-associated></test-form-associated></form>`,
    );

    const form = root.querySelector('form')!;
    const element = root.querySelector(
      'test-form-associated',
    ) as TestFormAssociated;

    return {root, form, element};
  }

  it('should add `static formAssociated = true`', () => {
    const {element} = setupTestWithoutForm();
    expect(
      (element.constructor as typeof TestFormAssociated).formAssociated,
    ).toBeTrue();
  });

  describe('.form', () => {
    it('should return null when not a child of a form', () => {
      const {element} = setupTestWithoutForm();
      expect(element.form).toBeNull();
    });

    it('should return parent form element', () => {
      const {form, element} = setupTestWithForm();
      expect(element.form).toBe(form);
    });
  });

  describe('labels', () => {
    it('should return empty NodeList when no labels associated', () => {
      const {element} = setupTestWithoutForm();
      expect(element.labels).toBeInstanceOf(NodeList);
      expect(element.labels).toHaveSize(0);
    });

    it('should return parent labels', () => {
      const {root, element} = setupTestWithoutForm();
      render(html`<label>${element}</label>`, root);
      const label = root.querySelector('label');
      if (!label) {
        throw new Error('<label> did not render');
      }

      expect(element.labels).toHaveSize(1);
      expect(element.labels[0]).toBe(label);
    });

    it('should return ID ref labels', () => {
      const {root, element} = setupTestWithoutForm();
      element.id = 'control';
      render(html`<label for="control"></label>${element}`, root);
      const label = root.querySelector('label');
      if (!label) {
        throw new Error('<label> did not render');
      }

      expect(element.labels).toHaveSize(1);
      expect(element.labels[0]).toBe(label);
    });

    it('should return multiple labels', () => {
      const {root, element} = setupTestWithoutForm();
      element.id = 'control';
      render(
        html`<label for="control"></label>
          <label for="control"></label>
          <label>${element}</label>`,
        root,
      );

      expect(element.labels).toHaveSize(3);
    });
  });

  describe('name', () => {
    it('should return empty string by default', () => {
      const {element} = setupTestWithoutForm();
      expect(element.name).toBe('');
    });

    it('should return name attribute', () => {
      const {element} = setupTestWithoutForm();
      element.setAttribute('name', 'foo');
      expect(element.name).toBe('foo');
    });

    it('should set name attribute synchronously', () => {
      const {element} = setupTestWithoutForm();
      element.name = 'foo';
      expect(element.getAttribute('name'))
        .withContext('name attribute value')
        .toBe('foo');
    });

    it('should add empty name attribute if set to an empty string', () => {
      const {element} = setupTestWithoutForm();
      element.name = '';
      expect(element.hasAttribute('name'))
        .withContext('has name attribute')
        .toBeTrue();
      expect(element.getAttribute('name'))
        .withContext('name attribute value')
        .toBe('');
    });

    it('should request a render on change', () => {
      const {element} = setupTestWithoutForm();
      spyOn(element, 'requestUpdate').and.callThrough();
      element.name = 'foo';
      expect(element.requestUpdate).toHaveBeenCalled();
    });
  });

  describe('disabled', () => {
    it('should return false by default', () => {
      const {element} = setupTestWithoutForm();
      expect(element.disabled).toBeFalse();
    });

    it('should return true if attribute set', () => {
      const {element} = setupTestWithoutForm();
      element.setAttribute('disabled', '');
      expect(element.disabled).toBeTrue();
    });

    it('should set disabled attribute synchronously', () => {
      const {element} = setupTestWithoutForm();
      element.disabled = true;
      expect(element.hasAttribute('disabled'))
        .withContext('has disabled attribute')
        .toBeTrue();
    });

    it('should remove attribute if set to false', () => {
      const {element} = setupTestWithoutForm();
      element.setAttribute('disabled', '');
      element.disabled = false;
      expect(element.hasAttribute('disabled'))
        .withContext('has disabled attribute')
        .toBeFalse();
    });

    it('should request a render on change', () => {
      const {element} = setupTestWithoutForm();
      spyOn(element, 'requestUpdate').and.callThrough();
      element.disabled = true;
      expect(element.requestUpdate).toHaveBeenCalled();
    });
  });

  describe('[getFormValue]()', () => {
    it('should throw an error if not implemented', () => {
      expect(() => {
        @customElement('test-bad-form-associated')
        class TestBadFormAssociated extends mixinFormAssociated(
          mixinElementInternals(LitElement),
        ) {
          override requestUpdate(
            ...args: Parameters<LitElement['requestUpdate']>
          ) {
            // Suppress errors that will occur async when the element is
            // initialized. This is harder to test in jasmine, so we explicitly
            // call the getFormValue function to test the error.
            try {
              super.requestUpdate(...args);
            } catch {}
          }
        }

        const element = new TestBadFormAssociated();
        element[getFormValue]();
      }).toThrowError(/getFormValue/);
    });

    it('should not add form data without a name', () => {
      const {element, form} = setupTestWithForm();
      element.value = 'value';
      const data = new FormData(form);
      expect(Array.from(data.entries())).toHaveSize(0);
    });

    it('should synchronously add value to form data', () => {
      const {element, form} = setupTestWithForm();
      element.name = 'foo';
      element.value = 'value';
      const data = new FormData(form);
      expect(data.get('foo')).withContext('FormData "foo" value').toBe('value');
    });
  });

  describe('[getFormState]()', () => {
    it('should return form value by default', () => {
      const {element} = setupTestWithoutForm();
      element.value = 'value';
      element.useCustomGetFormStateImpl = false;
      expect(element[getFormState]())
        .withContext('[getFormState]() return')
        .toBe('value');
    });

    it('should be able to return a custom state', () => {
      const {element} = setupTestWithoutForm();
      element.useCustomGetFormStateImpl = true;
      element.value = 'value';
      expect(element[getFormState]())
        .withContext('[getFormState]() custom return')
        .toBe(element.state);
    });

    it('should be provided as the second argument to `internals.setFormValue()`', () => {
      const {element} = setupTestWithoutForm();
      element.useCustomGetFormStateImpl = true;
      spyOn(element[internals], 'setFormValue').and.callThrough();
      element.value = 'value';
      expect(element[internals].setFormValue).toHaveBeenCalledOnceWith(
        element.value,
        element.state,
      );
    });
  });

  describe('formDisabledCallback()', () => {
    it('should set `element.disabled` to the provided value', () => {
      const {element} = setupTestWithoutForm();
      element.formDisabledCallback(true);
      expect(element.disabled)
        .withContext('element.disabled after callback with true')
        .toBeTrue();
      element.formDisabledCallback(false);
      expect(element.disabled)
        .withContext('element.disabled after callback with false')
        .toBeFalse();
    });

    it('should set `disabled` when control is disabled from fieldset', () => {
      const {root, element} = setupTestWithoutForm();
      render(html`<fieldset disabled>${element}</fieldset>`, root);
      expect(element.disabled).withContext('element.disabled').toBeTrue();
    });
  });
});


// ========== /behaviors/mixin.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * The base class for a mixin with an optional expected base class type.
 *
 * @template ExpectedBase Optional expected base class type, such as
 *     `LitElement`.
 *
 * @example
 * ```ts
 * interface Foo {
 *   isFoo: boolean;
 * }
 *
 * function mixinFoo<T extends MixinBase>(base: T): MixinReturn<T, Foo> {
 *   // Mixins must be `abstract`
 *   abstract class FooImpl extends base implements Foo {
 *     isFoo = true;
 *   }
 *
 *   return FooImpl;
 * }
 * ```
 */
export type MixinBase<ExpectedBase = object> = abstract new (
  // Mixins must have a constructor with `...args: any[]`
  // tslint:disable-next-line:no-any
  ...args: any[]
) => ExpectedBase;

/**
 * The return value of a mixin.
 *
 * @template MixinBase The generic that extends `MixinBase` used for the mixin's
 *     base class argument.
 * @template MixinClass Optional interface of fuctionality that was mixed in.
 *     Omit if no additional APIs were added (such as purely overriding base
 *     class functionality).
 *
 * @example
 * ```ts
 * interface Foo {
 *   isFoo: boolean;
 * }
 *
 * // Mixins must be `abstract`
 * function mixinFoo<T extends MixinBase>(base: T): MixinReturn<T, Foo> {
 *   abstract class FooImpl extends base implements Foo {
 *     isFoo = true;
 *   }
 *
 *   return FooImpl;
 * }
 * ```
 */
export type MixinReturn<MixinBase, MixinClass = object> =
  // Mixins must have a constructor with `...args: any[]`
  // tslint:disable-next-line:no-any
  (abstract new (...args: any[]) => MixinClass) & MixinBase;


// ========== /behaviors/on-report-validity.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement, isServer} from 'lit';

import {ConstraintValidation} from './constraint-validation.js';
import {WithElementInternals, internals} from './element-internals.js';
import {MixinBase, MixinReturn} from './mixin.js';

/**
 * A constraint validation element that has a callback for when the element
 * should report validity styles and error messages to the user.
 *
 * This is commonly used in text-field-like controls that display error styles
 * and error messages.
 */
export interface OnReportValidity extends ConstraintValidation {
  /**
   * A callback that is invoked when validity should be reported. Components
   * that can display their own error state can use this and update their
   * styles.
   *
   * If an invalid event is provided, the element is invalid. If `null`, the
   * element is valid.
   *
   * The invalid event's `preventDefault()` may be called to stop the platform
   * popup from displaying.
   *
   * @param invalidEvent The `invalid` event dispatched when an element is
   *     invalid, or `null` if the element is valid.
   */
  [onReportValidity](invalidEvent: Event | null): void;

  // `mixinOnReportValidity()` implements this optional method. If overriden,
  // call `super.formAssociatedCallback(form)`.
  // (inherit jsdoc from `FormAssociated`)
  formAssociatedCallback(form: HTMLFormElement | null): void;
}

/**
 * A symbol property used for a callback when validity has been reported.
 */
export const onReportValidity = Symbol('onReportValidity');

// Private symbol members, used to avoid name clashing.
const privateCleanupFormListeners = Symbol('privateCleanupFormListeners');
const privateDoNotReportInvalid = Symbol('privateDoNotReportInvalid');
const privateIsSelfReportingValidity = Symbol('privateIsSelfReportingValidity');
const privateCallOnReportValidity = Symbol('privateCallOnReportValidity');

/**
 * Mixes in a callback for constraint validation when validity should be
 * styled and reported to the user.
 *
 * This is commonly used in text-field-like controls that display error styles
 * and error messages.
 *
 * @example
 * ```ts
 * const baseClass = mixinOnReportValidity(
 *   mixinConstraintValidation(
 *     mixinFormAssociated(mixinElementInternals(LitElement)),
 *   ),
 * );
 *
 * class MyField extends baseClass {
 *   \@property({type: Boolean}) error = false;
 *   \@property() errorMessage = '';
 *
 *   [onReportValidity](invalidEvent: Event | null) {
 *     this.error = !!invalidEvent;
 *     this.errorMessage = this.validationMessage;
 *
 *     // Optionally prevent platform popup from displaying
 *     invalidEvent?.preventDefault();
 *   }
 * }
 * ```
 *
 * @param base The class to mix functionality into.
 * @return The provided class with `OnReportValidity` mixed in.
 */
export function mixinOnReportValidity<
  T extends MixinBase<LitElement & ConstraintValidation & WithElementInternals>,
>(base: T): MixinReturn<T, OnReportValidity> {
  abstract class OnReportValidityElement
    extends base
    implements OnReportValidity
  {
    /**
     * Used to clean up event listeners when a new form is associated.
     */
    [privateCleanupFormListeners] = new AbortController();

    /**
     * Used to determine if an invalid event should report validity. Invalid
     * events from `checkValidity()` do not trigger reporting.
     */
    [privateDoNotReportInvalid] = false;

    /**
     * Used to determine if the control is reporting validity from itself, or
     * if a `<form>` is causing the validity report. Forms have different
     * control focusing behavior.
     */
    [privateIsSelfReportingValidity] = false;

    // Mixins must have a constructor with `...args: any[]`
    // tslint:disable-next-line:no-any
    constructor(...args: any[]) {
      super(...args);
      if (isServer) {
        return;
      }

      this.addEventListener(
        'invalid',
        (invalidEvent) => {
          // Listen for invalid events dispatched by a `<form>` when it tries to
          // submit and the element is invalid. We ignore events dispatched when
          // calling `checkValidity()` as well as untrusted events, since the
          // `reportValidity()` and `<form>`-dispatched events are always
          // trusted.
          if (this[privateDoNotReportInvalid] || !invalidEvent.isTrusted) {
            return;
          }

          this.addEventListener(
            'invalid',
            () => {
              // A normal bubbling phase event listener. By adding it here, we
              // ensure it's the last event listener that is called during the
              // bubbling phase.
              this[privateCallOnReportValidity](invalidEvent);
            },
            {once: true},
          );
        },
        {
          // Listen during the capture phase, which will happen before the
          // bubbling phase. That way, we can add a final event listener that
          // will run after other event listeners, and we can check if it was
          // default prevented. This works because invalid does not bubble.
          capture: true,
        },
      );
    }

    override checkValidity() {
      this[privateDoNotReportInvalid] = true;
      const valid = super.checkValidity();
      this[privateDoNotReportInvalid] = false;
      return valid;
    }

    override reportValidity() {
      this[privateIsSelfReportingValidity] = true;
      const valid = super.reportValidity();
      // Constructor's invalid listener will handle reporting invalid events.
      if (valid) {
        this[privateCallOnReportValidity](null);
      }

      this[privateIsSelfReportingValidity] = false;
      return valid;
    }

    [privateCallOnReportValidity](invalidEvent: Event | null) {
      // Since invalid events do not bubble to parent listeners, and because
      // our invalid listeners are added lazily after other listeners, we can
      // reliably read `defaultPrevented` synchronously without worrying
      // about waiting for another listener that could cancel it.
      const wasCanceled = invalidEvent?.defaultPrevented;
      if (wasCanceled) {
        return;
      }

      this[onReportValidity](invalidEvent);

      // If an implementation calls invalidEvent.preventDefault() to stop the
      // platform popup from displaying, focusing is also prevented, so we need
      // to manually focus.
      const implementationCanceledFocus =
        !wasCanceled && invalidEvent?.defaultPrevented;
      if (!implementationCanceledFocus) {
        return;
      }

      // The control should be focused when:
      // - `control.reportValidity()` is called (self-reporting).
      // - a form is reporting validity for its controls and this is the first
      //   invalid control.
      if (
        this[privateIsSelfReportingValidity] ||
        isFirstInvalidControlInForm(this[internals].form, this)
      ) {
        this.focus();
      }
    }

    [onReportValidity](invalidEvent: Event | null) {
      throw new Error('Implement [onReportValidity]');
    }

    override formAssociatedCallback(form: HTMLFormElement | null) {
      // can't use super.formAssociatedCallback?.() due to closure
      if (super.formAssociatedCallback) {
        super.formAssociatedCallback(form);
      }

      // Clean up previous form listeners.
      this[privateCleanupFormListeners].abort();
      if (!form) {
        return;
      }

      this[privateCleanupFormListeners] = new AbortController();

      // Add a listener that fires when the form runs constraint validation and
      // the control is valid, so that it may remove its error styles.
      //
      // This happens on `form.reportValidity()` and `form.requestSubmit()`
      // (both when the submit fails and passes).
      addFormReportValidListener(
        this,
        form,
        () => {
          this[privateCallOnReportValidity](null);
        },
        this[privateCleanupFormListeners].signal,
      );
    }
  }

  return OnReportValidityElement;
}

/**
 * Add a listener that fires when a form runs constraint validation on a control
 * and it is valid. This is needed to clear previously invalid styles.
 *
 * @param control The control of the form to listen for valid events.
 * @param form The control's form that can run constraint validation.
 * @param onControlValid A listener that is called when the form runs constraint
 *     validation and the control is valid.
 * @param cleanup A cleanup signal to remove the listener.
 */
function addFormReportValidListener(
  control: Element,
  form: HTMLFormElement,
  onControlValid: () => void,
  cleanup: AbortSignal,
) {
  const validateHooks = getFormValidateHooks(form);

  // When a form validates its controls, check if an invalid event is dispatched
  // on the control. If it is not, then inform the control to report its valid
  // state.
  let controlFiredInvalid = false;
  let cleanupInvalidListener: AbortController | undefined;
  let isNextSubmitFromHook = false;
  validateHooks.addEventListener(
    'before',
    () => {
      isNextSubmitFromHook = true;
      cleanupInvalidListener = new AbortController();
      controlFiredInvalid = false;
      control.addEventListener(
        'invalid',
        () => {
          controlFiredInvalid = true;
        },
        {
          signal: cleanupInvalidListener.signal,
        },
      );
    },
    {signal: cleanup},
  );

  validateHooks.addEventListener(
    'after',
    () => {
      isNextSubmitFromHook = false;
      cleanupInvalidListener?.abort();
      if (controlFiredInvalid) {
        return;
      }

      onControlValid();
    },
    {signal: cleanup},
  );

  // The above hooks handle imperatively submitting the form, but not
  // declaratively submitting the form. This happens when:
  // 1. A non-custom element `<button type="submit">` is clicked.
  // 2. Enter is pressed on a non-custom element text editable `<input>`.
  form.addEventListener(
    'submit',
    () => {
      // This submit was from `form.requestSubmit()`, which already calls the
      // listener.
      if (isNextSubmitFromHook) {
        return;
      }

      onControlValid();
    },
    {
      signal: cleanup,
    },
  );

  // Note: it is a known limitation that we cannot detect if a form tries to
  // submit declaratively, but fails to do so because an unrelated sibling
  // control failed its constraint validation.
  //
  // Since we cannot detect when that happens, a previously invalid control may
  // not clear its error styling when it becomes valid again.
  //
  // To work around this, call `form.reportValidity()` when submitting a form
  // declaratively. This can be down on the `<button type="submit">`'s click or
  // the text editable `<input>`'s 'Enter' keydown.
}

const FORM_VALIDATE_HOOKS = new WeakMap<HTMLFormElement, EventTarget>();

/**
 * Get a hooks `EventTarget` that dispatches 'before' and 'after' events that
 * fire before a form runs constraint validation and immediately after it
 * finishes running constraint validation on its controls.
 *
 * This happens during `form.reportValidity()` and `form.requestSubmit()`.
 *
 * @param form The form to get or set up hooks for.
 * @return A hooks `EventTarget` to add listeners to.
 */
function getFormValidateHooks(form: HTMLFormElement) {
  if (!FORM_VALIDATE_HOOKS.has(form)) {
    // Patch form methods to add event listener hooks. These are needed to react
    // to form behaviors that do not dispatch events, such as a form asking its
    // controls to report their validity.
    //
    // We should only patch the methods once, since multiple controls and other
    // forces may want to patch this method. We cannot reliably clean it up if
    // there are multiple patched and re-patched methods referring holding
    // references to each other.
    //
    // Instead, we never clean up the patch but add and clean up event listeners
    // added to the hooks after the patch.
    const hooks = new EventTarget();
    FORM_VALIDATE_HOOKS.set(form, hooks);

    // Add hooks to support notifying before and after a form has run constraint
    // validation on its controls.
    // Note: `form.submit()` does not run constraint validation per spec.
    for (const methodName of ['reportValidity', 'requestSubmit'] as const) {
      const superMethod = form[methodName];
      form[methodName] = function (this: HTMLFormElement) {
        hooks.dispatchEvent(new Event('before'));
        const result = Reflect.apply(superMethod, this, arguments);
        hooks.dispatchEvent(new Event('after'));
        return result;
      };
    }
  }

  return FORM_VALIDATE_HOOKS.get(form)!;
}

/**
 * Checks if a control is the first invalid control in a form.
 *
 * @param form The control's form. When `null`, the control doesn't have a form
 *     and the method returns true.
 * @param control The control to check.
 * @return True if there is no form or if the control is the form's first
 *     invalid control.
 */
function isFirstInvalidControlInForm(
  form: HTMLFormElement | null,
  control: HTMLElement,
) {
  if (!form) {
    return true;
  }

  let firstInvalidControl: Element | undefined;
  for (const element of form.elements) {
    if (element.matches(':invalid')) {
      firstInvalidControl = element;
      break;
    }
  }

  return firstInvalidControl === control;
}


// ========== /behaviors/on-report-validity_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from './constraint-validation.js';
import {mixinElementInternals} from './element-internals.js';
import {mixinFocusable} from './focusable.js';
import {getFormValue, mixinFormAssociated} from './form-associated.js';
import {mixinOnReportValidity, onReportValidity} from './on-report-validity.js';
import {CheckboxValidator} from './validators/checkbox-validator.js';

describe('mixinOnReportValidity()', () => {
  const baseClass = mixinFocusable(
    mixinOnReportValidity(
      mixinConstraintValidation(
        mixinFormAssociated(mixinElementInternals(LitElement)),
      ),
    ),
  );

  @customElement('test-on-report-validity')
  class TestOnReportValidity extends baseClass {
    @property({type: Boolean}) checked = false;
    @property({type: Boolean}) required = false;

    override render() {
      return html`<div id="root"></div>`;
    }

    override [createValidator]() {
      return new CheckboxValidator(() => this);
    }

    override [getValidityAnchor]() {
      return this.shadowRoot?.querySelector<HTMLElement>('#root') ?? null;
    }

    override [getFormValue]() {
      return String(this.checked);
    }
  }

  describe('[onReportValidity]', () => {
    describe('for valid controls', () => {
      it('should be called with null when reportValidity() is called and it is valid', () => {
        const control = new TestOnReportValidity();
        control[onReportValidity] = jasmine.createSpy('onReportValidity');

        control.reportValidity();
        expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
      });
    });

    describe('for invalid controls', () => {
      it('should be called with event when reportValidity() is called and it is invalid', () => {
        const control = new TestOnReportValidity();
        control[onReportValidity] = jasmine.createSpy('onReportValidity');

        control.required = true;
        control.reportValidity();
        expect(control[onReportValidity]).toHaveBeenCalledOnceWith(
          jasmine.any(Event),
        );
      });

      it('should NOT be called when reportValidity() is called and invalid but default prevented', () => {
        const control = new TestOnReportValidity();
        control[onReportValidity] = jasmine.createSpy('onReportValidity');

        control.required = true;
        control.addEventListener('invalid', (event) => {
          event.preventDefault();
        });

        control.reportValidity();
        expect(control[onReportValidity]).not.toHaveBeenCalled();
      });
    });

    describe('for invalid to valid controls', () => {
      it('should be called with null when reportValidity() is called after fixing invalid', () => {
        const control = new TestOnReportValidity();
        const onReportValiditySpy = jasmine.createSpy('onReportValidity');
        control[onReportValidity] = onReportValiditySpy;
        control.required = true;
        control.reportValidity();
        onReportValiditySpy.calls.reset();

        // Fix invalid
        control.checked = true;
        control.reportValidity();

        expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
      });
    });

    describe('with forms', () => {
      describe('for valid controls', () => {
        it('should be called with null when form.reportValidity() is called and it is valid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);

          form.reportValidity();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form.requestSubmit() is called and it is valid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading
              event.preventDefault();
            },
            {capture: true},
          );

          document.body.appendChild(form);
          form.requestSubmit();
          form.remove();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form submits declaratively and it is valid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading
              event.preventDefault();
            },
            {capture: true},
          );

          const submitButton = document.createElement('button');
          form.appendChild(submitButton);
          document.body.appendChild(form);
          submitButton.click();
          form.remove();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form submits declaratively and it is valid, but another sibling is invalid', () => {
          // This is a known limitation. If a form is using an MWC control and
          // declaratively submits it with a native `<button>` or `<input>`, then
          // error styles will not clear if the form fails to submit.
          // The workaround is to call `form.reportValidity()` when clicking the
          // native `<button type="submit">` or pressing enter in an `<input>`.
          //
          // Leaving this test here for documentation and a possible future fix.
          expect().nothing();
        });
      });

      describe('for valid to invalid controls', () => {
        it('should be called with event when form.reportValidity() is called and it is invalid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);

          control.required = true;
          form.reportValidity();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(
            jasmine.any(Event),
          );
        });

        it('should NOT be called when form.reportValidity() is called and invalid but default prevented', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);

          control.required = true;
          control.addEventListener('invalid', (event) => {
            event.preventDefault();
          });

          form.reportValidity();
          expect(control[onReportValidity]).not.toHaveBeenCalled();
        });

        it('should be called with event when form.requestSubmit() is called and it is invalid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading. This shouldn't
              // happen, but we add it just in case the control fails and reports
              // as valid and the form tries to submit.
              event.preventDefault();
            },
            {capture: true},
          );

          document.body.appendChild(form);
          control.required = true;
          form.requestSubmit();
          form.remove();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(
            jasmine.any(Event),
          );
        });

        it('should NOT be called when form.requestSubmit() is called and invalid but default prevented', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading. This shouldn't
              // happen, but we add it just in case the control fails and reports
              // as valid and the form tries to submit.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          control.addEventListener('invalid', (event) => {
            event.preventDefault();
          });

          document.body.appendChild(form);
          form.requestSubmit();
          form.remove();
          expect(control[onReportValidity]).not.toHaveBeenCalled();
        });

        it('should be called with event when form submits declaratively and it is invalid', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading. This shouldn't
              // happen, but we add it just in case the control fails and reports
              // as valid and the form tries to submit.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          const submitButton = document.createElement('button');
          form.appendChild(submitButton);
          document.body.appendChild(form);
          submitButton.click();
          form.remove();
          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(
            jasmine.any(Event),
          );
        });

        it('should NOT be called when form submits declaratively and invalid but default prevented', () => {
          const control = new TestOnReportValidity();
          control[onReportValidity] = jasmine.createSpy('onReportValidity');
          const form = document.createElement('form');
          form.appendChild(control);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading. This shouldn't
              // happen, but we add it just in case the control fails and reports
              // as valid and the form tries to submit.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          control.addEventListener('invalid', (event) => {
            event.preventDefault();
          });

          document.body.appendChild(form);
          form.requestSubmit();
          form.remove();
          expect(control[onReportValidity]).not.toHaveBeenCalled();
        });
      });

      describe('invalid to valid', () => {
        it('should be called with null when form.reportValidity() is called after fixing invalid', () => {
          const control = new TestOnReportValidity();
          const onReportValiditySpy = jasmine.createSpy('onReportValidity');
          control[onReportValidity] = onReportValiditySpy;
          const form = document.createElement('form');
          form.appendChild(control);
          document.body.appendChild(form);

          control.required = true;
          form.reportValidity();
          onReportValiditySpy.calls.reset();

          // Fix invalid
          control.checked = true;

          form.reportValidity();
          form.remove();

          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form.requestSubmit() is called after fixing invalid', () => {
          const control = new TestOnReportValidity();
          const onReportValiditySpy = jasmine.createSpy('onReportValidity');
          control[onReportValidity] = onReportValiditySpy;
          const form = document.createElement('form');
          form.appendChild(control);
          document.body.appendChild(form);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          form.reportValidity();
          onReportValiditySpy.calls.reset();

          // Fix invalid
          control.checked = true;

          // Submit imperatively
          form.requestSubmit();
          form.remove();

          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form.requestSubmit() is called after fixing invalid, but another sibling is invalid', () => {
          const control = new TestOnReportValidity();
          const onReportValiditySpy = jasmine.createSpy('onReportValidity');
          control[onReportValidity] = onReportValiditySpy;
          const form = document.createElement('form');
          form.appendChild(control);

          const invalidSibling = document.createElement('input');
          invalidSibling.required = true;
          form.appendChild(invalidSibling);

          document.body.appendChild(form);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          form.reportValidity();
          onReportValiditySpy.calls.reset();

          // Fix invalid
          control.checked = true;

          // Submit imperatively
          form.requestSubmit();
          form.remove();

          expect(invalidSibling.validity.valid)
            .withContext('sibling is invalid')
            .toBeFalse();
          expect(control[onReportValidity]).toHaveBeenCalledWith(null);
        });

        it('should be called with null when form submits declaratively after fixing invalid', () => {
          const control = new TestOnReportValidity();
          const onReportValiditySpy = jasmine.createSpy('onReportValidity');
          control[onReportValidity] = onReportValiditySpy;
          const form = document.createElement('form');
          form.appendChild(control);
          const submitButton = document.createElement('button');
          form.appendChild(submitButton);
          document.body.appendChild(form);
          form.addEventListener(
            'submit',
            (event) => {
              // Prevent the test page from actually reloading.
              event.preventDefault();
            },
            {capture: true},
          );

          control.required = true;
          form.reportValidity();
          onReportValiditySpy.calls.reset();

          // Fix invalid
          control.checked = true;

          // Submit declaratively
          submitButton.click();
          form.remove();

          expect(control[onReportValidity]).toHaveBeenCalledOnceWith(null);
        });

        it('should be called with null when form submits declaratively after fixing invalid, but another sibling is invalid', () => {
          // See above "This is a known limitation" for explanation.
          expect().nothing();
        });
      });

      it('should clean up when form is unassociated and not call when non-parent form.reportValidity() is called', () => {
        const control = new TestOnReportValidity();
        control[onReportValidity] = jasmine.createSpy('onReportValidity');
        const form = document.createElement('form');
        form.appendChild(control);

        form.reportValidity();
        expect(control[onReportValidity])
          .withContext('onReportValidity is called once while attached to form')
          .toHaveBeenCalledTimes(1);

        form.removeChild(control);
        form.reportValidity();
        expect(control[onReportValidity])
          .withContext('onReportValidity is not called a second time')
          .toHaveBeenCalledTimes(1);
      });
    });

    describe('focusing after preventing platform popup', () => {
      it('should focus the control when calling reportValidity()', () => {
        const control = new TestOnReportValidity();
        control[onReportValidity] = (invalidEvent: Event | null) => {
          invalidEvent?.preventDefault();
        };

        spyOn(control, 'focus');

        control.required = true;
        control.reportValidity();
        expect(control.focus)
          .withContext('is focused')
          .toHaveBeenCalledTimes(1);
      });

      it('should only focus the first invalid control of a form', () => {
        const firstControl = new TestOnReportValidity();
        firstControl[onReportValidity] = (invalidEvent: Event | null) => {
          invalidEvent?.preventDefault();
        };

        const secondControl = new TestOnReportValidity();
        secondControl[onReportValidity] = (invalidEvent: Event | null) => {
          invalidEvent?.preventDefault();
        };

        spyOn(firstControl, 'focus');
        spyOn(secondControl, 'focus');

        const form = document.createElement('form');
        form.appendChild(firstControl);
        form.appendChild(secondControl);
        document.body.appendChild(form);

        firstControl.required = true;
        secondControl.required = true;
        form.reportValidity();
        form.remove();

        expect(firstControl.focus)
          .withContext('first control (invalid) is focused')
          .toHaveBeenCalledTimes(1);
        expect(secondControl.focus)
          .withContext('second control (invalid) is not focused')
          .not.toHaveBeenCalled();
      });

      it('should focus the control when calling control.reportValidity(), even if not the first invalid control of a form', () => {
        const firstControl = new TestOnReportValidity();
        firstControl[onReportValidity] = (invalidEvent: Event | null) => {
          invalidEvent?.preventDefault();
        };

        const secondControl = new TestOnReportValidity();
        secondControl[onReportValidity] = (invalidEvent: Event | null) => {
          invalidEvent?.preventDefault();
        };

        spyOn(firstControl, 'focus');
        spyOn(secondControl, 'focus');

        const form = document.createElement('form');
        form.appendChild(firstControl);
        form.appendChild(secondControl);
        document.body.appendChild(form);

        firstControl.required = true;
        secondControl.required = true;
        secondControl.reportValidity();

        expect(firstControl.focus)
          .withContext('first control (invalid) is not focused')
          .not.toHaveBeenCalled();
        expect(secondControl.focus)
          .withContext(
            'second control (invalid, called reportValidity()) is focused',
          )
          .toHaveBeenCalledTimes(1);
      });
    });
  });
});


// ========== /behaviors/validators/checkbox-validator.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Validator} from './validator.js';

/**
 * Constraint validation properties for a checkbox.
 */
export interface CheckboxState {
  /**
   * Whether the checkbox is checked.
   */
  readonly checked: boolean;

  /**
   * Whether the checkbox is required.
   */
  readonly required: boolean;
}

/**
 * A validator that provides constraint validation that emulates
 * `<input type="checkbox">` validation.
 */
export class CheckboxValidator extends Validator<CheckboxState> {
  private checkboxControl?: HTMLInputElement;

  protected override computeValidity(state: CheckboxState) {
    if (!this.checkboxControl) {
      // Lazily create the platform input
      this.checkboxControl = document.createElement('input');
      this.checkboxControl.type = 'checkbox';
    }

    this.checkboxControl.checked = state.checked;
    this.checkboxControl.required = state.required;
    return {
      validity: this.checkboxControl.validity,
      validationMessage: this.checkboxControl.validationMessage,
    };
  }

  protected override equals(prev: CheckboxState, next: CheckboxState) {
    return prev.checked === next.checked && prev.required === next.required;
  }

  protected override copy({checked, required}: CheckboxState) {
    return {checked, required};
  }
}


// ========== /behaviors/validators/checkbox-validator_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {CheckboxValidator} from './checkbox-validator.js';

describe('CheckboxValidator', () => {
  it('is invalid when required and not checked', () => {
    const state = {
      required: true,
      checked: false,
    };

    const validator = new CheckboxValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
    expect(validationMessage).withContext('validationMessage').not.toBe('');
  });

  it('is valid when required and checked', () => {
    const state = {
      required: true,
      checked: true,
    };

    const validator = new CheckboxValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });

  it('is valid when not required', () => {
    const state = {
      required: false,
      checked: false,
    };

    const validator = new CheckboxValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });
});


// ========== /behaviors/validators/radio-validator.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Validator} from './validator.js';

/**
 * Constraint validation properties for a radio.
 */
export interface RadioState {
  /**
   * Whether the radio is checked.
   */
  readonly checked: boolean;

  /**
   * Whether the radio is required.
   */
  readonly required: boolean;
}

/**
 * Radio constraint validation properties for a single radio and its siblings.
 */
export type RadioGroupState = readonly [RadioState, ...RadioState[]];

/**
 * A validator that provides constraint validation that emulates
 * `<input type="radio">` validation.
 */
export class RadioValidator extends Validator<RadioGroupState> {
  private radioElement?: HTMLInputElement;

  protected override computeValidity(states: RadioGroupState) {
    if (!this.radioElement) {
      // Lazily create the radio element
      this.radioElement = document.createElement('input');
      this.radioElement.type = 'radio';
      // A name is required for validation to run
      this.radioElement.name = 'group';
    }

    let isRequired = false;
    let isChecked = false;
    for (const {checked, required} of states) {
      if (required) {
        isRequired = true;
      }

      if (checked) {
        isChecked = true;
      }
    }

    // Firefox v119 doesn't compute grouped radio validation correctly while
    // they are detached from the DOM, which is why we don't render multiple
    // virtual <input>s. Instead, we can check the required/checked states and
    // grab the i18n'd validation message if the value is missing.
    this.radioElement.checked = isChecked;
    this.radioElement.required = isRequired;
    return {
      validity: {
        valueMissing: isRequired && !isChecked,
      },
      validationMessage: this.radioElement.validationMessage,
    };
  }

  protected override equals(
    prevGroup: RadioGroupState,
    nextGroup: RadioGroupState,
  ) {
    if (prevGroup.length !== nextGroup.length) {
      return false;
    }

    for (let i = 0; i < prevGroup.length; i++) {
      const prev = prevGroup[i];
      const next = nextGroup[i];
      if (prev.checked !== next.checked || prev.required !== next.required) {
        return false;
      }
    }

    return true;
  }

  protected override copy(states: RadioGroupState): RadioGroupState {
    // Cast as unknown since typescript does not have enough information to
    // infer that the array always has at least one element.
    return states.map(({checked, required}) => ({
      checked,
      required,
    })) as unknown as RadioGroupState;
  }
}


// ========== /behaviors/validators/radio-validator_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {RadioValidator} from './radio-validator.js';

describe('RadioValidator', () => {
  it('is invalid when required and no radios are checked', () => {
    const states = [
      {
        required: true,
        checked: false,
      },
      {
        required: true,
        checked: false,
      },
      {
        required: true,
        checked: false,
      },
    ] as const;

    const validator = new RadioValidator(() => states);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
    expect(validationMessage).withContext('validationMessage').not.toBe('');
  });

  it('is invalid when any radio is required and no radios are checked', () => {
    const states = [
      {
        required: false,
        checked: false,
      },
      {
        required: true,
        checked: false,
      },
      {
        required: false,
        checked: false,
      },
    ] as const;

    const validator = new RadioValidator(() => states);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
    expect(validationMessage).withContext('validationMessage').not.toBe('');
  });

  it('is valid when required and any radio is checked', () => {
    const states = [
      {
        required: true,
        checked: false,
      },
      {
        required: true,
        checked: true,
      },
      {
        required: true,
        checked: false,
      },
    ] as const;

    const validator = new RadioValidator(() => states);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });

  it('is valid when required and multiple radios are checked', () => {
    const states = [
      {
        required: true,
        checked: false,
      },
      {
        required: true,
        checked: true,
      },
      {
        required: true,
        checked: true,
      },
    ] as const;

    const validator = new RadioValidator(() => states);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });

  it('is valid when not required', () => {
    const states = [
      {
        required: false,
        checked: false,
      },
      {
        required: false,
        checked: false,
      },
      {
        required: false,
        checked: false,
      },
    ] as const;

    const validator = new RadioValidator(() => states);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });
});


// ========== /behaviors/validators/select-validator.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, render} from 'lit';

import {Validator} from './validator.js';

/**
 * Constraint validation properties for a select dropdown.
 */
export interface SelectState {
  /**
   * The current selected value.
   */
  readonly value: string;

  /**
   * Whether the select is required.
   */
  readonly required: boolean;
}

/**
 * A validator that provides constraint validation that emulates `<select>`
 * validation.
 */
export class SelectValidator extends Validator<SelectState> {
  private selectControl?: HTMLSelectElement;

  protected override computeValidity(state: SelectState) {
    if (!this.selectControl) {
      // Lazily create the platform select
      this.selectControl = document.createElement('select');
    }

    render(html`<option value=${state.value}></option>`, this.selectControl);

    this.selectControl.value = state.value;
    this.selectControl.required = state.required;
    return {
      validity: this.selectControl.validity,
      validationMessage: this.selectControl.validationMessage,
    };
  }

  protected override equals(prev: SelectState, next: SelectState) {
    return prev.value === next.value && prev.required === next.required;
  }

  protected override copy({value, required}: SelectState) {
    return {value, required};
  }
}


// ========== /behaviors/validators/select-validator_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {SelectValidator} from './select-validator.js';

describe('SelectValidator', () => {
  it('is invalid when required and value is empty', () => {
    const state = {
      required: true,
      value: '',
    };

    const validator = new SelectValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
    expect(validationMessage).withContext('validationMessage').not.toBe('');
  });

  it('is valid when required and value is provided', () => {
    const state = {
      required: true,
      value: 'Foo',
    };

    const validator = new SelectValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });

  it('is valid when not required', () => {
    const state = {
      required: false,
      value: '',
    };

    const validator = new SelectValidator(() => state);
    const {validity, validationMessage} = validator.getValidity();
    expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
    expect(validationMessage).withContext('validationMessage').toBe('');
  });
});


// ========== /behaviors/validators/text-field-validator.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Validator} from './validator.js';

/**
 * Constraint validation for a text field.
 */
export interface TextFieldState {
  /**
   * The input or textarea state to validate.
   */
  state: InputState | TextAreaState;

  /**
   * The `<input>` or `<textarea>` that is rendered on the page.
   *
   * `minlength` and `maxlength` validation do not apply until a user has
   * interacted with the control and the element is internally marked as dirty.
   * This is a spec quirk, the two properties behave differently from other
   * constraint validation.
   *
   * This means we need an actual rendered element instead of a virtual one,
   * since the virtual element will never be marked as dirty.
   *
   * This can be `null` if the element has not yet rendered, and the validator
   * will fall back to virtual elements for other constraint validation
   * properties, which do apply even if the control is not dirty.
   */
  renderedControl: HTMLInputElement | HTMLTextAreaElement | null;
}

/**
 * Constraint validation properties for an `<input>`.
 */
export interface InputState extends SharedInputAndTextAreaState {
  /**
   * The `<input>` type.
   *
   * Not all constraint validation properties apply to every type. See
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Constraint_validation#validation-related_attributes
   * for which properties will apply to which types.
   */
  readonly type: string;

  /**
   * The regex pattern a value must match.
   */
  readonly pattern: string;

  /**
   * The minimum value.
   */
  readonly min: string;

  /**
   * The maximum value.
   */
  readonly max: string;

  /**
   * The step interval of the value.
   */
  readonly step: string;
}

/**
 * Constraint validation properties for a `<textarea>`.
 */
export interface TextAreaState extends SharedInputAndTextAreaState {
  /**
   * The type, must be "textarea" to inform the validator to use `<textarea>`
   * instead of `<input>`.
   */
  readonly type: 'textarea';
}

/**
 * Constraint validation properties shared between an `<input>` and
 * `<textarea>`.
 */
interface SharedInputAndTextAreaState {
  /**
   * The current value.
   */
  readonly value: string;

  /**
   * Whether the textarea is required.
   */
  readonly required: boolean;

  /**
   * The minimum length of the value.
   */
  readonly minLength: number;

  /**
   * The maximum length of the value.
   */
  readonly maxLength: number;
}

/**
 * A validator that provides constraint validation that emulates `<input>` and
 * `<textarea>` validation.
 */
export class TextFieldValidator extends Validator<TextFieldState> {
  private inputControl?: HTMLInputElement;
  private textAreaControl?: HTMLTextAreaElement;

  protected override computeValidity({state, renderedControl}: TextFieldState) {
    let inputOrTextArea = renderedControl;
    if (isInputState(state) && !inputOrTextArea) {
      // Get cached <input> or create it.
      inputOrTextArea = this.inputControl || document.createElement('input');
      // Cache the <input> to re-use it next time.
      this.inputControl = inputOrTextArea;
    } else if (!inputOrTextArea) {
      // Get cached <textarea> or create it.
      inputOrTextArea =
        this.textAreaControl || document.createElement('textarea');
      // Cache the <textarea> to re-use it next time.
      this.textAreaControl = inputOrTextArea;
    }

    // Set this variable so we can check it for input-specific properties.
    const input = isInputState(state)
      ? (inputOrTextArea as HTMLInputElement)
      : null;

    // Set input's "type" first, since this can change the other properties
    if (input) {
      input.type = state.type;
    }

    if (inputOrTextArea.value !== state.value) {
      // Only programmatically set the value if there's a difference. When using
      // the rendered control, the value will always be up to date. Setting the
      // property (even if it's the same string) will reset the internal <input>
      // dirty flag, making minlength and maxlength validation reset.
      inputOrTextArea.value = state.value;
    }

    inputOrTextArea.required = state.required;

    // The following IDLAttribute properties will always hydrate an attribute,
    // even if set to a the default value ('' or -1). The presence of the
    // attribute triggers constraint validation, so we must remove the attribute
    // when empty.
    if (input) {
      const inputState = state as InputState;
      if (inputState.pattern) {
        input.pattern = inputState.pattern;
      } else {
        input.removeAttribute('pattern');
      }

      if (inputState.min) {
        input.min = inputState.min;
      } else {
        input.removeAttribute('min');
      }

      if (inputState.max) {
        input.max = inputState.max;
      } else {
        input.removeAttribute('max');
      }

      if (inputState.step) {
        input.step = inputState.step;
      } else {
        input.removeAttribute('step');
      }
    }

    // Use -1 to represent no minlength and maxlength, which is what the
    // platform input returns. However, it will throw an error if you try to
    // manually set it to -1.
    //
    // While the type is `number`, it may actually be `null` at runtime.
    // `null > -1` is true since `null` coerces to `0`, so we default null and
    // undefined to -1.
    //
    // We set attributes instead of properties since setting a property may
    // throw an out of bounds error in relation to the other property.
    // Attributes will not throw errors while the state is updating.
    if ((state.minLength ?? -1) > -1) {
      inputOrTextArea.setAttribute('minlength', String(state.minLength));
    } else {
      inputOrTextArea.removeAttribute('minlength');
    }

    if ((state.maxLength ?? -1) > -1) {
      inputOrTextArea.setAttribute('maxlength', String(state.maxLength));
    } else {
      inputOrTextArea.removeAttribute('maxlength');
    }

    return {
      validity: inputOrTextArea.validity,
      validationMessage: inputOrTextArea.validationMessage,
    };
  }

  protected override equals(
    {state: prev}: TextFieldState,
    {state: next}: TextFieldState,
  ) {
    // Check shared input and textarea properties
    const inputOrTextAreaEqual =
      prev.type === next.type &&
      prev.value === next.value &&
      prev.required === next.required &&
      prev.minLength === next.minLength &&
      prev.maxLength === next.maxLength;

    if (!isInputState(prev) || !isInputState(next)) {
      // Both are textareas, all relevant properties are equal.
      return inputOrTextAreaEqual;
    }

    // Check additional input-specific properties.
    return (
      inputOrTextAreaEqual &&
      prev.pattern === next.pattern &&
      prev.min === next.min &&
      prev.max === next.max &&
      prev.step === next.step
    );
  }

  protected override copy({state}: TextFieldState): TextFieldState {
    // Don't hold a reference to the rendered control when copying since we
    // don't use it when checking if the state changed.
    return {
      state: isInputState(state)
        ? this.copyInput(state)
        : this.copyTextArea(state),
      renderedControl: null,
    };
  }

  private copyInput(state: InputState): InputState {
    const {type, pattern, min, max, step} = state;
    return {
      ...this.copySharedState(state),
      type,
      pattern,
      min,
      max,
      step,
    };
  }

  private copyTextArea(state: TextAreaState): TextAreaState {
    return {
      ...this.copySharedState(state),
      type: state.type,
    };
  }

  private copySharedState({
    value,
    required,
    minLength,
    maxLength,
  }: SharedInputAndTextAreaState): SharedInputAndTextAreaState {
    return {value, required, minLength, maxLength};
  }
}

function isInputState(state: InputState | TextAreaState): state is InputState {
  return state.type !== 'textarea';
}


// ========== /behaviors/validators/text-field-validator_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {
  InputState,
  TextAreaState,
  TextFieldValidator,
} from './text-field-validator.js';

// Note: minlength and maxlength validation can NOT be tested programmatically.
// These properties will not trigger constraint validation until a user has
// interacted with the <input> or <textarea> and it marks itself as dirty.
// It's a spec quirk that these two properties behave differently, and
// unfortunately we cannot test them.

describe('TextFieldValidator', () => {
  // These types all have the same "text"-like validation
  describe('type="text", "password", "search", "tel", "url"', () => {
    it('is invalid when required and empty', () => {
      const state: InputState = {
        type: 'text',
        value: '',
        required: true,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is valid when required and not empty', () => {
      const state: InputState = {
        type: 'text',
        value: 'Value',
        required: true,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });

    it('is valid when not required and empty', () => {
      const state: InputState = {
        type: 'text',
        value: '',
        required: false,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });

    it('does not throw an error when setting minlength and maxlength out of bounds', () => {
      type WritableInputState = {
        -readonly [K in keyof InputState]: InputState[K];
      };

      const state: WritableInputState = {
        type: 'text',
        value: '',
        required: true,
        pattern: '',
        min: '',
        max: '',
        minLength: 5,
        maxLength: 10,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      // Compute initial validity with valid minlength of 5 and maxlength of 10
      validator.getValidity();
      // set to something that is out of bounds of current maxlength="10"
      state.minLength = 20;

      expect(() => {
        validator.getValidity();
      }).not.toThrow();
    });
  });

  describe('type="email"', () => {
    it('is invalid when not matching default email pattern', () => {
      const state: InputState = {
        type: 'email',
        value: 'invalid',
        required: false,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.typeMismatch).withContext('typeMismatch').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is valid when matching default email pattern', () => {
      const state: InputState = {
        type: 'email',
        value: 'valid@google.com',
        required: false,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.typeMismatch).withContext('typeMismatch').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });
  });

  describe('type="number"', () => {
    it('is invalid when value is less than min', () => {
      const state: InputState = {
        type: 'number',
        value: '1',
        required: false,
        pattern: '',
        min: '5',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.rangeUnderflow).withContext('rangeUnderflow').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is invalid when value is greater than max', () => {
      const state: InputState = {
        type: 'number',
        value: '10',
        required: false,
        pattern: '',
        min: '',
        max: '5',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.rangeOverflow).withContext('rangeOverflow').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is valid when value is between min and max', () => {
      const state: InputState = {
        type: 'number',
        value: '3',
        required: false,
        pattern: '',
        min: '1',
        max: '5',
        minLength: -1,
        maxLength: -1,
        step: '',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.rangeUnderflow).withContext('rangeUnderflow').toBeFalse();
      expect(validity.rangeOverflow).withContext('rangeOverflow').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });

    it('is invalid when value does not match step', () => {
      const state: InputState = {
        type: 'number',
        value: '2',
        required: false,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '5',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.stepMismatch).withContext('stepMismatch').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is valid when value matches step', () => {
      const state: InputState = {
        type: 'number',
        value: '20',
        required: false,
        pattern: '',
        min: '',
        max: '',
        minLength: -1,
        maxLength: -1,
        step: '5',
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.stepMismatch).withContext('stepMismatch').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });
  });

  describe('type="textarea"', () => {
    it('is invalid when required and empty', () => {
      const state: TextAreaState = {
        type: 'textarea',
        value: '',
        required: true,
        minLength: -1,
        maxLength: -1,
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeTrue();
      expect(validationMessage).withContext('validationMessage').not.toBe('');
    });

    it('is valid when required and not empty', () => {
      const state: TextAreaState = {
        type: 'textarea',
        value: 'Value',
        required: true,
        minLength: -1,
        maxLength: -1,
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });

    it('is valid when not required and empty', () => {
      const state: TextAreaState = {
        type: 'textarea',
        value: '',
        required: false,
        minLength: -1,
        maxLength: -1,
      };

      const validator = new TextFieldValidator(() => ({
        state,
        renderedControl: null,
      }));

      const {validity, validationMessage} = validator.getValidity();
      expect(validity.valueMissing).withContext('valueMissing').toBeFalse();
      expect(validationMessage).withContext('validationMessage').toBe('');
    });
  });
});


// ========== /behaviors/validators/validator.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * A class that computes and caches `ValidityStateFlags` for a component with
 * a given `State` interface.
 *
 * Cached performance before computing validity is important since constraint
 * validation must be checked frequently and synchronously when properties
 * change.
 *
 * @template State The expected interface of properties relevant to constraint
 *     validation.
 */
export abstract class Validator<State> {
  /**
   * The previous state, used to determine if state changed and validation needs
   * to be re-computed.
   */
  private prevState?: State;

  /**
   * The current validity state and message. This is cached and returns if
   * constraint validation state does not change.
   */
  private currentValidity: ValidityAndMessage = {
    validity: {},
    validationMessage: '',
  };

  /**
   * Creates a new validator.
   *
   * @param getCurrentState A callback that returns the current state of
   *     constraint validation-related properties.
   */
  constructor(private readonly getCurrentState: () => State) {}

  /**
   * Returns the current `ValidityStateFlags` and validation message for the
   * validator.
   *
   * If the constraint validation state has not changed, this will return a
   * cached result. This is important since `getValidity()` can be called
   * frequently in response to synchronous property changes.
   *
   * @return The current validity and validation message.
   */
  getValidity(): ValidityAndMessage {
    const state = this.getCurrentState();
    const hasStateChanged =
      !this.prevState || !this.equals(this.prevState, state);
    if (!hasStateChanged) {
      return this.currentValidity;
    }

    const {validity, validationMessage} = this.computeValidity(state);
    this.prevState = this.copy(state);
    this.currentValidity = {
      validationMessage,
      validity: {
        // Change any `ValidityState` instances into `ValidityStateFlags` since
        // `ValidityState` cannot be easily `{...spread}`.
        badInput: validity.badInput,
        customError: validity.customError,
        patternMismatch: validity.patternMismatch,
        rangeOverflow: validity.rangeOverflow,
        rangeUnderflow: validity.rangeUnderflow,
        stepMismatch: validity.stepMismatch,
        tooLong: validity.tooLong,
        tooShort: validity.tooShort,
        typeMismatch: validity.typeMismatch,
        valueMissing: validity.valueMissing,
      },
    };

    return this.currentValidity;
  }

  /**
   * Computes the `ValidityStateFlags` and validation message for a given set
   * of constraint validation properties.
   *
   * Implementations can use platform elements like `<input>` and `<select>` to
   * sync state and compute validation along with i18n'd messages. This function
   * may be expensive, and is only called when state changes.
   *
   * @param state The new state of constraint validation properties.
   * @return An object containing a `validity` property with
   *     `ValidityStateFlags` and a `validationMessage` property.
   */
  protected abstract computeValidity(state: State): ValidityAndMessage;

  /**
   * Checks if two states are equal. This is used to check against cached state
   * to see if validity needs to be re-computed.
   *
   * @param prev The previous state.
   * @param next The next state.
   * @return True if the states are equal, or false if not.
   */
  protected abstract equals(prev: State, next: State): boolean;

  /**
   * Creates a copy of a state. This is used to cache state and check if it
   * changes.
   *
   * Note: do NOT spread the {...state} to copy it. The actual state object is
   * a web component, and trying to spread its getter/setter properties won't
   * work.
   *
   * @param state The state to copy.
   * @return A copy of the state.
   */
  protected abstract copy(state: State): State;
}

/**
 * An object containing `ValidityStateFlags` and a corresponding validation
 * message.
 */
export interface ValidityAndMessage {
  /**
   * Validity flags.
   */
  validity: ValidityStateFlags;

  /**
   * The validation message for the associated flags. It may not be an empty
   * string if any of the validity flags are `true`.
   */
  validationMessage: string;
}


// ========== /behaviors/validators/validator_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {Validator} from './validator.js';

describe('Validator', () => {
  interface CustomState {
    value: string;
    required: boolean;
  }

  class CustomValidator extends Validator<CustomState> {
    computeValidity({required, value}: CustomState) {
      const valueMissing = required && !value;
      return {
        validity: {valueMissing},
        validationMessage: valueMissing ? 'Value missing' : '',
      };
    }

    equals(prev: CustomState, next: CustomState) {
      return prev.value === next.value && prev.required === next.required;
    }

    copy({value, required}: CustomState) {
      return {value, required};
    }
  }

  describe('getValidity()', () => {
    // Quick E2E test of our CustomValidator to make sure the logic is hooked up
    it('should return the expected validity', () => {
      const currentState = {
        value: '',
        required: false,
      };

      const validator = new CustomValidator(() => currentState);

      expect(validator.getValidity()).toEqual({
        validity: jasmine.objectContaining({valueMissing: false}),
        validationMessage: '',
      });

      currentState.required = true;
      expect(validator.getValidity()).toEqual({
        validity: jasmine.objectContaining({valueMissing: true}),
        validationMessage: 'Value missing',
      });

      currentState.value = 'Foo';
      expect(validator.getValidity()).toEqual({
        validity: jasmine.objectContaining({valueMissing: false}),
        validationMessage: '',
      });
    });

    it('should compute validity when first called', () => {
      const currentState = {
        value: '',
        required: false,
      };

      const validator = new CustomValidator(() => currentState);
      spyOn(validator, 'computeValidity').and.callThrough();

      validator.getValidity();
      expect(validator.computeValidity)
        .withContext('computeValidity() called')
        .toHaveBeenCalledTimes(1);
    });

    it('should compute and return validity when state changes', () => {
      const currentState = {
        value: '',
        required: false,
      };

      const validator = new CustomValidator(() => currentState);
      // Get initial validity, which always computes
      validator.getValidity();

      spyOn(validator, 'computeValidity').and.callThrough();
      // Change the state, should re-compute
      currentState.value = 'Changed value';
      validator.getValidity();

      expect(validator.computeValidity)
        .withContext('computeValidity() called')
        .toHaveBeenCalledTimes(1);
    });

    it('should not compute and return cached validity when state does not change', () => {
      const currentState = {
        value: '',
        required: false,
      };

      const validator = new CustomValidator(() => currentState);
      // Get initial validity, which always computes
      validator.getValidity();

      spyOn(validator, 'computeValidity').and.callThrough();
      // Don't change state
      validator.getValidity();

      expect(validator.computeValidity)
        .withContext('computeValidity() called')
        .not.toHaveBeenCalled();
    });
  });
});


/* ========== /card/_elevated-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/elevated-card' show theme;


/* ========== /card/_filled-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/filled-card' show theme;


/* ========== /card/_outlined-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/outlined-card' show theme;


// ========== /card/elevated-card.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Card} from './internal/card.js';
import {styles as elevatedStyles} from './internal/elevated-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-elevated-card': MdElevatedCard;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-elevated-card')
export class MdElevatedCard extends Card {
  static override styles: CSSResultOrNative[] = [sharedStyles, elevatedStyles];
}


// ========== /card/elevated-card_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../../testing/tokens.js';

import {MdElevatedCard} from './elevated-card.js';

describe('<md-elevated-card>', () => {
  describe('.styles', () => {
    createTokenTests(MdElevatedCard.styles);
  });
});


// ========== /card/filled-card.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Card} from './internal/card.js';
import {styles as filledStyles} from './internal/filled-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-filled-card': MdFilledCard;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-filled-card')
export class MdFilledCard extends Card {
  static override styles: CSSResultOrNative[] = [sharedStyles, filledStyles];
}


// ========== /card/filled-card_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../../testing/tokens.js';

import {MdFilledCard} from './filled-card.js';

describe('<md-filled-card>', () => {
  describe('.styles', () => {
    createTokenTests(MdFilledCard.styles);
  });
});


/* ========== /card/internal/_elevated-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-elevated-card-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Elevated card `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-elevated-card-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-elevated-card-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }
}


/* ========== /card/internal/_filled-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-filled-card-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Filled card `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-filled-card-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-filled-card-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }
}


/* ========== /card/internal/_outlined-card.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-outlined-card-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Outlined card `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-card-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-card-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .outline {
    border-color: var(--_outline-color);
    border-width: var(--_outline-width);
  }
}


/* ========== /card/internal/_shared.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use '../../../elevation/elevation';
// go/keep-sorted end

@mixin styles() {
  :host {
    border-radius: var(--_container-shape);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    position: relative;
    // Reset z-index for background elements.
    z-index: 0;
  }

  md-elevation,
  .background,
  .outline {
    border-radius: inherit;
    inset: 0;
    pointer-events: none;
    position: absolute;
  }

  // Separate element will be needed for disabled opacities (b/307361748)
  .background {
    background: var(--_container-color);
    // Place behind content.
    z-index: -1;
  }

  // Separate element needed to overlay on top of content as opposed to
  // background, which is behind content. All cards have an outline for HCM.
  .outline {
    // A default transparent border that is visible in HCM
    border: 1px solid transparent;
    // Outline should be placed on top of content, such as images.
    z-index: 1;
  }

  md-elevation {
    // Place behind content.
    z-index: -1;

    @include elevation.theme(
      (
        'level': var(--_container-elevation),
        'shadow-color': var(--_container-shadow-color),
      )
    );
  }

  slot {
    // Allow content to inherit card's border radius
    border-radius: inherit;
  }
}


// ========== /card/internal/card.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../elevation/elevation.js';

import {html, LitElement} from 'lit';

/**
 * A card component.
 */
export class Card extends LitElement {
  protected override render() {
    return html`
      <md-elevation part="elevation"></md-elevation>
      <div class="background"></div>
      <slot></slot>
      <div class="outline"></div>
    `;
  }
}


/* ========== /card/internal/elevated-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './elevated-card';
// go/keep-sorted end

@include elevated-card.styles;


/* ========== /card/internal/filled-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './filled-card';
// go/keep-sorted end

@include filled-card.styles;


/* ========== /card/internal/outlined-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-card';
// go/keep-sorted end

@include outlined-card.styles;


/* ========== /card/internal/shared-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /card/outlined-card.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Card} from './internal/card.js';
import {styles as outlinedStyles} from './internal/outlined-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-card': MdOutlinedCard;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-card')
export class MdOutlinedCard extends Card {
  static override styles: CSSResultOrNative[] = [sharedStyles, outlinedStyles];
}


// ========== /card/outlined-card_test.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {createTokenTests} from '../../testing/tokens.js';

import {MdOutlinedCard} from './outlined-card.js';

describe('<md-outlined-card>', () => {
  describe('.styles', () => {
    createTokenTests(MdOutlinedCard.styles);
  });
});


/* ========== /item/internal/_item.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

/// `<md-item>` does not provide `--md-item-*` custom properties. Instead, use
/// CSS on slotted elements to change their styles.
///
/// @example css
///   md-item {
///     color: var(--headline-color);
///     font: var(--headline-font);
///   }
///   md-item [slot='supporting-text'] {
///     color: var(--supporting-text-color);
///     font: var(--supporting-text-font);
///   }
///   // ...
///
@mixin styles() {
  $tokens: tokens.md-comp-item-values();

  :host {
    color: map.get($tokens, 'label-text-color');
    font-family: map.get($tokens, 'label-text-font');
    font-size: map.get($tokens, 'label-text-size');
    font-weight: map.get($tokens, 'label-text-weight');
    line-height: map.get($tokens, 'label-text-line-height');
    align-items: center;
    box-sizing: border-box;
    display: flex;
    gap: 16px;
    min-height: 56px;
    overflow: hidden;
    padding: 12px 16px;
    position: relative;
    text-overflow: ellipsis;
  }

  :host([multiline]) {
    min-height: 72px;
  }

  [name='overline'] {
    color: map.get($tokens, 'overline-color');
    font-family: map.get($tokens, 'overline-font');
    font-size: map.get($tokens, 'overline-size');
    font-weight: map.get($tokens, 'overline-weight');
    line-height: map.get($tokens, 'overline-line-height');
  }

  [name='supporting-text'] {
    color: map.get($tokens, 'supporting-text-color');
    font-family: map.get($tokens, 'supporting-text-font');
    font-size: map.get($tokens, 'supporting-text-size');
    font-weight: map.get($tokens, 'supporting-text-weight');
    line-height: map.get($tokens, 'supporting-text-line-height');
  }

  [name='trailing-supporting-text'] {
    color: map.get($tokens, 'trailing-supporting-text-color');
    font-family: map.get($tokens, 'trailing-supporting-text-font');
    font-size: map.get($tokens, 'trailing-supporting-text-size');
    font-weight: map.get($tokens, 'trailing-supporting-text-weight');
    line-height: map.get($tokens, 'trailing-supporting-text-line-height');
  }

  // A slot for background container elements, such as ripples and focus rings.
  [name='container']::slotted(*) {
    inset: 0;
    position: absolute;
  }

  .default-slot {
    // Needed since the default slot can have just text content, and ellipsis
    // need an inline display.
    display: inline;
  }

  .default-slot,
  .text ::slotted(*) {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .text {
    display: flex;
    flex: 1;
    flex-direction: column;
    overflow: hidden;
  }
}


/* ========== /item/internal/item-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './item';
// go/keep-sorted end

@include item.styles;


// ========== /item/internal/item.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, LitElement} from 'lit';
import {property, queryAll} from 'lit/decorators.js';

/**
 * An item layout component.
 */
export class Item extends LitElement {
  /**
   * Only needed for SSR.
   *
   * Add this attribute when an item has two lines to avoid a Flash Of Unstyled
   * Content. This attribute is not needed for single line items or items with
   * three or more lines.
   */
  @property({type: Boolean, reflect: true}) multiline = false;

  @queryAll('.text slot') private readonly textSlots!: HTMLSlotElement[];

  override render() {
    return html`
      <slot name="container"></slot>
      <slot class="non-text" name="start"></slot>
      <div class="text">
        <slot name="overline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          class="default-slot"
          @slotchange=${this.handleTextSlotChange}></slot>
        <slot name="headline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          name="supporting-text"
          @slotchange=${this.handleTextSlotChange}></slot>
      </div>
      <slot class="non-text" name="trailing-supporting-text"></slot>
      <slot class="non-text" name="end"></slot>
    `;
  }

  private handleTextSlotChange() {
    // Check if there's more than one text slot with content. If so, the item is
    // multiline, which has a different min-height than single line items.
    let isMultiline = false;
    let slotsWithContent = 0;
    for (const slot of this.textSlots) {
      if (slotHasContent(slot)) {
        slotsWithContent += 1;
      }

      if (slotsWithContent > 1) {
        isMultiline = true;
        break;
      }
    }

    this.multiline = isMultiline;
  }
}

function slotHasContent(slot: HTMLSlotElement) {
  for (const node of slot.assignedNodes({flatten: true})) {
    // Assume there's content if there's an element slotted in
    const isElement = node.nodeType === Node.ELEMENT_NODE;
    // If there's only text nodes for the default slot, check if there's
    // non-whitespace.
    const isTextWithContent =
      node.nodeType === Node.TEXT_NODE && node.textContent?.match(/\S/);
    if (isElement || isTextWithContent) {
      return true;
    }
  }

  return false;
}


// ========== /item/item.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Item} from './internal/item.js';
import {styles} from './internal/item-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-item': MdItem;
  }
}

/**
 * An item layout component that can be used inside list items to give them
 * their customizable structure.
 *
 * `<md-item>` does not have any functionality, which must be added by the
 * component using it.
 *
 * All text will wrap unless `white-space: nowrap` is set on the item or any of
 * its children.
 *
 * Slots available:
 * - `<default>`: The headline, or custom content.
 * - `headline`: The first line.
 * - `supporting-text`: Supporting text lines underneath the headline.
 * - `trailing-supporting-text`: A small text snippet at the end of the item.
 * - `start`: Any leading content, such as icons, avatars, or checkboxes.
 * - `end`: Any trailing content, such as icons and buttons.
 * - `container`: Background container content, intended for adding additional
 *     styles, such as ripples or focus rings.
 *
 * @example
 * ```html
 * <md-item>Single line</md-item>
 *
 * <md-item>
 *   <div class="custom-content">...</div>
 * </md-item>
 *
 * <!-- Classic 1 to 3+ line list items -->
 * <md-item>
 *   <md-icon slot="start">image</md-icon>
 *   <div slot="overline">Overline</div>
 *   <div slot="headline">Headline</div>
 *   <div="supporting-text">Supporting text</div>
 *   <div="trailing-supporting-text">Trailing</div>
 *   <md-icon slot="end">image</md-icon>
 * </md-item>
 * ```
 *
 * When wrapping `<md-item>`, forward the available slots to use the same slot
 * structure for the wrapping component (this is what `<md-list-item>` does).
 *
 * @example
 * ```html
 * <md-item>
 *   <slot></slot>
 *   <slot name="overline" slot="overline"></slot>
 *   <slot name="headline" slot="headline"></slot>
 *   <slot name="supporting-text" slot="supporting-text"></slot>
 *   <slot name="trailing-supporting-text"
 *       slot="trailing-supporting-text"></slot>
 *   <slot name="start" slot="start"></slot>
 *   <slot name="end" slot="end"></slot>
 * </md-item>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-item')
export class MdItem extends Item {
  static override styles: CSSResultOrNative[] = [styles];
}


/* ========== /navigationbar/_navigation-bar.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/navigation-bar' show theme;


/* ========== /navigationbar/internal/_navigation-bar.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../elevation/elevation';
@use '../../../tokens';
// go/keep-sorted end

$_md-sys-motion: tokens.md-sys-motion-values();

@mixin theme($tokens) {
  // $supported-tokens: tokens.$md-comp-navigation-bar-supported-tokens;

  @each $token, $value in $tokens {
    // @if list.index($supported-tokens, $token) == null {
    //   @error 'Token `#{$token}` is not a supported token.';
    // }

    @if $value {
      --md-navigation-bar-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-navigation-bar-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    @include elevation.theme(
      (
        'level': var(--_container-elevation),
        'shadow-color': var(--_container-shadow-color),
      )
    );

    width: 100%;
  }

  .md3-navigation-bar {
    display: flex;
    position: relative;
    width: 100%;
    background-color: var(--_container-color);
    border-radius: var(--_container-shape);
    height: var(--_container-height);

    .md3-navigation-bar__tabs-slot-container {
      display: inherit;
      width: inherit;
    }
  }

  md-elevation {
    transition-duration: 280ms;
    transition-timing-function: map.get($_md-sys-motion, 'emphasized-easing');
    z-index: 0;
  }
}


// ========== /navigationbar/internal/constants.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {NavigationTabState} from '../../navigationtab/internal/state.js';

/**
 * MDCNavigationTabInteractionEventDetail provides details for the interaction
 * event.
 */
export interface MDCNavigationTabInteractionEventDetail {
  state: NavigationTabState;
}

/**
 * NavigationTabInteractionEvent is the custom event for the interaction event.
 */
export type NavigationTabInteractionEvent =
  CustomEvent<MDCNavigationTabInteractionEventDetail>;


/* ========== /navigationbar/internal/navigation-bar-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './navigation-bar';
// go/keep-sorted end

@include navigation-bar.styles;


// ========== /navigationbar/internal/navigation-bar.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../elevation/elevation.js';

import {html, LitElement, nothing, PropertyValues} from 'lit';
import {property, queryAssignedElements} from 'lit/decorators.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';
import {isRtl} from '../../../internal/controller/is-rtl.js';
import {NavigationTab} from '../../navigationtab/internal/navigation-tab.js';

import {NavigationTabInteractionEvent} from './constants.js';
import {NavigationBarState} from './state.js';

// Separate variable needed for closure.
const navigationBarBaseClass = mixinDelegatesAria(LitElement);

/**
 * b/265346501 - add docs
 *
 * @fires navigation-bar-activated {CustomEvent<tab: NavigationTab, activeIndex: number>}
 * Dispatched whenever the `activeIndex` changes. --bubbles --composed
 */
export class NavigationBar
  extends navigationBarBaseClass
  implements NavigationBarState
{
  @property({type: Number, attribute: 'active-index'}) activeIndex = 0;

  @property({type: Boolean, attribute: 'hide-inactive-labels'})
  hideInactiveLabels = false;

  tabs: NavigationTab[] = [];

  @queryAssignedElements({flatten: true})
  private readonly tabsElement!: NavigationTab[];

  protected override render() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`<div
      class="md3-navigation-bar"
      role="tablist"
      aria-label=${ariaLabel || nothing}
      @keydown="${this.handleKeydown}"
      @navigation-tab-interaction="${this.handleNavigationTabInteraction}"
      @navigation-tab-rendered=${this.handleNavigationTabConnected}
      ><md-elevation part="elevation"></md-elevation
      ><div class="md3-navigation-bar__tabs-slot-container"><slot></slot></div
    ></div>`;
  }

  protected override updated(changedProperties: PropertyValues<NavigationBar>) {
    if (changedProperties.has('activeIndex')) {
      this.onActiveIndexChange(this.activeIndex);
      this.dispatchEvent(
        new CustomEvent('navigation-bar-activated', {
          detail: {
            tab: this.tabs[this.activeIndex],
            activeIndex: this.activeIndex,
          },
          bubbles: true,
          composed: true,
        }),
      );
    }

    if (changedProperties.has('hideInactiveLabels')) {
      this.onHideInactiveLabelsChange(this.hideInactiveLabels);
    }

    if (changedProperties.has('tabs')) {
      this.onHideInactiveLabelsChange(this.hideInactiveLabels);
      this.onActiveIndexChange(this.activeIndex);
    }
  }

  override firstUpdated(changedProperties: PropertyValues) {
    super.firstUpdated(changedProperties);
    this.layout();
  }

  layout() {
    if (!this.tabsElement) return;
    const navTabs: NavigationTab[] = [];
    for (const node of this.tabsElement) {
      navTabs.push(node);
    }
    this.tabs = navTabs;
  }

  private handleNavigationTabConnected(event: CustomEvent) {
    const target = event.target as NavigationTab;
    if (this.tabs.indexOf(target) === -1) {
      this.layout();
    }
  }

  private handleNavigationTabInteraction(event: NavigationTabInteractionEvent) {
    this.activeIndex = this.tabs.indexOf(event.detail.state as NavigationTab);
  }

  private handleKeydown(event: KeyboardEvent) {
    const key = event.key;
    const focusedTabIndex = this.tabs.findIndex((tab) => {
      return tab.matches(':focus-within');
    });
    const isRTL = isRtl(this);
    const maxIndex = this.tabs.length - 1;

    if (key === 'Enter' || key === ' ') {
      this.activeIndex = focusedTabIndex;
      return;
    }

    if (key === 'Home') {
      this.tabs[0].focus();
      return;
    }

    if (key === 'End') {
      this.tabs[maxIndex].focus();
      return;
    }

    const toNextTab =
      (key === 'ArrowRight' && !isRTL) || (key === 'ArrowLeft' && isRTL);
    if (toNextTab && focusedTabIndex === maxIndex) {
      this.tabs[0].focus();
      return;
    }
    if (toNextTab) {
      this.tabs[focusedTabIndex + 1].focus();
      return;
    }

    const toPreviousTab =
      (key === 'ArrowLeft' && !isRTL) || (key === 'ArrowRight' && isRTL);
    if (toPreviousTab && focusedTabIndex === 0) {
      this.tabs[maxIndex].focus();
      return;
    }
    if (toPreviousTab) {
      this.tabs[focusedTabIndex - 1].focus();
      return;
    }
  }

  private onActiveIndexChange(value: number) {
    if (!this.tabs[value]) {
      throw new Error('NavigationBar: activeIndex is out of bounds.');
    }
    for (let i = 0; i < this.tabs.length; i++) {
      this.tabs[i].active = i === value;
    }
  }

  private onHideInactiveLabelsChange(value: boolean) {
    for (const tab of this.tabs) {
      tab.hideInactiveLabel = value;
    }
  }
}


// ========== /navigationbar/internal/state.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {NavigationTabState} from '../../navigationtab/internal/state.js';

/**
 * The state of a navigation Bar.
 */
export interface NavigationBarState {
  /**
   * Index of the active navigation tab.
   */
  activeIndex: number;
  /**
   * If true, inactive navigation tabs will hide their label.
   */
  hideInactiveLabels: boolean;
  /**
   * An array of the navigation tab states.
   */
  tabs: NavigationTabState[];
}


// ========== /navigationbar/md-navigation-bar_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';
import {customElement} from 'lit/decorators.js';
import {ifDefined} from 'lit/directives/if-defined.js';

import {Environment} from '../../testing/environment.js';
import {NavigationTabHarness} from '../navigationtab/harness.js';
import {MdNavigationTab} from '../navigationtab/navigation-tab.js';

import {NavigationBarHarness} from './harness.js';
import {MdNavigationBar} from './navigation-bar.js';

@customElement('md-test-navigation-bar')
class TestMdNavigationBar extends MdNavigationBar {}
@customElement('md-test-navigation-bar-tab')
class TestMdNavigationTab extends MdNavigationTab {}

declare global {
  interface HTMLElementTagNameMap {
    'md-test-navigation-bar': TestMdNavigationBar;
    'md-test-navigation-bar-tab': TestMdNavigationTab;
  }
}

interface NavigationBarProps {
  activeIndex: number;
  hideInactiveLabels: boolean;
  ariaLabel?: string;
}

const defaultNavBar = html`
  <md-test-navigation-bar>
    <md-test-navigation-bar-tab label="One"></md-test-navigation-bar-tab>
  </md-test-navigation-bar>
`;

const navBarWithNavTabsElement = (propsInit: Partial<NavigationBarProps>) => {
  return html`
    <md-test-navigation-bar
      .activeIndex="${propsInit.activeIndex ?? 0}"
      .hideInactiveLabels="${propsInit.hideInactiveLabels === true}"
      aria-label="${ifDefined(propsInit.ariaLabel)}">
      <md-test-navigation-bar-tab label="One"></md-test-navigation-bar-tab>
      <md-test-navigation-bar-tab label="Two"></md-test-navigation-bar-tab>
    </md-test-navigation-bar>
  `;
};

// The following is a Navbar with the tabs being out of sync with the bar.
const navBarWithIncorrectTabsElement = html` <md-test-navigation-bar
  activeIndex="0">
  <md-test-navigation-bar-tab
    label="One"
    hideInactiveLabel></md-test-navigation-bar-tab>
  <md-test-navigation-bar-tab label="One" active></md-test-navigation-bar-tab>
</md-test-navigation-bar>`;

describe('md-navigation-bar', () => {
  const env = new Environment();

  async function setupTest(template = defaultNavBar) {
    const element = env
      .render(template)
      .querySelector('md-test-navigation-bar');
    if (!element) {
      throw new Error('Could not query rendered <md-test-navigation-bar>.');
    }

    await env.waitForStability();

    return {
      harness: new NavigationBarHarness(element),
    };
  }

  describe('basic', () => {
    it('initializes as a md-navigation-bar', async () => {
      const {harness} = await setupTest();
      const navBarBase = harness.element.shadowRoot!.querySelector(
        '.md3-navigation-bar',
      )!;
      expect(harness.element).toBeInstanceOf(MdNavigationBar);
      expect(harness.element.activeIndex).toEqual(0);
      expect(harness.element.hideInactiveLabels).toBeFalse();
      expect(navBarBase.getAttribute('aria-label')).toEqual(null);
    });
  });

  describe('activeIndex', () => {
    it('on change emits activated event', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 1}),
      );
      const activatedHandler = jasmine.createSpy();
      harness.element.addEventListener(
        'navigation-bar-activated',
        activatedHandler,
      );
      harness.element.activeIndex = 0;
      await env.waitForStability();
      expect(activatedHandler).toHaveBeenCalled();
    });

    it('activated event detail contains the tab and activeIndex', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 1}),
      );
      const navigationBarActivatedSpy = jasmine.createSpy(
        'navigationBarActivated',
      );
      harness.element.addEventListener(
        'navigation-bar-activated',
        navigationBarActivatedSpy,
      );

      const tab = harness.element.tabs[0];
      harness.element.activeIndex = 0;

      await env.waitForStability();
      expect(navigationBarActivatedSpy).toHaveBeenCalledWith(
        jasmine.any(CustomEvent),
      );
      expect(navigationBarActivatedSpy).toHaveBeenCalledWith(
        jasmine.objectContaining({
          detail: jasmine.objectContaining({tab, activeIndex: 0}),
        }),
      );
    });

    it('#handleNavigationTabInteraction () updates on navigation tab click', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 1}),
      );
      const tab1Harness = new NavigationTabHarness(harness.element.tabs[0]);
      const tab2Harness = new NavigationTabHarness(harness.element.tabs[1]);

      await tab1Harness.clickWithMouse();
      expect(harness.element.activeIndex).toEqual(0);
      await tab2Harness.clickWithMouse();
      expect(harness.element.activeIndex).toEqual(1);
    });

    it('#onActiveIndexChange() sets tab at activeIndex to active', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 1}),
      );
      const tab = harness.element.tabs[0];
      expect(tab.active).toBeFalse();
      harness.element.activeIndex = 0;
      harness.element.requestUpdate();
      await env.waitForStability();
      expect(tab.active).toBeTrue();
    });

    it('#onActiveIndexChange() sets previously active tab to inactive', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 1}),
      );
      const tab = harness.element.tabs[1];
      expect(tab.active).toBeTrue();
      harness.element.activeIndex = 0;
      harness.element.requestUpdate();
      await env.waitForStability();
      expect(tab.active).toBeFalse();
    });
  });

  describe('hideInactiveLabels', () => {
    it('#onHideInactiveLabelsChange() affects navigation tabs hideInactiveLabel state', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({hideInactiveLabels: true}),
      );
      const tab1 = harness.element.tabs[0];
      const tab2 = harness.element.tabs[1];
      expect(tab1.hideInactiveLabel).toBeTrue();
      expect(tab2.hideInactiveLabel).toBeTrue();
      harness.element.hideInactiveLabels = false;
      harness.element.requestUpdate();
      await env.waitForStability();
      expect(tab1.hideInactiveLabel).toBeFalse();
      expect(tab2.hideInactiveLabel).toBeFalse();
    });
  });

  describe('aria-label', () => {
    it('sets the root aria-label property', async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({ariaLabel: 'foo'}),
      );
      const navBarBase = harness.element.shadowRoot!.querySelector(
        '.md3-navigation-bar',
      )!;
      expect(navBarBase.getAttribute('aria-label')).toEqual('foo');
    });
  });

  describe('#onTabsChange()', () => {
    it(
      "syncs tabs' hideInactiveLabel state with the navigation bar's " +
        'hideInactiveLabels state',
      async () => {
        const {harness} = await setupTest(navBarWithIncorrectTabsElement);
        const tab1 = harness.element.tabs[0];
        const tab2 = harness.element.tabs[1];
        expect(harness.element.hideInactiveLabels).toBeFalse();
        expect(tab1.hideInactiveLabel).toBeFalse();
        expect(tab2.hideInactiveLabel).toBeFalse();
      },
    );

    it("syncs tabs' active state with the navigation bar's activeIndex state", async () => {
      const {harness} = await setupTest(navBarWithIncorrectTabsElement);
      const tab1 = harness.element.tabs[0];
      const tab2 = harness.element.tabs[1];
      expect(harness.element.activeIndex).toBe(0);
      expect(tab1.active).toBeTrue();
      expect(tab2.active).toBeFalse();
    });
  });

  describe('#handleKeydown', () => {
    let element: MdNavigationBar;
    let bar: HTMLElement;
    let tab1: HTMLElement;
    let tab2: HTMLElement;

    beforeEach(async () => {
      const {harness} = await setupTest(
        navBarWithNavTabsElement({activeIndex: 0}),
      );
      element = harness.element;
      bar = harness.element.shadowRoot!.querySelector('.md3-navigation-bar')!;
      tab1 = harness.element.children[0] as HTMLElement;
      tab2 = harness.element.children[1] as HTMLElement;
    });

    it('(Enter) activates the focused tab', async () => {
      const eventRight = new KeyboardEvent('keydown', {
        key: 'ArrowRight',
        bubbles: true,
      });
      const eventEnter = new KeyboardEvent('keydown', {
        key: 'Enter',
        bubbles: true,
      });
      tab1.focus();
      expect(element.activeIndex).toBe(0);
      bar.dispatchEvent(eventRight);
      bar.dispatchEvent(eventEnter);
      element.requestUpdate();
      await env.waitForStability();
      expect(element.activeIndex).toBe(1);
    });

    it('(Spacebar) activates the focused tab', async () => {
      const eventRight = new KeyboardEvent('keydown', {
        key: 'ArrowRight',
        bubbles: true,
      });
      const eventSpacebar = new KeyboardEvent('keydown', {
        key: ' ',
        bubbles: true,
      });
      tab1.focus();
      expect(element.activeIndex).toBe(0);
      bar.dispatchEvent(eventRight);
      bar.dispatchEvent(eventSpacebar);
      element.requestUpdate();
      await env.waitForStability();
      expect(element.activeIndex).toBe(1);
    });

    it('(Home) sets focus on the first tab', () => {
      const event = new KeyboardEvent('keydown', {key: 'Home', bubbles: true});
      tab2.focus();
      expect(tab1.matches(':focus-within')).toBeFalse();
      bar.dispatchEvent(event);
      expect(tab1.matches(':focus-within')).toBeTrue();
    });

    it('(End) sets focus on the last tab', () => {
      const event = new KeyboardEvent('keydown', {key: 'End', bubbles: true});
      bar.dispatchEvent(event);
      expect(tab2.matches(':focus-within')).toBeTrue();
    });

    describe('(ArrowLeft)', () => {
      // Use the same key for all tests
      const key = 'ArrowLeft';

      it(`sets focus on previous tab`, () => {
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab2.focus();
        bar.dispatchEvent(event);
        expect(tab1.matches(':focus-within')).toBeTrue();
      });

      it(`sets focus to last tab when focus is on the first tab`, () => {
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab1.focus();
        bar.dispatchEvent(event);
        expect(tab2.matches(':focus-within')).toBeTrue();
      });

      it(`sets focus on next tab in RTL`, () => {
        document.body.style.direction = 'rtl';
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab1.focus();
        bar.dispatchEvent(event);
        expect(tab2.matches(':focus-within')).toBeTrue();
      });
    });

    describe('(ArrowRight)', () => {
      // Use the same key for all tests
      const key = 'ArrowRight';

      it(`sets focus on next tab`, () => {
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab1.focus();
        bar.dispatchEvent(event);
        expect(tab2.matches(':focus-within')).toBeTrue();
      });

      it(`sets focus to first tab when focus is on the last tab`, () => {
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab2.focus();
        bar.dispatchEvent(event);
        expect(tab1.matches(':focus-within')).toBeTrue();
      });

      it(`sets focus on previous tab in RTL`, () => {
        document.body.style.direction = 'rtl';
        const event = new KeyboardEvent('keydown', {key, bubbles: true});
        tab2.focus();
        bar.dispatchEvent(event);
        expect(tab1.matches(':focus-within')).toBeTrue();
      });
    });
  });
});


// ========== /navigationbar/navigation-bar.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {NavigationBar} from './internal/navigation-bar.js';
import {styles} from './internal/navigation-bar-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-navigation-bar': MdNavigationBar;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-navigation-bar')
export class MdNavigationBar extends NavigationBar {
  static override styles: CSSResultOrNative[] = [styles];
}


/* ========== /navigationdrawer/_navigation-drawer-modal.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/navigation-drawer-modal' show theme;


/* ========== /navigationdrawer/_navigation-drawer.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/navigation-drawer' show theme;


/* ========== /navigationdrawer/internal/_navigation-drawer-modal.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../elevation/elevation';
@use '../../../internal/motion/animation';
// go/keep-sorted end

$_curve: animation.$standard-easing;
$_delay: 0s;
$_transition-duration: 0.25s;

$_reference: (
  'container-color': #fff,
  'container-height': 100%,
  'container-shape': 0 16px 16px 0,
  'container-width': 360px,
  // b/216384393 - Temporary existing token to use for shadow color
  'divider-color': #000,
  'modal-container-elevation': 1,
  'scrim-color': null,
  'scrim-opacity': 0.04,
  'standard-container-elevation': 0,
);

@mixin theme($tokens) {
  // $supported-tokens: tokens.$md-comp-navigation-drawer-modal-supported-tokens;

  @each $token, $value in $tokens {
    // @if list.index($supported-tokens, $token) == null {
    //   @error 'Token `#{$token}` is not a supported token.';
    // }

    @if $value {
      --md-navigation-drawer-modal-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: $_reference;

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: var(--md-navigation-drawer-modal-#{$token}, #{$value});
    }

    @include elevation.theme(
      (
        'level': var(--_modal-container-elevation),
      )
    );
  }

  .md3-navigation-drawer-modal {
    bottom: 0;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
    overflow: hidden;
    position: absolute;
    top: 0;
    inline-size: 0;

    transition: inline-size $_transition-duration $_curve $_delay,
      visibility $_delay $_curve $_transition-duration;
  }

  .md3-navigation-drawer-modal--opened {
    transition: inline-size $_transition-duration $_curve $_delay,
      visibility $_delay $_curve $_delay;
  }

  .md3-navigation-drawer-modal--pivot-at-start {
    justify-content: flex-start;
  }

  .md3-navigation-drawer-modal__slot-content {
    display: flex;
    flex-direction: column;
    position: relative;
  }

  .md3-navigation-drawer-modal__scrim {
    inset: 0;
    opacity: 0;
    position: absolute;
    visibility: hidden;
    background-color: var(--_scrim-color);

    transition: opacity $_transition-duration $_curve $_delay,
      visibility $_delay $_curve $_transition-duration;
  }

  .md3-navigation-drawer-modal--scrim-visible {
    visibility: visible;
    opacity: var(--_scrim-opacity);

    transition: opacity $_transition-duration $_curve $_delay,
      visibility $_delay $_curve $_delay;
  }
}


/* ========== /navigationdrawer/internal/_navigation-drawer.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use '../../../elevation/elevation';
@use '../../../internal/motion/animation';
// go/keep-sorted end

$curve: animation.$standard-easing;
$default: 0s;
$delay: 0s;
$transition-duration: 0.25s;

$_reference: (
  'container-color': #fff,
  'container-height': 100%,
  'container-shape': 0 16px 16px 0,
  'container-width': 360px,
  // b/216384393 - Temporary existing token to use for shadow color
  'divider-color': #000,
  'modal-container-elevation': 1,
  'standard-container-elevation': 0,
);

@mixin theme($tokens) {
  // $supported-tokens: tokens.$md-comp-navigation-drawer-supported-tokens;

  @each $token, $value in $tokens {
    // @if list.index($supported-tokens, $token) == null {
    //   @error 'Token `#{$token}` is not a supported token.';
    // }

    @if $value {
      --md-navigation-drawer-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: $_reference;

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: var(--md-navigation-drawer-#{$token}, #{$value});
    }

    @include elevation.theme(
      (
        'level': var(--_standard-container-elevation),
        'shadow-color': var(--_divider-color),
      )
    );
  }

  :host {
    display: flex;
  }

  .md3-navigation-drawer {
    inline-size: 0;
    box-sizing: border-box;
    display: flex;
    justify-content: flex-end;
    overflow: hidden;
    overflow-y: auto;
    visibility: hidden;

    transition: inline-size $transition-duration $curve $delay,
      visibility $default $curve $transition-duration;
  }

  md-elevation {
    z-index: 0;
  }

  .md3-navigation-drawer--opened {
    visibility: visible;

    transition: inline-size $transition-duration $curve $delay,
      visibility $default $curve $default;
  }

  .md3-navigation-drawer--pivot-at-start {
    justify-content: flex-start;
  }

  .md3-navigation-drawer__slot-content {
    display: flex;
    flex-direction: column;
    position: relative;
  }
}


/* ========== /navigationdrawer/internal/_shared.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end

@mixin styles() {
  .md3-navigation-drawer-modal,
  .md3-navigation-drawer {
    background-color: var(--_container-color);
    border-radius: var(--_container-shape);
    height: var(--_container-height);
  }

  .md3-navigation-drawer-modal.md3-navigation-drawer-modal--opened,
  .md3-navigation-drawer.md3-navigation-drawer--opened {
    inline-size: var(--_container-width);
  }

  .md3-navigation-drawer-modal .md3-navigation-drawer-modal__slot-content,
  .md3-navigation-drawer .md3-navigation-drawer__slot-content {
    min-inline-size: var(--_container-width);
    max-inline-size: var(--_container-width);
  }
}


/* ========== /navigationdrawer/internal/navigation-drawer-modal-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './navigation-drawer-modal';
// go/keep-sorted end

@include navigation-drawer-modal.styles;


// ========== /navigationdrawer/internal/navigation-drawer-modal.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, LitElement, nothing, PropertyValues} from 'lit';
import {property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';

// Separate variable needed for closure.
const navigationDrawerModalBaseClass = mixinDelegatesAria(LitElement);

/**
 * b/265346501 - add docs
 *
 * @fires navigation-drawer-changed {CustomEvent<{opened: boolean}>}
 * Dispatched whenever the drawer opens or closes --bubbles --composed
 */
export class NavigationDrawerModal extends navigationDrawerModalBaseClass {
  @property({type: Boolean}) opened = false;
  @property() pivot: 'start' | 'end' = 'end';

  protected override render() {
    const ariaExpanded = this.opened ? 'true' : 'false';
    const ariaHidden = !this.opened ? 'true' : 'false';
    // Needed for closure conformance
    const {ariaLabel, ariaModal} = this as ARIAMixinStrict;
    return html`
      <div
        class="md3-navigation-drawer-modal__scrim ${this.getScrimClasses()}"
        @click="${this.handleScrimClick}">
      </div>
      <div
        aria-expanded=${ariaExpanded}
        aria-hidden=${ariaHidden}
        aria-label=${ariaLabel || nothing}
        aria-modal=${ariaModal || nothing}
        class="md3-navigation-drawer-modal ${this.getRenderClasses()}"
        @keydown="${this.handleKeyDown}"
        role="dialog"
        ><div class="md3-elevation-overlay"></div>
        <div class="md3-navigation-drawer-modal__slot-content">
          <slot></slot>
        </div>
      </div>
    `;
  }

  private getScrimClasses() {
    return classMap({
      'md3-navigation-drawer-modal--scrim-visible': this.opened,
    });
  }

  private getRenderClasses() {
    return classMap({
      'md3-navigation-drawer-modal--opened': this.opened,
      'md3-navigation-drawer-modal--pivot-at-start': this.pivot === 'start',
    });
  }

  protected override updated(
    changedProperties: PropertyValues<NavigationDrawerModal>,
  ) {
    if (changedProperties.has('opened')) {
      setTimeout(() => {
        this.dispatchEvent(
          new CustomEvent('navigation-drawer-changed', {
            detail: {opened: this.opened},
            bubbles: true,
            composed: true,
          }),
        );
      }, 250);
    }
  }

  private handleKeyDown(event: KeyboardEvent) {
    if (event.code === 'Escape') {
      this.opened = false;
    }
  }

  private handleScrimClick() {
    this.opened = !this.opened;
  }
}


/* ========== /navigationdrawer/internal/navigation-drawer-styles.scss ========== */
//
// Copyright 2021 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './navigation-drawer';
// go/keep-sorted end

@include navigation-drawer.styles;


// ========== /navigationdrawer/internal/navigation-drawer.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../elevation/elevation.js';

import {html, LitElement, nothing, PropertyValues} from 'lit';
import {property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';

// Separate variable needed for closure.
const navigationDrawerBaseClass = mixinDelegatesAria(LitElement);

/**
 * b/265346501 - add docs
 *
 * @fires navigation-drawer-changed {CustomEvent<{opened: boolean}>}
 * Dispatched whenever the drawer opens or closes --bubbles --composed
 */
export class NavigationDrawer extends navigationDrawerBaseClass {
  @property({type: Boolean}) opened = false;
  @property() pivot: 'start' | 'end' = 'end';

  protected override render() {
    const ariaExpanded = this.opened ? 'true' : 'false';
    const ariaHidden = !this.opened ? 'true' : 'false';
    // Needed for closure conformance
    const {ariaLabel, ariaModal} = this as ARIAMixinStrict;
    return html`
      <div
        aria-expanded="${ariaExpanded}"
        aria-hidden="${ariaHidden}"
        aria-label=${ariaLabel || nothing}
        aria-modal="${ariaModal || nothing}"
        class="md3-navigation-drawer ${this.getRenderClasses()}"
        role="dialog">
        <md-elevation part="elevation"></md-elevation>
        <div class="md3-navigation-drawer__slot-content">
          <slot></slot>
        </div>
      </div>
    `;
  }

  private getRenderClasses() {
    return classMap({
      'md3-navigation-drawer--opened': this.opened,
      'md3-navigation-drawer--pivot-at-start': this.pivot === 'start',
    });
  }

  protected override updated(
    changedProperties: PropertyValues<NavigationDrawer>,
  ) {
    if (changedProperties.has('opened')) {
      setTimeout(() => {
        this.dispatchEvent(
          new CustomEvent('navigation-drawer-changed', {
            detail: {opened: this.opened},
            bubbles: true,
            composed: true,
          }),
        );
      }, 250);
    }
  }
}


/* ========== /navigationdrawer/internal/shared-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /navigationdrawer/navigation-drawer-modal.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {customElement} from 'lit/decorators.js';

import {NavigationDrawerModal} from './internal/navigation-drawer-modal.js';
import {styles} from './internal/navigation-drawer-modal-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-navigation-drawer-modal': MdNavigationDrawerModal;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-navigation-drawer-modal')
export class MdNavigationDrawerModal extends NavigationDrawerModal {
  static override readonly styles = [sharedStyles, styles];
}


// ========== /navigationdrawer/navigation-drawer.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {customElement} from 'lit/decorators.js';

import {NavigationDrawer} from './internal/navigation-drawer.js';
import {styles} from './internal/navigation-drawer-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-navigation-drawer': MdNavigationDrawer;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-navigation-drawer')
export class MdNavigationDrawer extends NavigationDrawer {
  static override readonly styles = [sharedStyles, styles];
}


/* ========== /navigationtab/_navigation-tab.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/navigation-tab' show theme;


/* ========== /navigationtab/internal/_navigation-tab.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../focus/focus-ring';
@use '../../../internal/motion/animation';
@use '../../../ripple/ripple';
@use '../../../tokens';
@use '../../badge/badge';
// go/keep-sorted end

$animation-duration: 100ms;

@mixin theme($tokens) {
  // $supported-tokens: tokens.$md-comp-navigation-bar-supported-tokens;

  @each $token, $value in $tokens {
    // @if list.index($supported-tokens, $token) == null {
    //   @error 'Token `#{$token}` is not a supported token.';
    // }

    @if $value {
      --md-navigation-bar-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-navigation-bar-values();

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }

    display: flex;
    flex-grow: 1;
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape': map.get(tokens.md-sys-shape-values(), 'corner-small'),
        'inward-offset': -1px,
      )
    );
  }

  .md3-navigation-tab {
    align-items: center;
    appearance: none;
    background: none;
    border: none;
    box-sizing: border-box;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    height: 100%;
    justify-content: center;
    min-height: 48px;
    min-width: 48px;
    outline: none;
    padding: 8px 0px 12px;
    position: relative;
    text-align: center;
    width: 100%;
    font-family: var(--_label-text-font);
    font-size: var(--_label-text-size);
    line-height: var(--_label-text-line-height);
    font-weight: var(--_label-text-weight);
    // Override the user-agent text-transform: none of <button>
    text-transform: inherit;

    // Firefox draws a dotted border around focused buttons unless specifically overridden.
    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  }

  .md3-navigation-tab__icon-content {
    align-items: center;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    position: relative;
    z-index: 1;
  }

  .md3-navigation-tab__label-text {
    height: 16px;
    margin-top: 4px;
    opacity: 1;
    transition: animation.standard(opacity, $animation-duration),
      animation.standard(height, $animation-duration);
    z-index: 1;

    .md3-navigation-tab--hide-inactive-label:not(.md3-navigation-tab--active)
      & {
      height: 0;
      opacity: 0;
    }
  }

  .md3-navigation-tab__active-indicator {
    display: flex;
    justify-content: center;
    opacity: 0;
    position: absolute;
    transition: animation.standard(width, $animation-duration),
      animation.standard(opacity, $animation-duration);
    width: 32px;
    background-color: var(--_active-indicator-color);
    border-radius: var(--_active-indicator-shape);

    .md3-navigation-tab--active & {
      opacity: 1;
    }
  }

  // Keep icon-content in sync with active-indicator size.
  .md3-navigation-tab__active-indicator,
  .md3-navigation-tab__icon-content {
    height: var(--_active-indicator-height);
  }

  // Keep icon-content in sync with active-indicator size.
  .md3-navigation-tab--active .md3-navigation-tab__active-indicator,
  .md3-navigation-tab__icon-content {
    width: var(--_active-indicator-width);
  }

  .md3-navigation-tab__icon {
    fill: currentColor;
    align-self: center;
    display: inline-block;
    position: relative;
    width: var(--_icon-size);
    height: var(--_icon-size);
    font-size: var(--_icon-size);

    &.md3-navigation-tab__icon--active {
      display: none;
    }

    .md3-navigation-tab--active & {
      display: none;

      &.md3-navigation-tab__icon--active {
        display: inline-block;
      }
    }
  }

  .md3-navigation-tab__ripple {
    z-index: 0;
  }

  .md3-navigation-tab--active {
    .md3-navigation-tab__icon {
      color: var(--_active-icon-color);
    }

    .md3-navigation-tab__label-text {
      color: var(--_active-label-text-color);
    }

    &:hover {
      .md3-navigation-tab__icon {
        color: var(--_active-hover-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_active-hover-label-text-color);
      }
    }

    &:focus {
      .md3-navigation-tab__icon {
        color: var(--_active-focus-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_active-focus-label-text-color);
      }
    }

    &:active {
      .md3-navigation-tab__icon {
        color: var(--_active-pressed-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_active-pressed-label-text-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_active-hover-state-layer-color),
        pressed-color: var(--_active-pressed-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .md3-navigation-tab:not(.md3-navigation-tab--active) {
    .md3-navigation-tab__icon {
      color: var(--_inactive-icon-color);
    }

    .md3-navigation-tab__label-text {
      color: var(--_inactive-label-text-color);
    }

    &:hover {
      .md3-navigation-tab__icon {
        color: var(--_inactive-hover-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_inactive-hover-label-text-color);
      }
    }

    &:focus {
      .md3-navigation-tab__icon {
        color: var(--_inactive-focus-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_inactive-focus-label-text-color);
      }
    }

    &:active {
      .md3-navigation-tab__icon {
        color: var(--_inactive-pressed-icon-color);
      }

      .md3-navigation-tab__label-text {
        color: var(--_inactive-pressed-label-text-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_inactive-hover-state-layer-color),
        pressed-color: var(--_inactive-pressed-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }
}


/* ========== /navigationtab/internal/navigation-tab-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './navigation-tab';
// go/keep-sorted end

@include navigation-tab.styles;


// ========== /navigationtab/internal/navigation-tab.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../focus/md-focus-ring.js';
import '../../../ripple/ripple.js';
import '../../badge/badge.js';

import {html, LitElement, nothing, PropertyValues} from 'lit';
import {property, query} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';

import {NavigationTabState} from './state.js';

// Separate variable needed for closure.
const navigationTabBaseClass = mixinDelegatesAria(LitElement);

/**
 * b/265346501 - add docs
 *
 * @fires navigation-tab-rendered {Event} Dispatched when the navigation tab's
 * DOM has rendered and custom element definition has loaded. --bubbles
 * --composed
 * @fires navigation-tab-interaction {CustomEvent<{state: MdNavigationTab}>}
 * Dispatched when the navigation tab has been clicked. --bubbles --composed
 */
export class NavigationTab
  extends navigationTabBaseClass
  implements NavigationTabState
{
  @property({type: Boolean}) disabled = false;
  @property({type: Boolean, reflect: true}) active = false;
  @property({type: Boolean, attribute: 'hide-inactive-label'})
  hideInactiveLabel = false;
  @property() label?: string;
  @property({attribute: 'badge-value'}) badgeValue = '';
  @property({type: Boolean, attribute: 'show-badge'}) showBadge = false;

  @query('button') buttonElement!: HTMLElement | null;

  protected override render() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html` <button
      class="md3-navigation-tab ${classMap(this.getRenderClasses())}"
      role="tab"
      aria-selected="${this.active}"
      aria-label=${ariaLabel || nothing}
      tabindex="${this.active ? 0 : -1}"
      @click="${this.handleClick}">
      <md-focus-ring part="focus-ring" inward></md-focus-ring>
      <md-ripple
        ?disabled="${this.disabled}"
        class="md3-navigation-tab__ripple"></md-ripple>
      <span aria-hidden="true" class="md3-navigation-tab__icon-content"
        ><span class="md3-navigation-tab__active-indicator"></span
        ><span class="md3-navigation-tab__icon"
          ><slot name="inactive-icon"></slot
        ></span>
        <span class="md3-navigation-tab__icon md3-navigation-tab__icon--active"
          ><slot name="active-icon"></slot></span
        >${this.renderBadge()}</span
      >${this.renderLabel()}
    </button>`;
  }

  private getRenderClasses() {
    return {
      'md3-navigation-tab--hide-inactive-label': this.hideInactiveLabel,
      'md3-navigation-tab--active': this.active,
    };
  }

  private renderBadge() {
    return this.showBadge
      ? html`<md-badge .value="${this.badgeValue}"></md-badge>`
      : nothing;
  }

  private renderLabel() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    const ariaHidden = ariaLabel ? 'true' : 'false';
    return !this.label
      ? nothing
      : html` <span
          aria-hidden="${ariaHidden}"
          class="md3-navigation-tab__label-text"
          >${this.label}</span
        >`;
  }

  override firstUpdated(changedProperties: PropertyValues) {
    super.firstUpdated(changedProperties);
    const event = new Event('navigation-tab-rendered', {
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(event);
  }

  override focus() {
    const buttonElement = this.buttonElement;
    if (buttonElement) {
      buttonElement.focus();
    }
  }

  override blur() {
    const buttonElement = this.buttonElement;
    if (buttonElement) {
      buttonElement.blur();
    }
  }

  handleClick() {
    // b/269772145 - connect to ripple
    this.dispatchEvent(
      new CustomEvent('navigation-tab-interaction', {
        detail: {state: this},
        bubbles: true,
        composed: true,
      }),
    );
  }
}


// ========== /navigationtab/internal/state.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * The state of a navigation tab.
 */
export interface NavigationTabState {
  /**
   * Active state of the navigation tab.
   */
  active: boolean;
  /**
   * If true, when inactive label will be hidden.
   */
  hideInactiveLabel: boolean;
}


// ========== /navigationtab/md-navigation-tab_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, render} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Environment} from '../../testing/environment.js';

import {NavigationTabHarness} from './harness.js';
import {MdNavigationTab} from './navigation-tab.js';

@customElement('md-test-navigation-tab')
class TestNavigationTab extends MdNavigationTab {}

declare global {
  interface HTMLElementTagNameMap {
    'md-test-navigation-tab': TestNavigationTab;
  }
}

describe('mwc-navigation-tab', () => {
  const env = new Environment();

  async function setupTest() {
    // Variant type does not matter for shared tests
    const element = env
      .render(html`<md-test-navigation-tab></md-test-navigation-tab>`)
      .querySelector('md-test-navigation-tab');
    if (!element) {
      throw new Error('Could not query rendered <md-test-navigation-tab>.');
    }

    await env.waitForStability();
    const button = element.renderRoot.querySelector('button');
    if (!button) {
      throw new Error('Could not query rendered <button>.');
    }

    const navTab = element.renderRoot.querySelector('.md3-navigation-tab');
    if (!navTab) {
      throw new Error('Could not query rendered .md3-navigation-tab.');
    }

    return {
      button,
      navTab,
      harness: new NavigationTabHarness(element),
    };
  }

  describe('basic', () => {
    it('initializes as an md-navigation-tab', async () => {
      const {harness} = await setupTest();
      expect(harness.element).toBeInstanceOf(MdNavigationTab);
      expect(harness.element.active).toBeFalse();
      expect(harness.element.hideInactiveLabel).toBeFalse();
      expect(harness.element.label).toBeUndefined();
      expect(harness.element.badgeValue).toEqual('');
      expect(harness.element.showBadge).toBeFalse();
    });

    it('emits interaction event on click', async () => {
      const {harness} = await setupTest();
      const interactionHandler = jasmine.createSpy();
      harness.element.addEventListener(
        'navigation-tab-interaction',
        interactionHandler,
      );
      await harness.clickWithMouse();
      expect(interactionHandler).toHaveBeenCalled();
    });

    it('focus() sets focus on button element', async () => {
      const {harness, button} = await setupTest();
      harness.element.focus();
      expect(button.matches(':focus')).toBeTrue();
    });
  });

  it('on render navigation-tab-rendered event fires', async () => {
    const element = document.createElement('md-test-navigation-tab');
    const renderedHandler = jasmine.createSpy();
    element.addEventListener('navigation-tab-rendered', renderedHandler);
    env.render(html`${element}`);
    await env.waitForStability();
    expect(renderedHandler).toHaveBeenCalled();
  });

  describe('active', () => {
    it('affects `aria-selected` of native button', async () => {
      const {harness, button} = await setupTest();
      harness.element.active = true;
      await env.waitForStability();

      expect(button.getAttribute('aria-selected')).toEqual('true');

      harness.element.active = false;
      await env.waitForStability();
      expect(button.getAttribute('aria-selected')).toEqual('false');
    });

    it('affects `tabindex` of native button', async () => {
      const {harness, button} = await setupTest();
      harness.element.active = true;
      await env.waitForStability();

      expect(button.getAttribute('tabindex')).toEqual('0');

      harness.element.active = false;
      await env.waitForStability();
      expect(button.getAttribute('tabindex')).toEqual('-1');
    });

    it('sets the correct classes', async () => {
      const {harness, navTab} = await setupTest();
      harness.element.active = true;
      await env.waitForStability();

      expect(
        navTab.classList.contains('md3-navigation-tab--active'),
      ).toBeTrue();
    });
  });

  describe('hideInactiveLabel', () => {
    it('sets the correct classes', async () => {
      const {harness, navTab} = await setupTest();
      harness.element.hideInactiveLabel = true;
      await env.waitForStability();

      expect(
        navTab.classList.contains('md3-navigation-tab--hide-inactive-label'),
      ).toBeTrue();
    });
  });

  describe('label', () => {
    it('displays label text', async () => {
      const {harness} = await setupTest();
      harness.element.label = 'foo';
      await env.waitForStability();

      const content = harness.element.shadowRoot!.querySelector(
        '.md3-navigation-tab__label-text',
      )!;
      expect(content.textContent!.trim()).toEqual('foo');
    });
  });

  describe('ariaLabel', () => {
    it('affects `aria-label` of native button', async () => {
      const {harness, button} = await setupTest();
      harness.element.label = 'foo';
      harness.element.ariaLabel = 'bar';
      await env.waitForStability();

      expect(button.getAttribute('aria-label')).toEqual('bar');
    });
  });

  describe('showBadge', () => {
    it('displays badge', async () => {
      const {harness} = await setupTest();
      harness.element.showBadge = true;
      await env.waitForStability();

      const badge = harness.element.renderRoot.querySelector('md-badge');
      expect(badge).toBeDefined();
    });

    it('does not display badge if showBadge is false', async () => {
      const {harness} = await setupTest();
      harness.element.showBadge = false;
      await env.waitForStability();

      const badge = harness.element.renderRoot.querySelector('md-badge');
      expect(badge).toEqual(null);
    });
  });

  describe('badgeValue', () => {
    it('displays badge value', async () => {
      const {harness} = await setupTest();
      harness.element.showBadge = true;
      harness.element.badgeValue = '9';
      await env.waitForStability();

      const badge = harness.element.renderRoot.querySelector('md-badge');
      expect(badge?.value).toEqual('9');
    });
  });

  describe('icons', () => {
    it('nodes with `slot=active-icon` will serve as the active icon', async () => {
      const {harness} = await setupTest();
      const icons = html`
        <i slot="active-icon" class="material-icons">star</i>
        <i slot="inactive-icon" class="material-icons">star_border</i>
      `;
      render(icons, harness.element);

      const icon = harness.element.querySelector<HTMLElement>(
        '[slot="active-icon"]',
      )!;
      expect(icon.textContent!.trim()).toEqual('star');
    });

    it('nodes with `slot=inactive-icon` will serve as the inactive icon', async () => {
      const {harness} = await setupTest();
      const icons = html`
        <i slot="active-icon" class="material-icons">star</i>
        <i slot="inactive-icon" class="material-icons">star_border</i>
      `;
      render(icons, harness.element);

      const icon = harness.element.querySelector<HTMLElement>(
        '[slot="inactive-icon"]',
      )!;
      expect(icon.textContent!.trim()).toEqual('star_border');
    });
  });
});


// ========== /navigationtab/navigation-tab.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {NavigationTab} from './internal/navigation-tab.js';
import {styles} from './internal/navigation-tab-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-navigation-tab': MdNavigationTab;
  }
}

/**
 * @final
 * @suppress {visibility}
 */
@customElement('md-navigation-tab')
export class MdNavigationTab extends NavigationTab {
  static override styles: CSSResultOrNative[] = [styles];
}


/* ========== /segmentedbutton/internal/_outlined-segmented-button.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin styles() {
  $tokens: tokens.md-comp-outlined-segmented-button-values();
  // b/198759625 - Remove spacing tokens once provided.
  $tokens: map.merge(
    $tokens,
    (
      'spacing-leading': 12px,
      'spacing-trailing': 12px,
    )
  );

  :host {
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }

  .md3-segmented-button__outline {
    border-radius: inherit;
    border-style: solid;
    // Move border-width and inset into theme.
    border-width: 1px;
    inset: 0px -0.5px;
    pointer-events: none;
    position: absolute;
  }
}


/* ========== /segmentedbutton/internal/_shared.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../internal/motion/animation';
@use '../../../ripple/ripple';
// go/keep-sorted end

@mixin styles() {
  @keyframes md3-segmented-button-checkmark-selection-draw-in {
    from {
      stroke-dashoffset: 29.7833385;
    }
    to {
      stroke-dashoffset: 0;
    }
  }

  @keyframes md3-segmented-button-simple-fade-out {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  @keyframes md3-segmented-button-simple-fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  :host {
    display: inline-flex;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  .md3-segmented-button {
    align-items: center;
    background: transparent;
    border: none;
    border-radius: inherit;
    display: flex;
    flex: 1;
    justify-content: center;
    outline: none;
    position: relative;
    vertical-align: middle;
    padding-inline-start: var(--_spacing-leading);
    padding-inline-end: var(--_spacing-trailing);
    // Override the user-agent text-transform: none of <button>
    text-transform: inherit;

    .md3-segmented-button__outline {
      border-color: var(--_outline-color);
    }

    &:disabled .md3-segmented-button__outline {
      border-color: var(--_disabled-outline-color);
    }

    .md3-segmented-button__graphic,
    .md3-segmented-button__checkmark,
    .md3-segmented-button__icon,
    .md3-segmented-button__icon ::slotted([slot='icon']) {
      height: var(--_icon-size);
      width: var(--_icon-size);
      font-size: var(--_icon-size);
    }

    // Under the following conditions, we need to account for extra space between
    // the graphic and the text label/icon content:
    //
    //   1. A button with an icon and a label.
    //   2. A selected button with a label and checkmark.
    //   3. A selected button with an icon and checkmark but no label.
    //
    // We calculate a larger width here instead of using padding or margin for
    // two main reasons:
    //
    //   1. We may need to transition between a zero width and an explicit width.
    //   2. Both margin and padding take up space when a node has child content
    //      even when a zero width is set and overflow is set to hidden.
    //
    // Because of those reasons, we calculate a new width with the given values.
    &.md3-segmented-button--with-icon.md3-segmented-button--with-label,
    &.md3-segmented-button--selected.md3-segmented-button--with-label.md3-segmented-button--with-checkmark,
    &.md3-segmented-button--selected.md3-segmented-button--without-label.md3-segmented-button--with-checkmark {
      .md3-segmented-button__graphic {
        // b/198759625 - Use padding token instead of hardcoded 8px value.
        width: calc(var(--_icon-size) + 8px);
      }
    }

    .md3-segmented-button__label-text {
      font-family: var(--_label-text-font);
      font-size: var(--_label-text-size);
      line-height: var(--_label-text-line-height);
      font-weight: var(--_label-text-weight);
    }

    &.md3-segmented-button--selected:enabled {
      .md3-segmented-button__label-text {
        color: var(--_selected-label-text-color);
      }

      &:hover {
        .md3-segmented-button__label-text {
          color: var(--_selected-hover-label-text-color);
        }
      }

      &:focus {
        .md3-segmented-button__label-text {
          color: var(--_selected-focus-label-text-color);
        }
      }

      &:active {
        .md3-segmented-button__label-text {
          color: var(--_selected-pressed-label-text-color);
        }
      }
    }

    &.md3-segmented-button--unselected:enabled {
      .md3-segmented-button__label-text {
        color: var(--_unselected-label-text-color);
      }

      &:hover {
        .md3-segmented-button__label-text {
          color: var(--_unselected-hover-label-text-color);
        }
      }

      &:focus {
        .md3-segmented-button__label-text {
          color: var(--_unselected-focus-label-text-color);
        }
      }

      &:active {
        .md3-segmented-button__label-text {
          color: var(--_unselected-pressed-label-text-color);
        }
      }
    }

    &:disabled {
      .md3-segmented-button__label-text {
        color: var(--_disabled-label-text-color);
      }
    }
  }

  .md3-segmented-button--unselected {
    .md3-segmented-button__icon {
      color: var(--_unselected-icon-color);
    }

    &:hover {
      .md3-segmented-button__icon {
        color: var(--_unselected-hover-icon-color);
      }
    }

    &:focus {
      .md3-segmented-button__icon {
        color: var(--_unselected-focus-icon-color);
      }
    }

    &:active {
      .md3-segmented-button__icon {
        color: var(--_unselected-pressed-icon-color);
      }
    }

    &:disabled {
      .md3-segmented-button__icon {
        color: var(--_disabled-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_unselected-hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_unselected-pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .md3-segmented-button--selected {
    background-color: var(--_selected-container-color);

    .md3-segmented-button__icon {
      color: var(--_selected-icon-color);
    }

    .md3-segmented-button__checkmark-path {
      stroke: var(--_selected-icon-color);
    }

    &:hover {
      .md3-segmented-button__checkmark-path {
        stroke: var(--_selected-hover-icon-color);
      }
    }

    &:focus {
      .md3-segmented-button__checkmark-path {
        stroke: var(--_selected-focus-icon-color);
      }
    }

    &:active {
      .md3-segmented-button__checkmark-path {
        stroke: var(--_selected-pressed-icon-color);
      }
    }

    &:disabled {
      .md3-segmented-button__checkmark-path {
        stroke: var(--_disabled-icon-color);
      }
    }

    @include ripple.theme(
      (
        hover-color: var(--_selected-hover-state-layer-color),
        hover-opacity: var(--_hover-state-layer-opacity),
        pressed-color: var(--_selected-pressed-state-layer-color),
        pressed-opacity: var(--_pressed-state-layer-opacity),
      )
    );
  }

  .md3-segmented-button:enabled {
    cursor: pointer;
  }

  .md3-segmented-button__focus-ring {
    z-index: 1;
  }

  .md3-segmented-button__ripple {
    border-radius: inherit;
    z-index: 0;
  }

  .md3-segmented-button__touch {
    position: absolute;
    top: 50%;
    height: 48px;
    left: 50%;
    width: 100%;
    transform: translate(-50%, -50%);
  }

  .md3-segmented-button__leading,
  .md3-segmented-button__graphic {
    display: inline-flex;
    justify-content: flex-start;
    align-items: center;
  }

  .md3-segmented-button__graphic {
    position: relative;
    overflow: hidden;
  }

  .md3-segmented-button__graphic {
    transition: animation.standard(width, 150ms);
  }

  .md3-segmented-button--unselected.md3-segmented-button--with-label,
  .md3-segmented-button--unselected.md3-segmented-button--without-label,
  .md3-segmented-button--selected.md3-segmented-button--without-checkmark {
    .md3-segmented-button__graphic {
      width: 0;
    }
  }

  .md3-segmented-button--unselected .md3-segmented-button__checkmark {
    opacity: 0;
  }

  .md3-segmented-button--selected.md3-segmented-button--with-label {
    .md3-segmented-button__icon {
      opacity: 0;
    }
  }

  .md3-segmented-button--with-label .md3-segmented-button__checkmark {
    display: inline-flex;
    position: absolute;
  }

  .md3-segmented-button__checkmark-path {
    stroke-width: 2px;
    stroke-dasharray: 29.7833385;
  }

  .md3-segmented-button--selecting {
    .md3-segmented-button__checkmark-path {
      // We immediately render the checkmark in the animation start treatment
      // because we're using an animation delay. If we didn't have the delay,
      // the checkmark would render in the base fully-drawn state during the
      // brief animation-delay period which would look wrong.
      stroke-dashoffset: 29.7833385;
      animation: md3-segmented-button-checkmark-selection-draw-in;
      animation-duration: 150ms;
      animation-delay: 50ms;
      animation-fill-mode: forwards;
      animation-timing-function: animation.$standard-easing;
    }
    &.md3-segmented-button--with-label .md3-segmented-button__icon {
      animation: md3-segmented-button-simple-fade-out;
      animation-duration: 75ms;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }
  }

  .md3-segmented-button--deselecting {
    .md3-segmented-button__checkmark {
      animation: md3-segmented-button-simple-fade-out;
      animation-duration: 50ms;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }
    &.md3-segmented-button--with-label .md3-segmented-button__icon {
      // We immediately render the icon in the animation start treatment
      // because we're using an animation delay. If we didn't have the delay,
      // the icon would render with full opacity during the brief
      // animation-delay period which would look wrong.
      opacity: 0;
      animation: md3-segmented-button-simple-fade-in;
      animation-delay: 50ms;
      animation-duration: 150ms;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }
  }
}


// ========== /segmentedbutton/internal/outlined-segmented-button.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {SegmentedButton} from './segmented-button.js';

/**
 * b/265346443 - add docs
 */
export class OutlinedSegmentedButton extends SegmentedButton {
  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'md3-segmented-button--outlined': true,
    };
  }

  protected override renderOutline() {
    return html`<span class="md3-segmented-button__outline"></span>`;
  }
}


/* ========== /segmentedbutton/internal/outlined-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-segmented-button';
// go/keep-sorted end

@include outlined-segmented-button.styles;


// ========== /segmentedbutton/internal/segmented-button.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../focus/md-focus-ring.js';
import '../../../ripple/ripple.js';

import {html, LitElement, nothing, PropertyValues, TemplateResult} from 'lit';
import {property, queryAssignedElements, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';

// Separate variable needed for closure.
const segmentedButtonBaseClass = mixinDelegatesAria(LitElement);

/**
 * SegmentedButton is a web component implementation of the Material Design
 * segmented button component. It is intended **only** for use as a child of a
 * `SementedButtonSet` component. It is **not** intended for use in any other
 * context.
 *
 * @fires segmented-button-interaction {Event} Dispatched whenever a button is
 * clicked. --bubbles --composed
 */
export class SegmentedButton extends segmentedButtonBaseClass {
  @property({type: Boolean}) disabled = false;
  @property({type: Boolean}) selected = false;
  @property() label = '';
  @property({type: Boolean, attribute: 'no-checkmark'}) noCheckmark = false;
  @property({type: Boolean, attribute: 'has-icon'}) hasIcon = false;

  @state() private animState = '';
  @queryAssignedElements({slot: 'icon', flatten: true})
  private readonly iconElement!: HTMLElement[];

  protected override update(props: PropertyValues<SegmentedButton>) {
    this.animState = this.nextAnimationState(props);
    super.update(props);
    // NOTE: This needs to be set *after* calling super.update() to ensure the
    // appropriate CSS classes are applied.
    this.hasIcon = this.iconElement.length > 0;
  }

  private nextAnimationState(
    changedProps: PropertyValues<SegmentedButton>,
  ): string {
    const prevSelected = changedProps.get('selected');
    // Early exit for first update.
    if (prevSelected === undefined) return '';

    const nextSelected = this.selected;
    const nextHasCheckmark = !this.noCheckmark;
    if (!prevSelected && nextSelected && nextHasCheckmark) {
      return 'selecting';
    }
    if (prevSelected && !nextSelected && nextHasCheckmark) {
      return 'deselecting';
    }
    return '';
  }

  private handleClick() {
    const event = new Event('segmented-button-interaction', {
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(event);
  }

  protected override render() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <button
        tabindex="${this.disabled ? '-1' : '0'}"
        aria-label=${ariaLabel || nothing}
        aria-pressed=${this.selected}
        ?disabled=${this.disabled}
        @click="${this.handleClick}"
        class="md3-segmented-button ${classMap(this.getRenderClasses())}">
        <md-focus-ring
          class="md3-segmented-button__focus-ring"
          part="focus-ring"></md-focus-ring>
        <md-ripple
          ?disabled="${this.disabled}"
          class="md3-segmented-button__ripple"></md-ripple>
        ${this.renderOutline()} ${this.renderLeading()} ${this.renderLabel()}
        ${this.renderTouchTarget()}
      </button>
    `;
  }

  protected getRenderClasses() {
    return {
      'md3-segmented-button--selected': this.selected,
      'md3-segmented-button--unselected': !this.selected,
      'md3-segmented-button--with-label': this.label !== '',
      'md3-segmented-button--without-label': this.label === '',
      'md3-segmented-button--with-icon': this.hasIcon,
      'md3-segmented-button--with-checkmark': !this.noCheckmark,
      'md3-segmented-button--without-checkmark': this.noCheckmark,
      'md3-segmented-button--selecting': this.animState === 'selecting',
      'md3-segmented-button--deselecting': this.animState === 'deselecting',
    };
  }

  protected renderOutline(): TemplateResult | typeof nothing {
    return nothing;
  }

  private renderLeading() {
    return this.label === ''
      ? this.renderLeadingWithoutLabel()
      : this.renderLeadingWithLabel();
  }

  private renderLeadingWithoutLabel() {
    return html`
      <span class="md3-segmented-button__leading" aria-hidden="true">
        <span class="md3-segmented-button__graphic">
          <svg class="md3-segmented-button__checkmark" viewBox="0 0 24 24">
            <path
              class="md3-segmented-button__checkmark-path"
              fill="none"
              d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
          </svg>
        </span>
        <span class="md3-segmented-button__icon" aria-hidden="true">
          <slot name="icon"></slot>
        </span>
      </span>
    `;
  }

  private renderLeadingWithLabel() {
    return html`
      <span class="md3-segmented-button__leading" aria-hidden="true">
        <span class="md3-segmented-button__graphic">
          <svg class="md3-segmented-button__checkmark" viewBox="0 0 24 24">
            <path
              class="md3-segmented-button__checkmark-path"
              fill="none"
              d="M1.73,12.91 8.1,19.28 22.79,4.59"></path>
          </svg>
          <span class="md3-segmented-button__icon" aria-hidden="true">
            <slot name="icon"></slot>
          </span>
        </span>
      </span>
    `;
  }

  private renderLabel() {
    return html`
      <span class="md3-segmented-button__label-text">${this.label}</span>
    `;
  }

  private renderTouchTarget() {
    return html`<span class="md3-segmented-button__touch"></span>`;
  }
}


/* ========== /segmentedbutton/internal/shared-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /segmentedbutton/outlined-segmented-button.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {OutlinedSegmentedButton} from './internal/outlined-segmented-button.js';
import {styles as outlinedStyles} from './internal/outlined-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-segmented-button': MdOutlinedSegmentedButton;
  }
}

/**
 * MdOutlinedSegmentedButton is the custom element for the Material
 * Design outlined segmented button component.
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-segmented-button')
export class MdOutlinedSegmentedButton extends OutlinedSegmentedButton {
  static override styles: CSSResultOrNative[] = [sharedStyles, outlinedStyles];
}


/* ========== /segmentedbuttonset/internal/_outlined-segmented-button-set.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:map';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: list.join(
    tokens.$md-comp-outlined-segmented-button-supported-tokens,
    ('shape-start-start', 'shape-start-end', 'shape-end-end', 'shape-end-start')
  );

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-outlined-segmented-button-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-outlined-segmented-button-values();

  :host {
    // Only use the logical properties.
    $tokens: map.remove($tokens, 'shape');
    @each $token, $value in $tokens {
      --_#{$token}: #{$value};
    }
  }
}


/* ========== /segmentedbuttonset/internal/_shared.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// stylelint-disable selector-class-pattern --
// Selector '.md3-*' should only be used in this project.

@mixin styles() {
  :host {
    display: flex;
    outline: none;
  }

  .md3-segmented-button-set {
    display: grid;
    grid-auto-columns: 1fr;
    grid-auto-flow: column;
    grid-auto-rows: auto;
    width: 100%;
    height: var(--_container-height);

    ::slotted(:first-child) {
      border-start-start-radius: var(--_shape-start-start);
      border-end-start-radius: var(--_shape-end-start);
    }

    ::slotted(:last-child) {
      border-start-end-radius: var(--_shape-start-end);
      border-end-end-radius: var(--_shape-end-end);
    }
  }
}


// ========== /segmentedbuttonset/internal/outlined-segmented-button-set.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {SegmentedButtonSet} from './segmented-button-set.js';

/**
 * b/265346443 - add docs
 */
export class OutlinedSegmentedButtonSet extends SegmentedButtonSet {
  protected override getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      'md3-segmented-button-set--outlined': true,
    };
  }
}


/* ========== /segmentedbuttonset/internal/outlined-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './outlined-segmented-button-set';
// go/keep-sorted end

@include outlined-segmented-button-set.styles;


// ========== /segmentedbuttonset/internal/segmented-button-set.ts ==========
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, LitElement, nothing} from 'lit';
import {property, queryAssignedElements} from 'lit/decorators.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';
import {SegmentedButton} from '../../segmentedbutton/internal/segmented-button.js';

// Separate variable needed for closure.
const segmentedButtonSetBaseClass = mixinDelegatesAria(LitElement);

/**
 * SegmentedButtonSet is the parent component for two or more
 * `SegmentedButton` components. **Only** `SegmentedButton` components may be
 * used as children.
 *
 * @fires segmented-button-set-selection {CustomEvent<{button: SegmentedButton, selected: boolean, index: number}>}
 * Dispatched when a button is selected programattically with the
 * `setButtonSelected` or the `toggleSelection` methods as well as on user
 * interaction. --bubbles --composed
 */
export class SegmentedButtonSet extends segmentedButtonSetBaseClass {
  @property({type: Boolean}) multiselect = false;

  @queryAssignedElements({flatten: true}) buttons!: SegmentedButton[];

  getButtonDisabled(index: number): boolean {
    if (this.indexOutOfBounds(index)) return false;
    return this.buttons[index].disabled;
  }

  setButtonDisabled(index: number, disabled: boolean) {
    if (this.indexOutOfBounds(index)) return;
    this.buttons[index].disabled = disabled;
  }

  getButtonSelected(index: number): boolean {
    if (this.indexOutOfBounds(index)) return false;
    return this.buttons[index].selected;
  }

  setButtonSelected(index: number, selected: boolean) {
    // Ignore out-of-index values.
    if (this.indexOutOfBounds(index)) return;
    // Ignore disabled buttons.
    if (this.getButtonDisabled(index)) return;

    if (this.multiselect) {
      this.buttons[index].selected = selected;
      this.emitSelectionEvent(index);
      return;
    }

    // Single-select segmented buttons are not unselectable.
    if (!selected) return;

    this.buttons[index].selected = true;
    this.emitSelectionEvent(index);
    // Deselect all other buttons for single-select.
    for (let i = 0; i < this.buttons.length; i++) {
      if (i === index) continue;
      this.buttons[i].selected = false;
    }
  }

  private handleSegmentedButtonInteraction(event: CustomEvent) {
    const index = this.buttons.indexOf(event.target as SegmentedButton);
    this.toggleSelection(index);
  }

  private toggleSelection(index: number) {
    if (this.indexOutOfBounds(index)) return;
    this.setButtonSelected(index, !this.buttons[index].selected);
  }

  private indexOutOfBounds(index: number): boolean {
    return index < 0 || index >= this.buttons.length;
  }

  private emitSelectionEvent(index: number) {
    this.dispatchEvent(
      new CustomEvent('segmented-button-set-selection', {
        detail: {
          button: this.buttons[index],
          selected: this.buttons[index].selected,
          index,
        },
        bubbles: true,
        composed: true,
      }),
    );
  }

  protected override render() {
    // Needed for closure conformance
    const {ariaLabel} = this as ARIAMixinStrict;
    return html`
      <span
        role="group"
        @segmented-button-interaction="${this.handleSegmentedButtonInteraction}"
        aria-label=${ariaLabel || nothing}
        class="md3-segmented-button-set">
        <slot></slot>
      </span>
    `;
  }

  protected getRenderClasses() {
    return {};
  }
}


/* ========== /segmentedbuttonset/internal/shared-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './shared';
// go/keep-sorted end

@include shared.styles;


// ========== /segmentedbuttonset/outlined-segmented-button-set.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {OutlinedSegmentedButtonSet} from './internal/outlined-segmented-button-set.js';
import {styles as outlinedStyles} from './internal/outlined-styles.js';
import {styles as sharedStyles} from './internal/shared-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-outlined-segmented-button-set': MdOutlinedSegmentedButtonSet;
  }
}

/**
 * MdOutlinedSegmentedButtonSet is the custom element for the Material
 * Design outlined segmented button set component.
 * @final
 * @suppress {visibility}
 */
@customElement('md-outlined-segmented-button-set')
export class MdOutlinedSegmentedButtonSet extends OutlinedSegmentedButtonSet {
  static override styles: CSSResultOrNative[] = [sharedStyles, outlinedStyles];
}