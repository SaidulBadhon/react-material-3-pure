/* ========== /_checkbox.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/checkbox' show theme;


// ========== /checkbox.ts ==========
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Checkbox} from './internal/checkbox.js';
import {styles} from './internal/checkbox-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-checkbox': MdCheckbox;
  }
}

/**
 * @summary Checkboxes allow users to select one or more items from a set.
 * Checkboxes can turn an option on or off.
 *
 * @description
 * Use checkboxes to:
 * - Select one or more options from a list
 * - Present a list containing sub-selections
 * - Turn an item on or off in a desktop environment
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-checkbox')
export class MdCheckbox extends Checkbox {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /checkbox_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)

import {html} from 'lit';

import {createFormTests} from '../testing/forms.js';
import {createTokenTests} from '../testing/tokens.js';

import {MdCheckbox} from './checkbox.js';

describe('<md-checkbox>', () => {
  describe('.styles', () => {
    createTokenTests(MdCheckbox.styles);
  });

  describe('forms', () => {
    createFormTests({
      queryControl: (root) => root.querySelector('md-checkbox'),
      valueTests: [
        {
          name: 'unnamed',
          render: () => html`<md-checkbox checked></md-checkbox>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form without a name')
              .toHaveSize(0);
          },
        },
        {
          name: 'unchecked',
          render: () => html`<md-checkbox name="checkbox"></md-checkbox>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when unchecked')
              .toHaveSize(0);
          },
        },
        {
          name: 'checked default value',
          render: () =>
            html`<md-checkbox name="checkbox" checked></md-checkbox>`,
          assertValue(formData) {
            expect(formData.get('checkbox')).toBe('on');
          },
        },
        {
          name: 'checked custom value',
          render: () =>
            html`<md-checkbox
              name="checkbox"
              checked
              value="Custom value"></md-checkbox>`,
          assertValue(formData) {
            expect(formData.get('checkbox')).toBe('Custom value');
          },
        },
        {
          name: 'indeterminate',
          render: () =>
            html`<md-checkbox
              name="checkbox"
              checked
              indeterminate></md-checkbox>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when indeterminate')
              .toHaveSize(0);
          },
        },
        {
          name: 'disabled',
          render: () =>
            html`<md-checkbox name="checkbox" checked disabled></md-checkbox>`,
          assertValue(formData) {
            expect(formData)
              .withContext('should not add anything to form when disabled')
              .toHaveSize(0);
          },
        },
      ],
      resetTests: [
        {
          name: 'reset to unchecked',
          render: () => html`<md-checkbox name="checkbox"></md-checkbox>`,
          change(checkbox) {
            checkbox.checked = true;
          },
          assertReset(checkbox) {
            expect(checkbox.checked)
              .withContext('checkbox.checked after reset')
              .toBeFalse();
          },
        },
        {
          name: 'reset to checked',
          render: () =>
            html`<md-checkbox name="checkbox" checked></md-checkbox>`,
          change(checkbox) {
            checkbox.checked = false;
          },
          assertReset(checkbox) {
            expect(checkbox.checked)
              .withContext('checkbox.checked after reset')
              .toBeTrue();
          },
        },
        {
          name: 'reset to indeterminate',
          render: () =>
            html`<md-checkbox name="checkbox" indeterminate></md-checkbox>`,
          change(checkbox) {
            checkbox.indeterminate = false;
          },
          assertReset(checkbox) {
            expect(checkbox.indeterminate)
              .withContext('checkbox.indeterminate should not be reset')
              .toBeFalse();
          },
        },
      ],
      restoreTests: [
        {
          name: 'restore unchecked',
          render: () => html`<md-checkbox name="checkbox"></md-checkbox>`,
          assertRestored(checkbox) {
            expect(checkbox.checked)
              .withContext('checkbox.checked after restore')
              .toBeFalse();
          },
        },
        {
          name: 'restore checked',
          render: () =>
            html`<md-checkbox name="checkbox" checked></md-checkbox>`,
          assertRestored(checkbox) {
            expect(checkbox.checked)
              .withContext('checkbox.checked after restore')
              .toBeTrue();
          },
        },
        {
          name: 'restore indeterminate',
          render: () =>
            html`<md-checkbox name="checkbox" indeterminate></md-checkbox>`,
          assertRestored(checkbox) {
            expect(checkbox.indeterminate)
              .withContext('checkbox.indeterminate should not be restored')
              .toBeFalse();
          },
        },
      ],
    });
  });
});


/* ========== /internal/_checkbox.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';
// go/keep-sorted end
// go/keep-sorted start
@use '../../ripple/ripple';
@use '../../tokens';
// go/keep-sorted end

// Motion token values.
$_md-sys-motion: tokens.md-sys-motion-values();
// The stroke width of the icon marks.
$_mark-stroke: 2px;
// The coordinates in an 18px viewBox of the bottom left corner of the
// indeterminate icon. Y is negative to fix an issue in Safari (see below).
$_indeterminate-bottom-left: 4px, -10px;
// The coordinates in an 18px viewBox of the bottom left corner of the
// checkmark icon. Y is negative to fix an issue in Safari (see below).
$_checkmark-bottom-left: 7px, -14px;

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-checkbox-supported-tokens;
  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-checkbox-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-checkbox-values();

  :host {
    border-start-start-radius: map.get($tokens, 'container-shape-start-start');
    border-start-end-radius: map.get($tokens, 'container-shape-start-end');
    border-end-end-radius: map.get($tokens, 'container-shape-end-end');
    border-end-start-radius: map.get($tokens, 'container-shape-end-start');
    display: inline-flex;
    height: map.get($tokens, 'container-size');
    position: relative;
    vertical-align: top; // Fix extra space when placed inside display: block
    width: map.get($tokens, 'container-size');
    -webkit-tap-highlight-color: transparent;
    cursor: pointer;
  }

  :host([disabled]) {
    cursor: default;
  }

  :host([touch-target='wrapper']) {
    margin: max(0px, ((48px - map.get($tokens, 'container-size')) / 2));
  }

  md-focus-ring {
    height: 44px;
    inset: unset;
    width: 44px;
  }

  // <input> is also the touch target
  input {
    appearance: none;
    height: 48px;
    margin: 0;
    opacity: 0;
    outline: none;
    position: absolute;
    width: 48px;
    z-index: 1;
    cursor: inherit;
  }

  :host([touch-target='none']) input {
    height: 100%;
    width: 100%;
  }

  .container {
    border-radius: inherit;
    display: flex;
    height: 100%;
    place-content: center;
    place-items: center;
    position: relative;
    width: 100%;
  }

  .outline,
  .background,
  .icon {
    inset: 0;
    position: absolute;
  }

  .outline,
  .background {
    border-radius: inherit;
  }

  .outline {
    border-color: map.get($tokens, 'outline-color');
    border-style: solid;
    border-width: map.get($tokens, 'outline-width');
    box-sizing: border-box;
  }

  .background {
    background-color: map.get($tokens, 'selected-container-color');
  }

  // Background and icon transitions.
  .background,
  .icon {
    opacity: 0; // Background and icon fade in
    transition-duration: 150ms, 50ms; // Exit duration for scale and opacity.
    transition-property: transform, opacity;
    // Exit easing function for scale, linear for opacity.
    transition-timing-function: map.get(
        $_md-sys-motion,
        easing-emphasized-accelerate
      ),
      linear;
    transform: scale(0.6); // Background and icon scale from 60% to 100%.
  }

  :where(.selected) :is(.background, .icon) {
    opacity: 1;
    // Enter duration for scale and opacity.
    transition-duration: 350ms, 50ms;
    // Enter easing function for scale, linear for opacity.
    transition-timing-function: map.get(
        $_md-sys-motion,
        easing-emphasized-decelerate
      ),
      linear;
    transform: scale(1);
  }

  // Ripple

  md-ripple {
    border-radius: map.get($tokens, 'state-layer-shape');
    height: map.get($tokens, 'state-layer-size');
    inset: unset;
    width: map.get($tokens, 'state-layer-size');

    @include ripple.theme(
      (
        hover-color: map.get($tokens, 'hover-state-layer-color'),
        hover-opacity: map.get($tokens, 'hover-state-layer-opacity'),
        pressed-color: map.get($tokens, 'pressed-state-layer-color'),
        pressed-opacity: map.get($tokens, 'pressed-state-layer-opacity'),
      )
    );
  }

  .selected md-ripple {
    @include ripple.theme(
      (
        hover-color: map.get($tokens, 'selected-hover-state-layer-color'),
        hover-opacity: map.get($tokens, 'selected-hover-state-layer-opacity'),
        pressed-color: map.get($tokens, 'selected-pressed-state-layer-color'),
        pressed-opacity:
          map.get($tokens, 'selected-pressed-state-layer-opacity'),
      )
    );
  }

  // Icon and icon marks

  .icon {
    // The icon is created with two <rect> marks for animation:
    // 1. Short end
    //   - the smaller leading part of the checkmark
    //   - hidden behind long end for indeterminate mark
    // 2. Long end
    //   - the larger trailing part of the checkmark
    //   - the entirety of the indeterminate mark
    fill: map.get($tokens, 'selected-icon-color');
    height: map.get($tokens, 'icon-size');
    width: map.get($tokens, 'icon-size');
  }

  // The short end of the checkmark. Initially hidden underneath the
  // indeterminate mark.
  .mark.short {
    height: $_mark-stroke;
    transition-property: transform, height;
    width: $_mark-stroke;
  }

  // The long end of the checkmark. Initially the indeterminate mark.
  .mark.long {
    height: $_mark-stroke;
    transition-property: transform, width;
    width: 10px;
  }

  // Exit duration and easing.
  .mark {
    animation-duration: 150ms;
    animation-timing-function: map.get(
      $_md-sys-motion,
      easing-emphasized-accelerate
    );
    transition-duration: 150ms;
    transition-timing-function: map.get(
      $_md-sys-motion,
      easing-emphasized-accelerate
    );
  }

  // Enter duration and easing.
  .selected .mark {
    animation-duration: 350ms;
    animation-timing-function: map.get(
      $_md-sys-motion,
      easing-emphasized-decelerate
    );
    transition-duration: 350ms;
    transition-timing-function: map.get(
      $_md-sys-motion,
      easing-emphasized-decelerate
    );
  }

  // Creates the checkmark icon.
  .checked,
  // Keep the checkmark shape when unselecting a checked checkbox.
  .prev-checked.unselected {
    .mark {
      // Transform from the bottom left of the rectangles, whch turn into the
      // bottom-most point of the checkmark.
      // Fix Safari's transform-origin bug from "top left" to "bottom left"
      $scale: scaleY(-1);
      // Move the "bottom left" corner to the checkmark location.
      $translate: translate($_checkmark-bottom-left);
      // Rotate the checkmark.
      $rotate: rotate(45deg);
      transform: $scale $translate $rotate;
    }

    .mark.short {
      // The right triangle that forms the short end has an X, Y length of
      // 4dp, 4dp. The hypoteneuse is √(4*4 + 4*4), which is the length of the
      // short end when checked.
      height: 1px * math.sqrt(32);
    }

    .mark.long {
      // The right triangle that forms the long end has an X, Y length of
      // 8dp, 8dp. The hypoteneuse is √(8*8 + 8*8), which is the length of the
      // long end when checked.
      width: 1px * math.sqrt(128);
    }
  }

  // Creates the indeterminate icon.
  .indeterminate,
  // Keep the indeterminate shape when unselecting an indeterminate checkbox.
  .prev-indeterminate.unselected {
    .mark {
      transform: scaleY(-1) translate($_indeterminate-bottom-left) rotate(0deg);
    }
  }

  // When selecting an unselected checkbox, don't transition between the
  // checked and indeterminate states. The checkmark icon or indeterminate icon
  // should fade in from its final position.
  .prev-unselected .mark {
    transition-property: none;
  }

  // When checking a checkbox, the long mark of the checkmark grows from the
  // bottom-most point of the checkmark. An animation provides the starting
  // width to animate from.
  .prev-unselected.checked .mark.long {
    animation-name: prev-unselected-to-checked;
  }
  @keyframes prev-unselected-to-checked {
    from {
      width: 0;
    }
  }

  // States

  :where(:hover) .outline {
    border-color: map.get($tokens, 'hover-outline-color');
    border-width: map.get($tokens, 'hover-outline-width');
  }

  :where(:hover) .background {
    background: map.get($tokens, 'selected-hover-container-color');
  }

  :where(:hover) .icon {
    fill: map.get($tokens, 'selected-hover-icon-color');
  }

  :where(:focus-within) .outline {
    border-color: map.get($tokens, 'focus-outline-color');
    border-width: map.get($tokens, 'focus-outline-width');
  }

  :where(:focus-within) .background {
    background: map.get($tokens, 'selected-focus-container-color');
  }

  :where(:focus-within) .icon {
    fill: map.get($tokens, 'selected-focus-icon-color');
  }

  :where(:active) .outline {
    border-color: map.get($tokens, 'pressed-outline-color');
    border-width: map.get($tokens, 'pressed-outline-width');
  }

  :where(:active) .background {
    background: map.get($tokens, 'selected-pressed-container-color');
  }

  :where(:active) .icon {
    fill: map.get($tokens, 'selected-pressed-icon-color');
  }

  // Don't animate to/from disabled states because the outline is hidden when
  // selected. Without this, there'd be a FOUC if the checkbox state is
  // programmatically  changed while disabled.
  :where(.disabled, .prev-disabled) :is(.background, .icon, .mark) {
    animation-duration: 0s;
    transition-duration: 0s;
  }

  :where(.disabled) .outline {
    border-color: map.get($tokens, 'disabled-outline-color');
    border-width: map.get($tokens, 'disabled-outline-width');
    opacity: map.get($tokens, 'disabled-container-opacity');
  }

  :where(.selected.disabled) .outline {
    // Hide the outline behind the transparent selected container color.
    // This can be removed once disabled colors are flattened.
    visibility: hidden;
  }

  :where(.selected.disabled) .background {
    // Set disabled opacity only when selected since opacity is used to show
    // or hide the container background.
    background: map.get($tokens, 'selected-disabled-container-color');
    opacity: map.get($tokens, 'selected-disabled-container-opacity');
  }

  :where(.disabled) .icon {
    fill: map.get($tokens, 'selected-disabled-icon-color');
  }

  @media (forced-colors: active) {
    .background {
      background-color: CanvasText;
    }

    .selected.disabled .background {
      background-color: GrayText;
      opacity: 1;
    }

    .outline {
      border-color: CanvasText;
    }

    .disabled .outline {
      border-color: GrayText;
      opacity: 1;
    }

    .icon {
      fill: Canvas;
    }
  }
}


/* ========== /internal/checkbox-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './checkbox';
// go/keep-sorted end

@include checkbox.styles;


// ========== /internal/checkbox.ts ==========
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../focus/md-focus-ring.js';
import '../../ripple/ripple.js';

import {html, isServer, LitElement, nothing, PropertyValues} from 'lit';
import {property, query, state} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';

import {ARIAMixinStrict} from '../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../internal/aria/delegate.js';
import {
  dispatchActivationClick,
  isActivationClick,
} from '../../internal/events/form-label-activation.js';
import {redispatchEvent} from '../../internal/events/redispatch-event.js';
import {
  createValidator,
  getValidityAnchor,
  mixinConstraintValidation,
} from '../../labs/behaviors/constraint-validation.js';
import {mixinElementInternals} from '../../labs/behaviors/element-internals.js';
import {
  getFormState,
  getFormValue,
  mixinFormAssociated,
} from '../../labs/behaviors/form-associated.js';
import {CheckboxValidator} from '../../labs/behaviors/validators/checkbox-validator.js';

// Separate variable needed for closure.
const checkboxBaseClass = mixinDelegatesAria(
  mixinConstraintValidation(
    mixinFormAssociated(mixinElementInternals(LitElement)),
  ),
);

/**
 * A checkbox component.
 *
 *
 * @fires change {Event} The native `change` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event)
 * --bubbles
 * @fires input {InputEvent} The native `input` event on
 * [`<input>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
 * --bubbles --composed
 */
export class Checkbox extends checkboxBaseClass {
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Whether or not the checkbox is selected.
   */
  @property({type: Boolean}) checked = false;

  /**
   * Whether or not the checkbox is indeterminate.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes
   */
  @property({type: Boolean}) indeterminate = false;

  /**
   * When true, require the checkbox to be selected when participating in
   * form submission.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#validation
   */
  @property({type: Boolean}) required = false;

  /**
   * The value of the checkbox that is submitted with a form when selected.
   *
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#value
   */
  @property() value = 'on';

  @state() private prevChecked = false;
  @state() private prevDisabled = false;
  @state() private prevIndeterminate = false;
  @query('input') private readonly input!: HTMLInputElement | null;

  constructor() {
    super();
    if (!isServer) {
      this.addEventListener('click', (event: MouseEvent) => {
        if (!isActivationClick(event) || !this.input) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.input);
      });
    }
  }

  protected override update(changed: PropertyValues<Checkbox>) {
    if (
      changed.has('checked') ||
      changed.has('disabled') ||
      changed.has('indeterminate')
    ) {
      this.prevChecked = changed.get('checked') ?? this.checked;
      this.prevDisabled = changed.get('disabled') ?? this.disabled;
      this.prevIndeterminate =
        changed.get('indeterminate') ?? this.indeterminate;
    }

    super.update(changed);
  }

  protected override render() {
    const prevNone = !this.prevChecked && !this.prevIndeterminate;
    const prevChecked = this.prevChecked && !this.prevIndeterminate;
    const prevIndeterminate = this.prevIndeterminate;
    const isChecked = this.checked && !this.indeterminate;
    const isIndeterminate = this.indeterminate;

    const containerClasses = classMap({
      'disabled': this.disabled,
      'selected': isChecked || isIndeterminate,
      'unselected': !isChecked && !isIndeterminate,
      'checked': isChecked,
      'indeterminate': isIndeterminate,
      'prev-unselected': prevNone,
      'prev-checked': prevChecked,
      'prev-indeterminate': prevIndeterminate,
      'prev-disabled': this.prevDisabled,
    });

    // Needed for closure conformance
    const {ariaLabel, ariaInvalid} = this as ARIAMixinStrict;
    // Note: <input> needs to be rendered before the <svg> for
    // form.reportValidity() to work in Chrome.
    return html`
      <div class="container ${containerClasses}">
        <input
          type="checkbox"
          id="input"
          aria-checked=${isIndeterminate ? 'mixed' : nothing}
          aria-label=${ariaLabel || nothing}
          aria-invalid=${ariaInvalid || nothing}
          ?disabled=${this.disabled}
          ?required=${this.required}
          .indeterminate=${this.indeterminate}
          .checked=${this.checked}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <div class="outline"></div>
        <div class="background"></div>
        <md-focus-ring part="focus-ring" for="input"></md-focus-ring>
        <md-ripple for="input" ?disabled=${this.disabled}></md-ripple>
        <svg class="icon" viewBox="0 0 18 18" aria-hidden="true">
          <rect class="mark short" />
          <rect class="mark long" />
        </svg>
      </div>
    `;
  }

  private handleInput(event: Event) {
    const target = event.target as HTMLInputElement;
    this.checked = target.checked;
    this.indeterminate = target.indeterminate;
    // <input> 'input' event bubbles and is composed, don't re-dispatch it.
  }

  private handleChange(event: Event) {
    // <input> 'change' event is not composed, re-dispatch it.
    redispatchEvent(this, event);
  }

  // Writable mixin properties for lit-html binding, needed for lit-analyzer
  declare disabled: boolean;
  declare name: string;

  override [getFormValue]() {
    if (!this.checked || this.indeterminate) {
      return null;
    }

    return this.value;
  }

  override [getFormState]() {
    return String(this.checked);
  }

  override formResetCallback() {
    // The checked property does not reflect, so the original attribute set by
    // the user is used to determine the default value.
    this.checked = this.hasAttribute('checked');
  }

  override formStateRestoreCallback(state: string) {
    this.checked = state === 'true';
  }

  override [createValidator]() {
    return new CheckboxValidator(() => this);
  }

  override [getValidityAnchor]() {
    return this.input;
  }
}


// ========== /internal/checkbox_test.ts ==========
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html} from 'lit';

import {Environment} from '../../testing/environment.js';
import {CheckboxHarness} from '../harness.js';

import {Checkbox} from './checkbox.js';

customElements.define('md-test-checkbox', Checkbox);

declare global {
  interface HTMLElementTagNameMap {
    'md-test-checkbox': Checkbox;
  }
}

describe('checkbox', () => {
  const env = new Environment();

  async function setupTest(
    template = html`<md-test-checkbox></md-test-checkbox>`,
  ) {
    const element = env.render(template).querySelector('md-test-checkbox');
    if (!element) {
      throw new Error('Could not query rendered <md-test-checkbox>.');
    }

    await env.waitForStability();
    const input = element.renderRoot.querySelector('input');
    if (!input) {
      throw new Error('Could not query rendered <input>.');
    }

    return {
      input,
      harness: new CheckboxHarness(element),
    };
  }

  describe('basic', () => {
    it('initializes as a checkbox', async () => {
      const {harness} = await setupTest();
      expect(harness.element).toBeInstanceOf(Checkbox);
      expect(harness.element.checked).toEqual(false);
      expect(harness.element.indeterminate).toEqual(false);
      expect(harness.element.disabled).toEqual(false);
      expect(harness.element.value).toEqual('on');
    });

    it('user input updates checked state', async () => {
      const {harness} = await setupTest();
      await harness.clickWithMouse();
      await env.waitForStability();
      expect(harness.element.checked).toEqual(true);
    });

    it('should trigger changed event when checkbox is selected', async () => {
      const {harness} = await setupTest();
      const changeHandler = jasmine.createSpy('changeHandler');
      harness.element.addEventListener('change', changeHandler);

      await harness.clickWithMouse();

      expect(harness.element.checked).toBeTrue();
      expect(changeHandler).toHaveBeenCalledTimes(1);
      expect(changeHandler).toHaveBeenCalledWith(jasmine.any(Event));
    });

    it('should trigger input event when checkbox is selected', async () => {
      const {harness} = await setupTest();
      const inputHandler = jasmine.createSpy('inputHandler');
      harness.element.addEventListener('input', inputHandler);

      await harness.clickWithMouse();

      expect(harness.element.checked).toBeTrue();
      expect(inputHandler).toHaveBeenCalledTimes(1);
      expect(inputHandler).toHaveBeenCalledWith(jasmine.any(Event));
    });

    it('checkbox state is updated during input event listeners', async () => {
      const {harness} = await setupTest();
      let state = false;
      const inputHandler = jasmine
        .createSpy('inputHandler')
        .and.callFake(() => {
          state = harness.element.checked;
        });

      harness.element.addEventListener('input', inputHandler);

      await harness.clickWithMouse();
      expect(inputHandler).withContext('input listener').toHaveBeenCalled();
      expect(state)
        .withContext('checkbox.checked during input listener')
        .toBeTrue();
    });

    it('checkbox state is updated during change event listeners', async () => {
      const {harness} = await setupTest();
      let state = false;
      const changeHandler = jasmine
        .createSpy('changeHandler')
        .and.callFake(() => {
          state = harness.element.checked;
        });

      harness.element.addEventListener('change', changeHandler);

      await harness.clickWithMouse();
      expect(changeHandler).withContext('change listener').toHaveBeenCalled();
      expect(state)
        .withContext('checkbox.checked during change listener')
        .toBeTrue();
    });
  });

  describe('checked', () => {
    it('get/set updates the checked property on the native checkbox element', async () => {
      const {harness, input} = await setupTest();
      harness.element.checked = true;
      await env.waitForStability();
      expect(input.checked).toEqual(true);
      harness.element.checked = false;
      await env.waitForStability();
      expect(input.checked).toEqual(false);
    });

    it('get/set updates the checked property after user updates checked state', async () => {
      const {harness, input} = await setupTest();

      // Simulate user interaction setting checked to true.
      await harness.clickWithMouse();
      await env.waitForStability();
      expect(input.checked).toEqual(true);
      expect(harness.element.checked).toEqual(true);

      // Set custom element checked to false.
      harness.element.checked = false;
      await env.waitForStability();
      expect(input.checked).toEqual(false);
      expect(harness.element.checked).toEqual(false);

      // Set custom element checked to true.
      harness.element.checked = true;
      await env.waitForStability();
      expect(input.checked).toEqual(true);
      expect(harness.element.checked).toEqual(true);
    });
  });

  describe('indeterminate', () => {
    it('get/set updates the indeterminate property on the native checkbox element', async () => {
      const {harness, input} = await setupTest();
      harness.element.indeterminate = true;
      await env.waitForStability();

      expect(input.indeterminate).toEqual(true);
      expect(input.getAttribute('aria-checked')).toEqual('mixed');

      harness.element.indeterminate = false;
      await env.waitForStability();

      expect(input.indeterminate).toEqual(false);
      expect(input.getAttribute('aria-checked')).not.toEqual('mixed');
    });
  });

  describe('disabled', () => {
    it('get/set updates the disabled property on the native checkbox element', async () => {
      const {harness, input} = await setupTest();
      harness.element.disabled = true;
      await env.waitForStability();

      expect(input.disabled).toEqual(true);
      harness.element.disabled = false;
      await env.waitForStability();
      expect(input.disabled).toEqual(false);
    });
  });

  describe('form submission', () => {
    async function setupFormTest(propsInit: Partial<Checkbox> = {}) {
      return await setupTest(html` <form>
        <md-test-checkbox
          .checked=${propsInit.checked === true}
          .disabled=${propsInit.disabled === true}
          .name=${propsInit.name ?? ''}
          .value=${propsInit.value ?? ''}></md-test-checkbox>
      </form>`);
    }

    it('does not submit if not checked', async () => {
      const {harness} = await setupFormTest({name: 'foo'});
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toBeNull();
    });

    it('does not submit if disabled', async () => {
      const {harness} = await setupFormTest({
        name: 'foo',
        checked: true,
        disabled: true,
      });
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toBeNull();
    });

    it('does not submit if name is not provided', async () => {
      const {harness} = await setupFormTest({checked: true});
      const formData = await harness.submitForm();
      const keys = Array.from(formData.keys());
      expect(keys.length).toEqual(0);
    });

    it('submits under correct conditions', async () => {
      const {harness} = await setupFormTest({
        name: 'foo',
        checked: true,
        value: 'bar',
      });
      const formData = await harness.submitForm();
      expect(formData.get('foo')).toEqual('bar');
    });
  });

  describe('label activation', () => {
    async function setupLabelTest() {
      const test = await setupTest(html`
        <label>
          <md-test-checkbox></md-test-checkbox>
        </label>
      `);
      const label = (
        test.harness.element.getRootNode() as HTMLElement
      ).querySelector<HTMLLabelElement>('label')!;
      return {...test, label};
    }

    it('toggles when label is clicked', async () => {
      const {
        harness: {element},
        label,
      } = await setupLabelTest();
      label.click();
      await env.waitForStability();
      expect(element.checked).toBeTrue();
      label.click();
      await env.waitForStability();
      expect(element.checked).toBeFalse();
    });
  });

  describe('validation', () => {
    it('should set valueMissing when required and not selected', async () => {
      const {harness} = await setupTest();
      harness.element.required = true;

      expect(harness.element.validity.valueMissing)
        .withContext('checkbox.validity.valueMissing')
        .toBeTrue();
    });

    it('should not set valueMissing when required and checked', async () => {
      const {harness} = await setupTest();
      harness.element.required = true;
      harness.element.checked = true;

      expect(harness.element.validity.valueMissing)
        .withContext('checkbox.validity.valueMissing')
        .toBeFalse();
    });

    it('should set valueMissing when required and indeterminate', async () => {
      const {harness} = await setupTest();
      harness.element.required = true;
      harness.element.indeterminate = true;

      expect(harness.element.validity.valueMissing)
        .withContext('checkbox.validity.valueMissing')
        .toBeTrue();
    });
  });
});