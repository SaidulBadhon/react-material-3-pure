/* ========== /_menu-item.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/menuitem/menu-item' show theme;


/* ========== /_menu.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@forward './internal/menu' show theme;


/* ========== /internal/_menu.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
// go/keep-sorted end
// go/keep-sorted start
@use '../../elevation/elevation';
@use '../../focus/focus-ring';
@use '../../list/list' as md-list;
@use '../../list/list-item';
@use '../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-menu-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-menu-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-menu-values();

  :host {
    @include elevation.theme(
      (
        'level': map.get($tokens, 'container-elevation'),
        'shadow-color': map.get($tokens, 'container-shadow-color'),
      )
    );

    min-width: 112px;
    color: unset;
    display: contents;
  }

  md-focus-ring {
    @include focus-ring.theme(
      (
        'shape': map.get($tokens, 'container-shape'),
      )
    );
  }

  .menu {
    border-radius: map.get($tokens, 'container-shape');
    display: none;
    inset: auto;
    border: none;
    padding: 0px;
    overflow: visible;
    // [popover] adds a canvas background
    background-color: transparent;
    color: inherit;
    opacity: 0;
    z-index: 20;
    position: absolute;
    user-select: none;
    max-height: inherit;
    height: inherit;
    min-width: inherit;
    max-width: inherit;
    scrollbar-width: inherit;
  }

  .menu::backdrop {
    display: none;
  }

  .fixed {
    position: fixed;
  }

  .items {
    display: block;
    list-style-type: none;
    margin: 0;
    outline: none;
    box-sizing: border-box;
    background-color: map.get($tokens, 'container-color');
    height: inherit;
    max-height: inherit;
    overflow: auto;
    min-width: inherit;
    max-width: inherit;
    border-radius: inherit;
    scrollbar-width: inherit;
  }

  .item-padding {
    padding-block: map.get($tokens, 'top-space')
      map.get($tokens, 'bottom-space');
  }

  .has-overflow:not([popover]) .items {
    overflow: visible;
  }

  .has-overflow.animating .items,
  .animating .items {
    overflow: hidden;
  }

  .has-overflow.animating .items {
    // Often has-overlow is set because there are submenus. Since we need
    // overflow to be hidden to make the animation work, we need to disable
    // submenus opening mid-animation or else it looks completely wrong.
    pointer-events: none;
  }

  .animating ::slotted(.md-menu-hidden) {
    opacity: 0;
  }

  slot {
    display: block;
    height: inherit;
    max-height: inherit;
  }

  ::slotted(:is(md-divider, [role='separator'])) {
    margin: 8px 0;
  }

  @media (forced-colors: active) {
    .menu {
      border-style: solid;
      border-color: CanvasText;
      border-width: 1px;
    }
  }
}


// ========== /internal/controllers/menuItemController.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {ReactiveController, ReactiveControllerHost} from 'lit';

import {
  CloseReason,
  createDefaultCloseMenuEvent,
  isClosableKey,
} from './shared.js';

/**
 * Interface specific to menu item and not HTMLElement.
 *
 * NOTE: required properties are expected to be reactive.
 */
interface MenuItemAdditions {
  /**
   * Whether or not the item is in the disabled state.
   */
  disabled: boolean;
  /**
   * The text of the item that will be used for typeahead. If not set, defaults
   * to the textContent of the element slotted into the headline.
   */
  typeaheadText: string;
  /**
   * Whether or not the item is in the selected visual state.
   */
  selected: boolean;
  /**
   * Sets the behavior and role of the menu item, defaults to "menuitem".
   */
  type: MenuItemType;
  /**
   * Whether it should keep the menu open after click.
   */
  keepOpen?: boolean;
  /**
   * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
   */
  href?: string;
  /**
   * Focuses the item.
   */
  focus: () => void;
}

/**
 * The interface of every menu item interactive with a menu. All menu items
 * should implement this interface to be compatible with md-menu. Additionally
 * it should have the `md-menu-item` attribute set.
 *
 * NOTE, the required properties are recommended to be reactive properties.
 */
export type MenuItem = MenuItemAdditions & HTMLElement;

/**
 * Supported behaviors for a menu item.
 */
export type MenuItemType = 'menuitem' | 'option' | 'button' | 'link';

/**
 * The options used to inialize MenuItemController.
 */
export interface MenuItemControllerConfig {
  /**
   * A function that returns the headline element of the menu item.
   */
  getHeadlineElements: () => HTMLElement[];

  /**
   * A function that returns the supporting-text element of the menu item.
   */
  getSupportingTextElements: () => HTMLElement[];

  /**
   * A function that returns the default slot / misc content.
   */
  getDefaultElements: () => Node[];

  /**
   * The HTML Element that accepts user interactions like click. Used for
   * occasions like programmatically clicking anchor tags when `Enter` is
   * pressed.
   */
  getInteractiveElement: () => HTMLElement | null;
}

/**
 * A controller that provides most functionality of an element that implements
 * the MenuItem interface.
 */
export class MenuItemController implements ReactiveController {
  private internalTypeaheadText: string | null = null;
  private readonly getHeadlineElements: MenuItemControllerConfig['getHeadlineElements'];
  private readonly getSupportingTextElements: MenuItemControllerConfig['getSupportingTextElements'];
  private readonly getDefaultElements: MenuItemControllerConfig['getDefaultElements'];
  private readonly getInteractiveElement: MenuItemControllerConfig['getInteractiveElement'];

  /**
   * @param host The MenuItem in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(
    private readonly host: ReactiveControllerHost & MenuItem,
    config: MenuItemControllerConfig,
  ) {
    this.getHeadlineElements = config.getHeadlineElements;
    this.getSupportingTextElements = config.getSupportingTextElements;
    this.getDefaultElements = config.getDefaultElements;
    this.getInteractiveElement = config.getInteractiveElement;
    this.host.addController(this);
  }

  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    if (this.internalTypeaheadText !== null) {
      return this.internalTypeaheadText;
    }

    const headlineElements = this.getHeadlineElements();

    const textParts: string[] = [];
    headlineElements.forEach((headlineElement) => {
      if (headlineElement.textContent && headlineElement.textContent.trim()) {
        textParts.push(headlineElement.textContent.trim());
      }
    });

    // If there are no headline elements, check the default slot's text content
    if (textParts.length === 0) {
      this.getDefaultElements().forEach((defaultElement) => {
        if (defaultElement.textContent && defaultElement.textContent.trim()) {
          textParts.push(defaultElement.textContent.trim());
        }
      });
    }

    // If there are no headline nor default slot elements, check the
    //supporting-text slot's text content
    if (textParts.length === 0) {
      this.getSupportingTextElements().forEach((supportingTextElement) => {
        if (
          supportingTextElement.textContent &&
          supportingTextElement.textContent.trim()
        ) {
          textParts.push(supportingTextElement.textContent.trim());
        }
      });
    }

    return textParts.join(' ');
  }

  /**
   * The recommended tag name to render as the list item.
   */
  get tagName() {
    const type = this.host.type;

    switch (type) {
      case 'link':
        return 'a' as const;
      case 'button':
        return 'button' as const;
      default:
      case 'menuitem':
      case 'option':
        return 'li' as const;
    }
  }

  /**
   * The recommended role of the menu item.
   */
  get role() {
    return this.host.type === 'option' ? 'option' : 'menuitem';
  }

  hostConnected() {
    this.host.toggleAttribute('md-menu-item', true);
  }

  hostUpdate() {
    if (this.host.href) {
      this.host.type = 'link';
    }
  }

  /**
   * Bind this click listener to the interactive element. Handles closing the
   * menu.
   */
  onClick = () => {
    if (this.host.keepOpen) return;

    this.host.dispatchEvent(
      createDefaultCloseMenuEvent(this.host, {
        kind: CloseReason.CLICK_SELECTION,
      }),
    );
  };

  /**
   * Bind this click listener to the interactive element. Handles closing the
   * menu.
   */
  onKeydown = (event: KeyboardEvent) => {
    // Check if the interactive element is an anchor tag. If so, click it.
    if (this.host.href && event.code === 'Enter') {
      const interactiveElement = this.getInteractiveElement();
      if (interactiveElement instanceof HTMLAnchorElement) {
        interactiveElement.click();
      }
    }

    if (event.defaultPrevented) return;

    // If the host has keepOpen = true we should ignore clicks & Space/Enter,
    // however we always maintain the ability to close a menu with a explicit
    // `escape` keypress.
    const keyCode = event.code;
    if (this.host.keepOpen && keyCode !== 'Escape') return;

    if (isClosableKey(keyCode)) {
      event.preventDefault();
      this.host.dispatchEvent(
        createDefaultCloseMenuEvent(this.host, {
          kind: CloseReason.KEYDOWN,
          key: keyCode,
        }),
      );
    }
  };

  /**
   * Use to set the typeaheadText when it changes.
   */
  setTypeaheadText(text: string) {
    this.internalTypeaheadText = text;
  }
}


// ========== /internal/controllers/shared.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {LitElement} from 'lit';

import {MenuItem} from './menuItemController.js';
import type {Corner, SurfacePositionTarget} from './surfacePositionController.js';

/**
 * The interface needed for a Menu to work with other md-menu elements.
 */
export interface MenuSelf {
  /**
   * Whether or not the menu is currently opened.
   */
  open: boolean;
  /**
   * Skips the opening and closing animations.
   */
  quick: boolean;
  /**
   * Displays overflow content like a submenu.
   *
   * __NOTE__: This may cause adverse effects if you set
   * `md-menu {max-height:...}`
   * and have items overflowing items in the "y" direction.
   */
  hasOverflow: boolean;
  /**
   * Communicates to the menu that it is a submenu and should not handle the
   * ArrowLeft button in LTR and ArrowRight button in RTL.
   */
  isSubmenu: boolean;
  /**
   * After closing, does not restore focus to the last focused element before
   * the menu was opened.
   */
  skipRestoreFocus: boolean;
  /**
   * The corner of the anchor in which the menu should anchor to.
   */
  anchorCorner: Corner;
  /**
   * The corner of the menu in which the menu should anchor from.
   */
  menuCorner: Corner;
  /**
   * The element the menu should anchor to.
   */
  anchorElement: (HTMLElement & Partial<SurfacePositionTarget>) | null;
  /**
   * What the menu should focus by default when opened.
   */
  defaultFocus: FocusState;
  /**
   * An array of items managed by the list.
   */
  items: MenuItem[];
  /**
   * The positioning strategy of the menu.
   *
   * - `absolute` is relative to the anchor element.
   * - `fixed` is relative to the window
   * - `document` is relative to the document
   */
  positioning?: 'absolute' | 'fixed' | 'document';
  /**
   * Opens the menu.
   */
  show: () => void;
  /**
   * Closes the menu.
   */
  close: () => void;
}

/**
 * The interface needed for a Menu to work with other md-menu elements. Useful
 * for keeping your types safe when wrapping `md-menu`.
 */
export type Menu = MenuSelf & LitElement;

/**
 * The reason the `close-menu` event was dispatched.
 */
export interface Reason {
  kind: string;
}

/**
 * The click selection reason for the `close-menu` event. The menu was closed
 * because an item was selected via user click.
 */
export interface ClickReason extends Reason {
  kind: typeof CloseReason.CLICK_SELECTION;
}

/**
 * The keydown reason for the `close-menu` event. The menu was closed
 * because a specific key was pressed. The default closing keys for
 * `md-menu-item` are, Space, Enter or Escape.
 */
export interface KeydownReason extends Reason {
  kind: typeof CloseReason.KEYDOWN;
  key: string;
}

/**
 * The default menu closing reasons for the material md-menu package.
 */
export type DefaultReasons = ClickReason | KeydownReason;

/**
 * Creates an event that closes any parent menus.
 */
export function createCloseMenuEvent<T extends Reason = DefaultReasons>(
  initiator: MenuItem,
  reason: T,
) {
  return new CustomEvent<{
    initiator: MenuItem;
    itemPath: MenuItem[];
    reason: T;
  }>('close-menu', {
    bubbles: true,
    composed: true,
    detail: {initiator, reason, itemPath: [initiator]},
  });
}

/**
 * Creates an event that signals to the menu that it should stay open on the
 * focusout event.
 */
export function createStayOpenOnFocusoutEvent() {
  return new Event('stay-open-on-focusout', {bubbles: true, composed: true});
}

/**
 * Creates an event that signals to the menu that it should close open on the
 * focusout event.
 */
export function createCloseOnFocusoutEvent() {
  return new Event('close-on-focusout', {bubbles: true, composed: true});
}

/**
 * Creates a default close menu event used by md-menu.
 */
export const createDefaultCloseMenuEvent = createCloseMenuEvent<DefaultReasons>;

/**
 * The type of the default close menu event used by md-menu.
 */
// tslint:disable-next-line
export type CloseMenuEvent<T extends Reason = DefaultReasons> = ReturnType<
  typeof createCloseMenuEvent<T>
>;

/**
 * Creates an event that requests the given item be selected.
 */
export function createDeactivateTypeaheadEvent() {
  return new Event('deactivate-typeahead', {bubbles: true, composed: true});
}

/**
 * The type of the event that requests the typeahead functionality of containing
 * menu be deactivated.
 */
export type DeactivateTypeaheadEvent = ReturnType<
  typeof createDeactivateTypeaheadEvent
>;

/**
 * Creates an event that requests the typeahead functionality of containing menu
 * be activated.
 */
export function createActivateTypeaheadEvent() {
  return new Event('activate-typeahead', {bubbles: true, composed: true});
}

/**
 * The type of the event that requests the typeahead functionality of containing
 * menu be activated.
 */
export type ActivateTypeaheadEvent = ReturnType<
  typeof createActivateTypeaheadEvent
>;

/**
 * Keys that are used to navigate menus.
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const NavigableKey = {
  UP: 'ArrowUp',
  DOWN: 'ArrowDown',
  RIGHT: 'ArrowRight',
  LEFT: 'ArrowLeft',
} as const;

/**
 * Keys that are used for selection in menus.
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const SelectionKey = {
  SPACE: 'Space',
  ENTER: 'Enter',
} as const;

/**
 * Default close `Reason` kind values.
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const CloseReason = {
  CLICK_SELECTION: 'click-selection',
  KEYDOWN: 'keydown',
} as const;

/**
 * Keys that can close menus.
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const KeydownCloseKey = {
  ESCAPE: 'Escape',
  SPACE: SelectionKey.SPACE,
  ENTER: SelectionKey.ENTER,
} as const;

type Values<T> = T[keyof T];

/**
 * Determines whether the given key code is a key code that should close the
 * menu.
 *
 * @param code The KeyboardEvent code to check.
 * @return Whether or not the key code is in the predetermined list to close the
 * menu.
 */
export function isClosableKey(
  code: string,
): code is Values<typeof KeydownCloseKey> {
  return Object.values(KeydownCloseKey).some((value) => value === code);
}

/**
 * Determines whether the given key code is a key code that should select a menu
 * item.
 *
 * @param code They KeyboardEvent code to check.
 * @return Whether or not the key code is in the predetermined list to select a
 * menu item.
 */
export function isSelectableKey(
  code: string,
): code is Values<typeof SelectionKey> {
  return Object.values(SelectionKey).some((value) => value === code);
}

/**
 * Determines whether a target element is contained inside another element's
 * composed tree.
 *
 * @param target The potential contained element.
 * @param container The potential containing element of the target.
 * @returns Whether the target element is contained inside the container's
 * composed subtree
 */
export function isElementInSubtree(
  target: EventTarget,
  container: EventTarget,
) {
  // Dispatch a composed, bubbling event to check its path to see if the
  // newly-focused element is contained in container's subtree
  const focusEv = new Event('md-contains', {bubbles: true, composed: true});
  let composedPath: EventTarget[] = [];
  const listener = (ev: Event) => {
    composedPath = ev.composedPath();
  };

  container.addEventListener('md-contains', listener);
  target.dispatchEvent(focusEv);
  container.removeEventListener('md-contains', listener);

  const isContained = composedPath.length > 0;
  return isContained;
}

/**
 * Element to focus on when menu is first opened.
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const FocusState = {
  NONE: 'none',
  LIST_ROOT: 'list-root',
  FIRST_ITEM: 'first-item',
  LAST_ITEM: 'last-item',
} as const;

/**
 * Element to focus on when menu is first opened.
 */
export type FocusState = (typeof FocusState)[keyof typeof FocusState];


// ========== /internal/controllers/surfacePositionController.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {ReactiveController, ReactiveControllerHost} from 'lit';
import {StyleInfo} from 'lit/directives/style-map.js';

/**
 * Declare popoverAPI functions and properties. See
 * https://developer.mozilla.org/en-US/docs/Web/API/Popover_API
 * Without this, closure will rename these functions. Can remove once these
 * functions make it into the typescript lib.
 */
declare global {
  interface HTMLElement {
    showPopover(): void;
    hidePopover(): void;
    togglePopover(force: boolean): void;
    popover: string | null;
  }
}

/**
 * An enum of supported Menu corners
 */
// tslint:disable-next-line:enforce-name-casing We are mimicking enum style
export const Corner = {
  END_START: 'end-start',
  END_END: 'end-end',
  START_START: 'start-start',
  START_END: 'start-end',
} as const;

/**
 * A corner of a box in the standard logical property style of <block>_<inline>
 */
export type Corner = (typeof Corner)[keyof typeof Corner];

/**
 * An interface that provides a method to customize the rect from which to
 * calculate the anchor positioning. Useful for when you want a surface to
 * anchor to an element in your shadow DOM rather than the host element.
 */
export interface SurfacePositionTarget extends HTMLElement {
  getSurfacePositionClientRect?: () => DOMRect;
}

/**
 * The configurable options for the surface position controller.
 */
export interface SurfacePositionControllerProperties {
  /**
   * Disable the `flip` behavior on the block axis of the surface's corner
   */
  disableBlockFlip: boolean;
  /**
   * Disable the `flip` behavior on the inline axis of the surface's corner
   */
  disableInlineFlip: boolean;
  /**
   * The corner of the anchor to align the surface's position.
   */
  anchorCorner: Corner;
  /**
   * The corner of the surface to align to the given anchor corner.
   */
  surfaceCorner: Corner;
  /**
   * The HTMLElement reference of the surface to be positioned.
   */
  surfaceEl: SurfacePositionTarget | null;
  /**
   * The HTMLElement reference of the anchor to align to.
   */
  anchorEl: SurfacePositionTarget | null;
  /**
   * Whether the positioning algorithim should calculate relative to the parent
   * of the anchor element (absolute) or relative to the window (fixed).
   *
   * Examples for `position = 'fixed'`:
   *
   * - If there is no `position:relative` in the given parent tree and the
   *   surface is `position:absolute`
   * - If the surface is `position:fixed`
   * - If the surface is in the "top layer"
   * - The anchor and the surface do not share a common `position:relative`
   *   ancestor
   */
  positioning: 'absolute' | 'fixed' | 'document';
  /**
   * Whether or not the surface should be "open" and visible
   */
  isOpen: boolean;
  /**
   * The number of pixels in which to offset from the inline axis relative to
   * logical property.
   *
   * Positive is right in LTR and left in RTL.
   */
  xOffset: number;
  /**
   * The number of pixes in which to offset the block axis.
   *
   * Positive is down and negative is up.
   */
  yOffset: number;
  /**
   * The strategy to follow when repositioning the menu to stay inside the
   * viewport. "move" will simply move the surface to stay in the viewport.
   * "resize" will attempt to resize the surface.
   *
   * Both strategies will still attempt to flip the anchor and surface corners.
   */
  repositionStrategy: 'move' | 'resize';
  /**
   * A function to call after the surface has been positioned.
   */
  onOpen: () => void;
  /**
   * A function to call before the surface should be closed. (A good time to
   * perform animations while the surface is still visible)
   */
  beforeClose: () => Promise<void>;
  /**
   * A function to call after the surface has been closed.
   */
  onClose: () => void;
}

/**
 * Given a surface, an anchor, corners, and some options, this surface will
 * calculate the position of a surface to align the two given corners and keep
 * the surface inside the window viewport. It also provides a StyleInfo map that
 * can be applied to the surface to handle visiblility and position.
 */
export class SurfacePositionController implements ReactiveController {
  // The current styles to apply to the surface.
  private surfaceStylesInternal: StyleInfo = {
    'display': 'none',
  };
  // Previous values stored for change detection. Open change detection is
  // calculated separately so initialize it here.
  private lastValues: SurfacePositionControllerProperties = {
    isOpen: false,
  } as SurfacePositionControllerProperties;

  /**
   * @param host The host to connect the controller to.
   * @param getProperties A function that returns the properties for the
   * controller.
   */
  constructor(
    private readonly host: ReactiveControllerHost,
    private readonly getProperties: () => SurfacePositionControllerProperties,
  ) {
    this.host.addController(this);
  }

  /**
   * The StyleInfo map to apply to the surface via Lit's stylemap
   */
  get surfaceStyles() {
    return this.surfaceStylesInternal;
  }

  /**
   * Calculates the surface's new position required so that the surface's
   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the
   * surface inside the window viewport. This positioning also respects RTL by
   * checking `getComputedStyle()` on the surface element.
   */
  async position() {
    const {
      surfaceEl,
      anchorEl,
      anchorCorner: anchorCornerRaw,
      surfaceCorner: surfaceCornerRaw,
      positioning,
      xOffset,
      yOffset,
      disableBlockFlip,
      disableInlineFlip,
      repositionStrategy,
    } = this.getProperties();
    const anchorCorner = anchorCornerRaw.toLowerCase().trim();
    const surfaceCorner = surfaceCornerRaw.toLowerCase().trim();

    if (!surfaceEl || !anchorEl) {
      return;
    }

    // Store these before we potentially resize the window with the next set of
    // lines
    const windowInnerWidth = window.innerWidth;
    const windowInnerHeight = window.innerHeight;

    const div = document.createElement('div');
    div.style.opacity = '0';
    div.style.position = 'fixed';
    div.style.display = 'block';
    div.style.inset = '0';
    document.body.appendChild(div);
    const scrollbarTestRect = div.getBoundingClientRect();
    div.remove();

    // Calculate the widths of the scrollbars in the inline and block directions
    // to account for window-relative calculations.
    const blockScrollbarHeight = window.innerHeight - scrollbarTestRect.bottom;
    const inlineScrollbarWidth = window.innerWidth - scrollbarTestRect.right;

    // Paint the surface transparently so that we can get the position and the
    // rect info of the surface.
    this.surfaceStylesInternal = {
      'display': 'block',
      'opacity': '0',
    };

    // Wait for it to be visible.
    this.host.requestUpdate();
    await this.host.updateComplete;

    // Safari has a bug that makes popovers render incorrectly if the node is
    // made visible + Animation Frame before calling showPopover().
    // https://bugs.webkit.org/show_bug.cgi?id=264069
    // also the cast is required due to differing TS types in Google and OSS.
    if (
      (surfaceEl as unknown as {popover: string}).popover &&
      surfaceEl.isConnected
    ) {
      (surfaceEl as unknown as {showPopover: () => void}).showPopover();
    }

    const surfaceRect = surfaceEl.getSurfacePositionClientRect
      ? surfaceEl.getSurfacePositionClientRect()
      : surfaceEl.getBoundingClientRect();
    const anchorRect = anchorEl.getSurfacePositionClientRect
      ? anchorEl.getSurfacePositionClientRect()
      : anchorEl.getBoundingClientRect();
    const [surfaceBlock, surfaceInline] = surfaceCorner.split('-') as Array<
      'start' | 'end'
    >;
    const [anchorBlock, anchorInline] = anchorCorner.split('-') as Array<
      'start' | 'end'
    >;

    // LTR depends on the direction of the SURFACE not the anchor.
    const isLTR =
      getComputedStyle(surfaceEl as HTMLElement).direction === 'ltr';

    /*
     * For more on inline and block dimensions, see MDN article:
     * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_logical_properties_and_values
     *
     * ┌───── inline/blockDocumentOffset  inlineScrollbarWidth
     * │       │                                    │
     * │     ┌─▼─────┐                              │Document
     * │    ┌┼───────┴──────────────────────────────┼────────┐
     * │    ││                                      │        │
     * └──► ││ ┌───── inline/blockWindowOffset      │        │
     *      ││ │       │                            ▼        │
     *      ││ │     ┌─▼───┐                 Window┌┐        │
     *      └┤ │    ┌┼─────┴───────────────────────┼│        │
     *       │ │    ││                             ││        │
     *       │ └──► ││  ┌──inline/blockAnchorOffset││        │
     *       │      ││  │     │                    ││        │
     *       │      └┤  │  ┌──▼───┐                ││        │
     *       │       │  │ ┌┼──────┤                ││        │
     *       │       │  └─►│Anchor│                ││        │
     *       │       │    └┴──────┘                ││        │
     *       │       │                             ││        │
     *       │       │     ┌───────────────────────┼┼────┐   │
     *       │       │     │ Surface               ││    │   │
     *       │       │     │                       ││    │   │
     *       │       │     │                       ││    │   │
     *       │       │     │                       ││    │   │
     *       │       │     │                       ││    │   │
     *       │      ┌┼─────┼───────────────────────┼│    │   │
     *       │   ┌─►┴──────┼────────────────────────┘    ├┐  │
     *       │   │         │ inline/blockOOBCorrection   ││  │
     *       │   │         │                         │   ││  │
     *       │   │         │                         ├──►├│  │
     *       │   │         │                         │   ││  │
     *       │   │         └────────────────────────┐▼───┼┘  │
     *       │  blockScrollbarHeight                └────┘   │
     *       │                                               │
     *       └───────────────────────────────────────────────┘
     */

    // Calculate the block positioning properties
    let {blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty} =
      this.calculateBlock({
        surfaceRect,
        anchorRect,
        anchorBlock,
        surfaceBlock,
        yOffset,
        positioning,
        windowInnerHeight,
        blockScrollbarHeight,
      });

    // If the surface should be out of bounds in the block direction, flip the
    // surface and anchor corner block values and recalculate
    if (blockOutOfBoundsCorrection && !disableBlockFlip) {
      const flippedSurfaceBlock = surfaceBlock === 'start' ? 'end' : 'start';
      const flippedAnchorBlock = anchorBlock === 'start' ? 'end' : 'start';

      const flippedBlock = this.calculateBlock({
        surfaceRect,
        anchorRect,
        anchorBlock: flippedAnchorBlock,
        surfaceBlock: flippedSurfaceBlock,
        yOffset,
        positioning,
        windowInnerHeight,
        blockScrollbarHeight,
      });

      // In the case that the flipped verion would require less out of bounds
      // correcting, use the flipped corner block values
      if (
        blockOutOfBoundsCorrection > flippedBlock.blockOutOfBoundsCorrection
      ) {
        blockInset = flippedBlock.blockInset;
        blockOutOfBoundsCorrection = flippedBlock.blockOutOfBoundsCorrection;
        surfaceBlockProperty = flippedBlock.surfaceBlockProperty;
      }
    }

    // Calculate the inline positioning properties
    let {inlineInset, inlineOutOfBoundsCorrection, surfaceInlineProperty} =
      this.calculateInline({
        surfaceRect,
        anchorRect,
        anchorInline,
        surfaceInline,
        xOffset,
        positioning,
        isLTR,
        windowInnerWidth,
        inlineScrollbarWidth,
      });

    // If the surface should be out of bounds in the inline direction, flip the
    // surface and anchor corner inline values and recalculate
    if (inlineOutOfBoundsCorrection && !disableInlineFlip) {
      const flippedSurfaceInline = surfaceInline === 'start' ? 'end' : 'start';
      const flippedAnchorInline = anchorInline === 'start' ? 'end' : 'start';

      const flippedInline = this.calculateInline({
        surfaceRect,
        anchorRect,
        anchorInline: flippedAnchorInline,
        surfaceInline: flippedSurfaceInline,
        xOffset,
        positioning,
        isLTR,
        windowInnerWidth,
        inlineScrollbarWidth,
      });

      // In the case that the flipped verion would require less out of bounds
      // correcting, use the flipped corner inline values
      if (
        Math.abs(inlineOutOfBoundsCorrection) >
        Math.abs(flippedInline.inlineOutOfBoundsCorrection)
      ) {
        inlineInset = flippedInline.inlineInset;
        inlineOutOfBoundsCorrection = flippedInline.inlineOutOfBoundsCorrection;
        surfaceInlineProperty = flippedInline.surfaceInlineProperty;
      }
    }

    // If we are simply repositioning the surface back inside the viewport,
    // subtract the out of bounds correction values from the positioning.
    if (repositionStrategy === 'move') {
      blockInset = blockInset - blockOutOfBoundsCorrection;
      inlineInset = inlineInset - inlineOutOfBoundsCorrection;
    }

    this.surfaceStylesInternal = {
      'display': 'block',
      'opacity': '1',
      [surfaceBlockProperty]: `${blockInset}px`,
      [surfaceInlineProperty]: `${inlineInset}px`,
    };

    // In the case that we are resizing the surface to stay inside the viewport
    // we need to set height and width on the surface.
    if (repositionStrategy === 'resize') {
      // Add a height property to the styles if there is block height correction
      if (blockOutOfBoundsCorrection) {
        this.surfaceStylesInternal['height'] = `${
          surfaceRect.height - blockOutOfBoundsCorrection
        }px`;
      }

      // Add a width property to the styles if there is block height correction
      if (inlineOutOfBoundsCorrection) {
        this.surfaceStylesInternal['width'] = `${
          surfaceRect.width - inlineOutOfBoundsCorrection
        }px`;
      }
    }

    this.host.requestUpdate();
  }

  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the block direction.
   */
  private calculateBlock(config: {
    surfaceRect: DOMRect;
    anchorRect: DOMRect;
    anchorBlock: 'start' | 'end';
    surfaceBlock: 'start' | 'end';
    yOffset: number;
    positioning: 'absolute' | 'fixed' | 'document';
    windowInnerHeight: number;
    blockScrollbarHeight: number;
  }) {
    const {
      surfaceRect,
      anchorRect,
      anchorBlock,
      surfaceBlock,
      yOffset,
      positioning,
      windowInnerHeight,
      blockScrollbarHeight,
    } = config;
    // We use number booleans to multiply values rather than `if` / ternary
    // statements because it _heavily_ cuts down on nesting and readability
    const relativeToWindow =
      positioning === 'fixed' || positioning === 'document' ? 1 : 0;
    const relativeToDocument = positioning === 'document' ? 1 : 0;
    const isSurfaceBlockStart = surfaceBlock === 'start' ? 1 : 0;
    const isSurfaceBlockEnd = surfaceBlock === 'end' ? 1 : 0;
    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;

    // Whether or not to apply the height of the anchor
    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;
    // The absolute block position of the anchor relative to window
    const blockTopLayerOffset =
      isSurfaceBlockStart * anchorRect.top +
      isSurfaceBlockEnd *
        (windowInnerHeight - anchorRect.bottom - blockScrollbarHeight);
    const blockDocumentOffset =
      isSurfaceBlockStart * window.scrollY - isSurfaceBlockEnd * window.scrollY;

    // If the surface's block would be out of bounds of the window, move it back
    // in
    const blockOutOfBoundsCorrection = Math.abs(
      Math.min(
        0,
        windowInnerHeight -
          blockTopLayerOffset -
          blockAnchorOffset -
          surfaceRect.height,
      ),
    );

    // The block logical value of the surface
    const blockInset =
      relativeToWindow * blockTopLayerOffset +
      relativeToDocument * blockDocumentOffset +
      blockAnchorOffset;

    const surfaceBlockProperty =
      surfaceBlock === 'start' ? 'inset-block-start' : 'inset-block-end';

    return {blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty};
  }

  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the inline direction.
   */
  private calculateInline(config: {
    isLTR: boolean;
    surfaceInline: 'start' | 'end';
    anchorInline: 'start' | 'end';
    anchorRect: DOMRect;
    surfaceRect: DOMRect;
    xOffset: number;
    positioning: 'absolute' | 'fixed' | 'document';
    windowInnerWidth: number;
    inlineScrollbarWidth: number;
  }) {
    const {
      isLTR: isLTRBool,
      surfaceInline,
      anchorInline,
      anchorRect,
      surfaceRect,
      xOffset,
      positioning,
      windowInnerWidth,
      inlineScrollbarWidth,
    } = config;
    // We use number booleans to multiply values rather than `if` / ternary
    // statements because it _heavily_ cuts down on nesting and readability
    const relativeToWindow =
      positioning === 'fixed' || positioning === 'document' ? 1 : 0;
    const relativeToDocument = positioning === 'document' ? 1 : 0;
    const isLTR = isLTRBool ? 1 : 0;
    const isRTL = isLTRBool ? 0 : 1;
    const isSurfaceInlineStart = surfaceInline === 'start' ? 1 : 0;
    const isSurfaceInlineEnd = surfaceInline === 'end' ? 1 : 0;
    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;

    // Whether or not to apply the width of the anchor
    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;
    // The inline position of the anchor relative to window in LTR
    const inlineTopLayerOffsetLTR =
      isSurfaceInlineStart * anchorRect.left +
      isSurfaceInlineEnd *
        (windowInnerWidth - anchorRect.right - inlineScrollbarWidth);
    // The inline position of the anchor relative to window in RTL
    const inlineTopLayerOffsetRTL =
      isSurfaceInlineStart *
        (windowInnerWidth - anchorRect.right - inlineScrollbarWidth) +
      isSurfaceInlineEnd * anchorRect.left;
    // The inline position of the anchor relative to window
    const inlineTopLayerOffset =
      isLTR * inlineTopLayerOffsetLTR + isRTL * inlineTopLayerOffsetRTL;

    // The inline position of the anchor relative to window in LTR
    const inlineDocumentOffsetLTR =
      isSurfaceInlineStart * window.scrollX -
      isSurfaceInlineEnd * window.scrollX;
    // The inline position of the anchor relative to window in RTL
    const inlineDocumentOffsetRTL =
      isSurfaceInlineEnd * window.scrollX -
      isSurfaceInlineStart * window.scrollX;
    // The inline position of the anchor relative to window
    const inlineDocumentOffset =
      isLTR * inlineDocumentOffsetLTR + isRTL * inlineDocumentOffsetRTL;

    // If the surface's inline would be out of bounds of the window, move it
    // back in
    const inlineOutOfBoundsCorrection = Math.abs(
      Math.min(
        0,
        windowInnerWidth -
          inlineTopLayerOffset -
          inlineAnchorOffset -
          surfaceRect.width,
      ),
    );

    // The inline logical value of the surface
    const inlineInset =
      relativeToWindow * inlineTopLayerOffset +
      inlineAnchorOffset +
      relativeToDocument * inlineDocumentOffset;

    let surfaceInlineProperty =
      surfaceInline === 'start' ? 'inset-inline-start' : 'inset-inline-end';

    // There are cases where the element is RTL but the root of the page is not.
    // In these cases we want to not use logical properties.
    if (positioning === 'document' || positioning === 'fixed') {
      if (
        (surfaceInline === 'start' && isLTRBool) ||
        (surfaceInline === 'end' && !isLTRBool)
      ) {
        surfaceInlineProperty = 'left';
      } else {
        surfaceInlineProperty = 'right';
      }
    }

    return {
      inlineInset,
      inlineOutOfBoundsCorrection,
      surfaceInlineProperty,
    };
  }

  hostUpdate() {
    this.onUpdate();
  }

  hostUpdated() {
    this.onUpdate();
  }

  /**
   * Checks whether the properties passed into the controller have changed since
   * the last positioning. If so, it will reposition if the surface is open or
   * close it if the surface should close.
   */
  private async onUpdate() {
    const props = this.getProperties();
    let hasChanged = false;
    for (const [key, value] of Object.entries(props)) {
      // tslint:disable-next-line
      hasChanged = hasChanged || value !== (this.lastValues as any)[key];
      if (hasChanged) break;
    }

    const openChanged = this.lastValues.isOpen !== props.isOpen;
    const hasAnchor = !!props.anchorEl;
    const hasSurface = !!props.surfaceEl;

    if (hasChanged && hasAnchor && hasSurface) {
      // Only update isOpen, because if it's closed, we do not want to waste
      // time on a useless reposition calculation. So save the other "dirty"
      // values until next time it opens.
      this.lastValues.isOpen = props.isOpen;

      if (props.isOpen) {
        // We are going to do a reposition, so save the prop values for future
        // dirty checking.
        this.lastValues = props;

        await this.position();
        props.onOpen();
      } else if (openChanged) {
        await props.beforeClose();
        this.close();
        props.onClose();
      }
    }
  }

  /**
   * Hides the surface.
   */
  private close() {
    this.surfaceStylesInternal = {
      'display': 'none',
    };
    this.host.requestUpdate();
    const surfaceEl = this.getProperties().surfaceEl;

    // The following type casts are required due to differing TS types in Google
    // and open source.
    if (
      (surfaceEl as unknown as {popover?: string})?.popover &&
      surfaceEl?.isConnected
    ) {
      (surfaceEl as unknown as {hidePopover: () => void}).hidePopover();
    }
  }
}


// ========== /internal/controllers/typeaheadController.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {MenuItem} from './menuItemController.js';

/**
 * The options that are passed to the typeahead controller.
 */
export interface TypeaheadControllerProperties {
  /**
   * A function that returns an array of menu items to be searched.
   * @return An array of menu items to be searched by typing.
   */
  getItems: () => MenuItem[];
  /**
   * The maximum time between each keystroke to keep the current type buffer
   * alive.
   */
  typeaheadBufferTime: number;
  /**
   * Whether or not the typeahead should listen for keystrokes or not.
   */
  active: boolean;
}

/**
 * Data structure tuple that helps with indexing.
 *
 * [index, item, normalized header text]
 */
type TypeaheadRecord = [number, MenuItem, string];
/**
 * Indicies to access the TypeaheadRecord tuple type.
 */
export const TYPEAHEAD_RECORD = {
  INDEX: 0,
  ITEM: 1,
  TEXT: 2,
} as const;

/**
 * This controller listens to `keydown` events and searches the header text of
 * an array of `MenuItem`s with the corresponding entered keys within the buffer
 * time and activates the item.
 *
 * @example
 * ```ts
 * const typeaheadController = new TypeaheadController(() => ({
 *   typeaheadBufferTime: 50,
 *   getItems: () => Array.from(document.querySelectorAll('md-menu-item'))
 * }));
 * html`
 *   <div
 *       @keydown=${typeaheadController.onKeydown}
 *       tabindex="0"
 *       class="activeItemText">
 *     <!-- focusable element that will receive keydown events -->
 *     Apple
 *   </div>
 *   <div>
 *     <md-menu-item active header="Apple"></md-menu-item>
 *     <md-menu-item header="Apricot"></md-menu-item>
 *     <md-menu-item header="Banana"></md-menu-item>
 *     <md-menu-item header="Olive"></md-menu-item>
 *     <md-menu-item header="Orange"></md-menu-item>
 *   </div>
 * `;
 * ```
 */
export class TypeaheadController {
  /**
   * Array of tuples that helps with indexing.
   */
  private typeaheadRecords: TypeaheadRecord[] = [];
  /**
   * Currently-typed text since last buffer timeout
   */
  private typaheadBuffer = '';
  /**
   * The timeout id from the current buffer's setTimeout
   */
  private cancelTypeaheadTimeout = 0;
  /**
   * If we are currently "typing"
   */
  isTypingAhead = false;
  /**
   * The record of the last active item.
   */
  lastActiveRecord: TypeaheadRecord | null = null;

  /**
   * @param getProperties A function that returns the options of the typeahead
   * controller:
   *
   * {
   *   getItems: A function that returns an array of menu items to be searched.
   *   typeaheadBufferTime: The maximum time between each keystroke to keep the
   *       current type buffer alive.
   * }
   */
  constructor(
    private readonly getProperties: () => TypeaheadControllerProperties,
  ) {}

  private get items() {
    return this.getProperties().getItems();
  }

  private get active() {
    return this.getProperties().active;
  }

  /**
   * Apply this listener to the element that will receive `keydown` events that
   * should trigger this controller.
   *
   * @param event The native browser `KeyboardEvent` from the `keydown` event.
   */
  readonly onKeydown = (event: KeyboardEvent) => {
    if (this.isTypingAhead) {
      this.typeahead(event);
    } else {
      this.beginTypeahead(event);
    }
  };

  /**
   * Sets up typingahead
   */
  private beginTypeahead(event: KeyboardEvent) {
    if (!this.active) {
      return;
    }

    // We don't want to typeahead if the _beginning_ of the typeahead is a menu
    // navigation, or a selection. We will handle "Space" only if it's in the
    // middle of a typeahead
    if (
      event.code === 'Space' ||
      event.code === 'Enter' ||
      event.code.startsWith('Arrow') ||
      event.code === 'Escape'
    ) {
      return;
    }

    this.isTypingAhead = true;
    // Generates the record array data structure which is the index, the element
    // and a normalized header.
    this.typeaheadRecords = this.items.map((el, index) => [
      index,
      el,
      el.typeaheadText.trim().toLowerCase(),
    ]);
    this.lastActiveRecord =
      this.typeaheadRecords.find(
        (record) => record[TYPEAHEAD_RECORD.ITEM].tabIndex === 0,
      ) ?? null;
    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }
    this.typeahead(event);
  }

  /**
   * Performs the typeahead. Based on the normalized items and the current text
   * buffer, finds the _next_ item with matching text and activates it.
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: 'o'
   * user types: l
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Orange
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange (active), Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   */
  private typeahead(event: KeyboardEvent) {
    if (event.defaultPrevented) return;
    clearTimeout(this.cancelTypeaheadTimeout);
    // Stop typingahead if one of the navigation or selection keys (except for
    // Space) are pressed
    if (
      event.code === 'Enter' ||
      event.code.startsWith('Arrow') ||
      event.code === 'Escape'
    ) {
      this.endTypeahead();
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      return;
    }

    // If Space is pressed, prevent it from selecting and closing the menu
    if (event.code === 'Space') {
      event.preventDefault();
    }

    // Start up a new keystroke buffer timeout
    this.cancelTypeaheadTimeout = setTimeout(
      this.endTypeahead,
      this.getProperties().typeaheadBufferTime,
    );

    this.typaheadBuffer += event.key.toLowerCase();

    const lastActiveIndex = this.lastActiveRecord
      ? this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX]
      : -1;
    const numRecords = this.typeaheadRecords.length;

    /**
     * Sorting function that will resort the items starting with the given index
     *
     * @example
     *
     * this.typeaheadRecords =
     * 0: [0, <reference>, 'apple']
     * 1: [1, <reference>, 'apricot']
     * 2: [2, <reference>, 'banana']
     * 3: [3, <reference>, 'olive'] <-- lastActiveIndex
     * 4: [4, <reference>, 'orange']
     * 5: [5, <reference>, 'strawberry']
     *
     * this.typeaheadRecords.sort((a,b) => rebaseIndexOnActive(a)
     *                                       - rebaseIndexOnActive(b)) ===
     * 0: [3, <reference>, 'olive'] <-- lastActiveIndex
     * 1: [4, <reference>, 'orange']
     * 2: [5, <reference>, 'strawberry']
     * 3: [0, <reference>, 'apple']
     * 4: [1, <reference>, 'apricot']
     * 5: [2, <reference>, 'banana']
     */
    const rebaseIndexOnActive = (record: TypeaheadRecord) => {
      return (
        (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) %
        numRecords
      );
    };

    // records filtered and sorted / rebased around the last active index
    const matchingRecords = this.typeaheadRecords
      .filter(
        (record) =>
          !record[TYPEAHEAD_RECORD.ITEM].disabled &&
          record[TYPEAHEAD_RECORD.TEXT].startsWith(this.typaheadBuffer),
      )
      .sort((a, b) => rebaseIndexOnActive(a) - rebaseIndexOnActive(b));

    // Just leave if there's nothing that matches. Native select will just
    // choose the first thing that starts with the next letter in the alphabet
    // but that's out of scope and hard to localize
    if (matchingRecords.length === 0) {
      clearTimeout(this.cancelTypeaheadTimeout);
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      this.endTypeahead();
      return;
    }

    const isNewQuery = this.typaheadBuffer.length === 1;
    let nextRecord: TypeaheadRecord;

    // This is likely the case that someone is trying to "tab" through different
    // entries that start with the same letter
    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {
      nextRecord = matchingRecords[1] ?? matchingRecords[0];
    } else {
      nextRecord = matchingRecords[0];
    }

    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }

    this.lastActiveRecord = nextRecord;
    nextRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = 0;
    nextRecord[TYPEAHEAD_RECORD.ITEM].focus();
    return;
  }

  /**
   * Ends the current typeahead and clears the buffer.
   */
  private readonly endTypeahead = () => {
    this.isTypingAhead = false;
    this.typaheadBuffer = '';
    this.typeaheadRecords = [];
  };
}


/* ========== /internal/menu-styles.scss ========== */
//
// Copyright 2022 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './menu';
// go/keep-sorted end

@include menu.styles;


// ========== /internal/menu.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../elevation/elevation.js';
import '../../focus/md-focus-ring.js';

import {LitElement, PropertyValues, html, isServer, nothing} from 'lit';
import {property, query, queryAssignedElements, state} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';

import {EASING, createAnimationSignal} from '../../internal/motion/animation.js';
import {
  ListController,
  NavigableKeys,
} from '../../list/internal/list-controller.js';
import {
  getActiveItem,
  getFirstActivatableItem,
  getLastActivatableItem,
} from '../../list/internal/list-navigation-helpers.js';

import {MenuItem} from './controllers/menuItemController.js';
import {
  ActivateTypeaheadEvent,
  DeactivateTypeaheadEvent,
  FocusState,
  isClosableKey,
  isElementInSubtree,
} from './controllers/shared.js';
import {
  Corner,
  SurfacePositionController,
  SurfacePositionTarget,
} from './controllers/surfacePositionController.js';
import {TypeaheadController} from './controllers/typeaheadController.js';

export {Corner} from './controllers/surfacePositionController.js';

/**
 * The default value for the typeahead buffer time in Milliseconds.
 */
export const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;

const submenuNavKeys = new Set<string>([
  NavigableKeys.ArrowDown,
  NavigableKeys.ArrowUp,
  NavigableKeys.Home,
  NavigableKeys.End,
]);

const menuNavKeys = new Set<string>([
  NavigableKeys.ArrowLeft,
  NavigableKeys.ArrowRight,
  ...submenuNavKeys,
]);

/**
 * Gets the currently focused element on the page.
 *
 * @param activeDoc The document or shadowroot from which to start the search.
 *    Defaults to `window.document`
 * @return Returns the currently deeply focused element or `null` if none.
 */
function getFocusedElement(
  activeDoc: Document | ShadowRoot = document,
): HTMLElement | null {
  let activeEl = activeDoc.activeElement as HTMLElement | null;

  // Check for activeElement in the case that an element with a shadow root host
  // is currently focused.
  while (activeEl && activeEl?.shadowRoot?.activeElement) {
    activeEl = activeEl.shadowRoot.activeElement as HTMLElement | null;
  }

  return activeEl;
}

/**
 * @fires opening {Event} Fired before the opening animation begins
 * @fires opened {Event} Fired once the menu is open, after any animations
 * @fires closing {Event} Fired before the closing animation begins
 * @fires closed {Event} Fired once the menu is closed, after any animations
 */
export abstract class Menu extends LitElement {
  @query('.menu') private readonly surfaceEl!: HTMLElement | null;
  @query('slot') private readonly slotEl!: HTMLSlotElement | null;

  /**
   * The ID of the element in the same root node in which the menu should align
   * to. Overrides setting `anchorElement = elementReference`.
   *
   * __NOTE__: anchor or anchorElement must either be an HTMLElement or resolve
   * to an HTMLElement in order for menu to open.
   */
  @property() anchor = '';
  /**
   * Whether the positioning algorithm should calculate relative to the parent
   * of the anchor element (`absolute`), relative to the window (`fixed`), or
   * relative to the document (`document`). `popover` will use the popover API
   * to render the menu in the top-layer. If your browser does not support the
   * popover API, it will fall back to `fixed`.
   *
   * __Examples for `position = 'fixed'`:__
   *
   * - If there is no `position:relative` in the given parent tree and the
   *   surface is `position:absolute`
   * - If the surface is `position:fixed`
   * - If the surface is in the "top layer"
   * - The anchor and the surface do not share a common `position:relative`
   *   ancestor
   *
   * When using `positioning=fixed`, in most cases, the menu should position
   * itself above most other `position:absolute` or `position:fixed` elements
   * when placed inside of them. e.g. using a menu inside of an `md-dialog`.
   *
   * __NOTE__: Fixed menus will not scroll with the page and will be fixed to
   * the window instead.
   *
   * __Examples for `position = 'document'`:__
   *
   * - There is no parent that creates a relative positioning context e.g.
   *   `position: relative`, `position: absolute`, `transform: translate(x, y)`,
   *   etc.
   * - You put the effort into hoisting the menu to the top of the DOM like the
   *   end of the `<body>` to render over everything or in a top-layer.
   * - You are reusing a single `md-menu` element that dynamically renders
   *   content.
   *
   * __Examples for `position = 'popover'`:__
   *
   * - Your browser supports `popover`.
   * - Most cases. Once popover is in browsers, this will become the default.
   */
  @property() positioning: 'absolute' | 'fixed' | 'document' | 'popover' =
    'absolute';
  /**
   * Skips the opening and closing animations.
   */
  @property({type: Boolean}) quick = false;
  /**
   * Displays overflow content like a submenu. Not required in most cases when
   * using `positioning="popover"`.
   *
   * __NOTE__: This may cause adverse effects if you set
   * `md-menu {max-height:...}`
   * and have items overflowing items in the "y" direction.
   */
  @property({type: Boolean, attribute: 'has-overflow'}) hasOverflow = false;
  /**
   * Opens the menu and makes it visible. Alternative to the `.show()` and
   * `.close()` methods
   */
  @property({type: Boolean, reflect: true}) open = false;
  /**
   * Offsets the menu's inline alignment from the anchor by the given number in
   * pixels. This value is direction aware and will follow the LTR / RTL
   * direction.
   *
   * e.g. LTR: positive -> right, negative -> left
   *      RTL: positive -> left, negative -> right
   */
  @property({type: Number, attribute: 'x-offset'}) xOffset = 0;
  /**
   * Offsets the menu's block alignment from the anchor by the given number in
   * pixels.
   *
   * e.g. positive -> down, negative -> up
   */
  @property({type: Number, attribute: 'y-offset'}) yOffset = 0;
  /**
   * Disable the `flip` behavior that usually happens on the horizontal axis
   * when the surface would render outside the viewport.
   */
  @property({type: Boolean, attribute: 'no-horizontal-flip'}) noHorizontalFlip =
    false;
  /**
   * Disable the `flip` behavior that usually happens on the vertical axis when
   * the surface would render outside the viewport.
   */
  @property({type: Boolean, attribute: 'no-vertical-flip'}) noVerticalFlip =
    false;
  /**
   * The max time between the keystrokes of the typeahead menu behavior before
   * it clears the typeahead buffer.
   */
  @property({type: Number, attribute: 'typeahead-delay'})
  typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
  /**
   * The corner of the anchor which to align the menu in the standard logical
   * property style of <block>-<inline> e.g. `'end-start'`.
   *
   * NOTE: This value may not be respected by the menu positioning algorithm
   * if the menu would render outisde the viewport.
   * Use `no-horizontal-flip` or `no-vertical-flip` to force the usage of the value
   */
  @property({attribute: 'anchor-corner'})
  anchorCorner: Corner = Corner.END_START;
  /**
   * The corner of the menu which to align the anchor in the standard logical
   * property style of <block>-<inline> e.g. `'start-start'`.
   *
   * NOTE: This value may not be respected by the menu positioning algorithm
   * if the menu would render outisde the viewport.
   * Use `no-horizontal-flip` or `no-vertical-flip` to force the usage of the value
   */
  @property({attribute: 'menu-corner'}) menuCorner: Corner = Corner.START_START;
  /**
   * Keeps the user clicks outside the menu.
   *
   * NOTE: clicking outside may still cause focusout to close the menu so see
   * `stayOpenOnFocusout`.
   */
  @property({type: Boolean, attribute: 'stay-open-on-outside-click'})
  stayOpenOnOutsideClick = false;
  /**
   * Keeps the menu open when focus leaves the menu's composed subtree.
   *
   * NOTE: Focusout behavior will stop propagation of the focusout event. Set
   * this property to true to opt-out of menu's focusout handling altogether.
   */
  @property({type: Boolean, attribute: 'stay-open-on-focusout'})
  stayOpenOnFocusout = false;
  /**
   * After closing, does not restore focus to the last focused element before
   * the menu was opened.
   */
  @property({type: Boolean, attribute: 'skip-restore-focus'})
  skipRestoreFocus = false;
  /**
   * The element that should be focused by default once opened.
   *
   * NOTE: When setting default focus to 'LIST_ROOT', remember to change
   * `tabindex` to `0` and change md-menu's display to something other than
   * `display: contents` when necessary.
   */
  @property({attribute: 'default-focus'})
  defaultFocus: FocusState = FocusState.FIRST_ITEM;

  /**
   * Turns off navigation wrapping. By default, navigating past the end of the
   * menu items will wrap focus back to the beginning and vice versa. Use this
   * for ARIA patterns that do not wrap focus, like combobox.
   */
  @property({type: Boolean, attribute: 'no-navigation-wrap'})
  noNavigationWrap = false;

  @queryAssignedElements({flatten: true}) protected slotItems!: HTMLElement[];
  @state() private typeaheadActive = true;

  /**
   * Whether or not the current menu is a submenu and should not handle specific
   * navigation keys.
   *
   * @export
   */
  isSubmenu = false;

  /**
   * The event path of the last window pointerdown event.
   */
  private pointerPath: EventTarget[] = [];

  /**
   * Whether or not the menu is repositoining due to window / document resize
   */
  private isRepositioning = false;
  private readonly openCloseAnimationSignal = createAnimationSignal();

  private readonly listController = new ListController<MenuItem>({
    isItem: (maybeItem: HTMLElement): maybeItem is MenuItem => {
      return maybeItem.hasAttribute('md-menu-item');
    },
    getPossibleItems: () => this.slotItems,
    isRtl: () => getComputedStyle(this).direction === 'rtl',
    deactivateItem: (item: MenuItem) => {
      item.selected = false;
      item.tabIndex = -1;
    },
    activateItem: (item: MenuItem) => {
      item.selected = true;
      item.tabIndex = 0;
    },
    isNavigableKey: (key: string) => {
      if (!this.isSubmenu) {
        return menuNavKeys.has(key);
      }

      const isRtl = getComputedStyle(this).direction === 'rtl';
      // we want md-submenu to handle the submenu's left/right arrow exit
      // key so it can close the menu instead of navigate the list.
      // Therefore we need to include all keys but left/right arrow close
      // key
      const arrowOpen = isRtl
        ? NavigableKeys.ArrowLeft
        : NavigableKeys.ArrowRight;

      if (key === arrowOpen) {
        return true;
      }

      return submenuNavKeys.has(key);
    },
    wrapNavigation: () => !this.noNavigationWrap,
  });

  /**
   * Whether the menu is animating upwards or downwards when opening. This is
   * helpful for calculating some animation calculations.
   */
  private get openDirection(): 'UP' | 'DOWN' {
    const menuCornerBlock = this.menuCorner.split('-')[0];
    return menuCornerBlock === 'start' ? 'DOWN' : 'UP';
  }

  /**
   * The element that was focused before the menu opened.
   */
  private lastFocusedElement: HTMLElement | null = null;

  /**
   * Handles typeahead navigation through the menu.
   */
  typeaheadController = new TypeaheadController(() => {
    return {
      getItems: () => this.items,
      typeaheadBufferTime: this.typeaheadDelay,
      active: this.typeaheadActive,
    };
  });

  private currentAnchorElement: HTMLElement | null = null;

  /**
   * The element which the menu should align to. If `anchor` is set to a
   * non-empty idref string, then `anchorEl` will resolve to the element with
   * the given id in the same root node. Otherwise, `null`.
   */
  get anchorElement(): (HTMLElement & Partial<SurfacePositionTarget>) | null {
    if (this.anchor) {
      return (this.getRootNode() as Document | ShadowRoot).querySelector(
        `#${this.anchor}`,
      );
    }

    return this.currentAnchorElement;
  }

  set anchorElement(
    element: (HTMLElement & Partial<SurfacePositionTarget>) | null,
  ) {
    this.currentAnchorElement = element;
    this.requestUpdate('anchorElement');
  }

  private readonly internals =
    // Cast needed for closure
    (this as HTMLElement).attachInternals();

  constructor() {
    super();
    if (!isServer) {
      this.internals.role = 'menu';
      this.addEventListener('keydown', this.handleKeydown);
      // Capture so that we can grab the event before it reaches the menu item
      // istelf. Specifically useful for the case where typeahead encounters a
      // space and we don't want the menu item to close the menu.
      this.addEventListener('keydown', this.captureKeydown, {capture: true});
      this.addEventListener('focusout', this.handleFocusout);
    }
  }

  /**
   * Handles positioning the surface and aligning it to the anchor as well as
   * keeping it in the viewport.
   */
  private readonly menuPositionController = new SurfacePositionController(
    this,
    () => {
      return {
        anchorCorner: this.anchorCorner,
        surfaceCorner: this.menuCorner,
        surfaceEl: this.surfaceEl,
        anchorEl: this.anchorElement,
        positioning:
          this.positioning === 'popover' ? 'document' : this.positioning,
        isOpen: this.open,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        disableBlockFlip: this.noVerticalFlip,
        disableInlineFlip: this.noHorizontalFlip,
        onOpen: this.onOpened,
        beforeClose: this.beforeClose,
        onClose: this.onClosed,
        // We can't resize components that have overflow like menus with
        // submenus because the overflow-y will show menu items / content
        // outside the bounds of the menu. Popover API fixes this because each
        // submenu is hoisted to the top-layer and are not considered overflow
        // content.
        repositionStrategy:
          this.hasOverflow && this.positioning !== 'popover'
            ? 'move'
            : 'resize',
      };
    },
  );

  /**
   * The menu items associated with this menu. The items must be `MenuItem`s and
   * have both the `md-menu-item` and `md-list-item` attributes.
   */
  get items(): MenuItem[] {
    return this.listController.items;
  }

  protected override willUpdate(changed: PropertyValues<Menu>) {
    if (!changed.has('open')) {
      return;
    }

    if (this.open) {
      this.removeAttribute('aria-hidden');
      return;
    }

    this.setAttribute('aria-hidden', 'true');
  }

  override update(changed: PropertyValues<Menu>) {
    if (changed.has('open')) {
      if (this.open) {
        this.setUpGlobalEventListeners();
      } else {
        this.cleanUpGlobalEventListeners();
      }
    }

    // Firefox does not support popover. Fall-back to using fixed.
    if (
      changed.has('positioning') &&
      this.positioning === 'popover' &&
      // type required for Google JS conformance
      !(this as unknown as {showPopover?: () => void}).showPopover
    ) {
      this.positioning = 'fixed';
    }

    super.update(changed);
  }

  private readonly onWindowResize = () => {
    if (
      this.isRepositioning ||
      (this.positioning !== 'document' &&
        this.positioning !== 'fixed' &&
        this.positioning !== 'popover')
    ) {
      return;
    }
    this.isRepositioning = true;
    this.reposition();
    this.isRepositioning = false;
  };

  override connectedCallback() {
    super.connectedCallback();
    if (this.open) {
      this.setUpGlobalEventListeners();
    }
  }

  override disconnectedCallback() {
    super.disconnectedCallback();
    this.cleanUpGlobalEventListeners();
  }

  override getBoundingClientRect() {
    if (!this.surfaceEl) {
      return super.getBoundingClientRect();
    }
    return this.surfaceEl.getBoundingClientRect();
  }

  override getClientRects() {
    if (!this.surfaceEl) {
      return super.getClientRects();
    }
    return this.surfaceEl.getClientRects();
  }

  protected override render() {
    return this.renderSurface();
  }

  /**
   * Renders the positionable surface element and its contents.
   */
  private renderSurface() {
    return html`
      <div
        class="menu ${classMap(this.getSurfaceClasses())}"
        style=${styleMap(this.menuPositionController.surfaceStyles)}
        popover=${this.positioning === 'popover' ? 'manual' : nothing}>
        ${this.renderElevation()}
        <div class="items">
          <div class="item-padding"> ${this.renderMenuItems()} </div>
        </div>
      </div>
    `;
  }

  /**
   * Renders the menu items' slot
   */
  private renderMenuItems() {
    return html`<slot
      @close-menu=${this.onCloseMenu}
      @deactivate-items=${this.onDeactivateItems}
      @request-activation=${this.onRequestActivation}
      @deactivate-typeahead=${this.handleDeactivateTypeahead}
      @activate-typeahead=${this.handleActivateTypeahead}
      @stay-open-on-focusout=${this.handleStayOpenOnFocusout}
      @close-on-focusout=${this.handleCloseOnFocusout}
      @slotchange=${this.listController.onSlotchange}></slot>`;
  }

  /**
   * Renders the elevation component.
   */
  private renderElevation() {
    return html`<md-elevation part="elevation"></md-elevation>`;
  }

  private getSurfaceClasses(): ClassInfo {
    return {
      open: this.open,
      fixed: this.positioning === 'fixed',
      'has-overflow': this.hasOverflow,
    };
  }

  private readonly handleFocusout = async (event: FocusEvent) => {
    const anchorEl = this.anchorElement!;
    // Do not close if we focused out by clicking on the anchor element. We
    // can't assume anchor buttons can be the related target because of iOS does
    // not focus buttons.
    if (
      this.stayOpenOnFocusout ||
      !this.open ||
      this.pointerPath.includes(anchorEl)
    ) {
      return;
    }

    if (event.relatedTarget) {
      // Don't close the menu if we are switching focus between menu,
      // md-menu-item, and md-list or if the anchor was click focused, but check
      // if length of pointerPath is 0 because that means something was at least
      // clicked (shift+tab case).
      if (
        isElementInSubtree(event.relatedTarget, this) ||
        (this.pointerPath.length !== 0 &&
          isElementInSubtree(event.relatedTarget, anchorEl))
      ) {
        return;
      }
    } else if (this.pointerPath.includes(this)) {
      // If menu tabindex == -1 and the user clicks on the menu or a divider, we
      // want to keep the menu open.
      return;
    }

    const oldRestoreFocus = this.skipRestoreFocus;
    // allow focus to continue to the next focused object rather than returning
    this.skipRestoreFocus = true;
    this.close();
    // await for close
    await this.updateComplete;
    // return to previous behavior
    this.skipRestoreFocus = oldRestoreFocus;
  };

  private captureKeydown(event: KeyboardEvent) {
    if (
      event.target === this &&
      !event.defaultPrevented &&
      isClosableKey(event.code)
    ) {
      event.preventDefault();
      this.close();
    }

    this.typeaheadController.onKeydown(event);
  }

  /**
   * Saves the last focused element focuses the new element based on
   * `defaultFocus`, and animates open.
   */
  private readonly onOpened = async () => {
    this.lastFocusedElement = getFocusedElement();

    const items = this.items;
    const activeItemRecord = getActiveItem(items);

    if (activeItemRecord && this.defaultFocus !== FocusState.NONE) {
      activeItemRecord.item.tabIndex = -1;
    }

    let animationAborted = !this.quick;

    if (this.quick) {
      this.dispatchEvent(new Event('opening'));
    } else {
      animationAborted = !!(await this.animateOpen());
    }

    // This must come after the opening animation or else it may focus one of
    // the items before the animation has begun and causes the list to slide
    // (block-padding-of-the-menu)px at the end of the animation
    switch (this.defaultFocus) {
      case FocusState.FIRST_ITEM:
        const first = getFirstActivatableItem(items);
        if (first) {
          first.tabIndex = 0;
          first.focus();
          await (first as LitElement & MenuItem).updateComplete;
        }
        break;
      case FocusState.LAST_ITEM:
        const last = getLastActivatableItem(items);
        if (last) {
          last.tabIndex = 0;
          last.focus();
          await (last as LitElement & MenuItem).updateComplete;
        }
        break;
      case FocusState.LIST_ROOT:
        this.focus();
        break;
      default:
      case FocusState.NONE:
        // Do nothing.
        break;
    }

    if (!animationAborted) {
      this.dispatchEvent(new Event('opened'));
    }
  };

  /**
   * Animates closed.
   */
  private readonly beforeClose = async () => {
    this.open = false;

    if (!this.skipRestoreFocus) {
      this.lastFocusedElement?.focus?.();
    }

    if (!this.quick) {
      await this.animateClose();
    }
  };

  /**
   * Focuses the last focused element.
   */
  private readonly onClosed = () => {
    if (this.quick) {
      this.dispatchEvent(new Event('closing'));
      this.dispatchEvent(new Event('closed'));
    }
  };

  /**
   * Performs the opening animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   *
   * @return A promise that resolve to `true` if the animation was aborted,
   *     `false` if it was not aborted.
   */
  private async animateOpen() {
    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;

    if (!surfaceEl || !slotEl) return true;

    const openDirection = this.openDirection;
    this.dispatchEvent(new Event('opening'));
    // needs to be imperative because we don't want to mix animation and Lit
    // render timing
    surfaceEl.classList.toggle('animating', true);

    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const openingUpwards = openDirection === 'UP';
    const children = this.items;
    const FULL_DURATION = 500;
    const SURFACE_OPACITY_DURATION = 50;
    const ITEM_OPACITY_DURATION = 250;
    // We want to fit every child fade-in animation within the full duration of
    // the animation.
    const DELAY_BETWEEN_ITEMS =
      (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;

    const surfaceHeightAnimation = surfaceEl.animate(
      [{height: '0px'}, {height: `${height}px`}],
      {
        duration: FULL_DURATION,
        easing: EASING.EMPHASIZED,
      },
    );
    // When we are opening upwards, we want to make sure the last item is always
    // in view, so we need to translate it upwards the opposite direction of the
    // height animation
    const upPositionCorrectionAnimation = slotEl.animate(
      [
        {transform: openingUpwards ? `translateY(-${height}px)` : ''},
        {transform: ''},
      ],
      {duration: FULL_DURATION, easing: EASING.EMPHASIZED},
    );

    const surfaceOpacityAnimation = surfaceEl.animate(
      [{opacity: 0}, {opacity: 1}],
      SURFACE_OPACITY_DURATION,
    );

    const childrenAnimations: Array<[HTMLElement, Animation]> = [];

    for (let i = 0; i < children.length; i++) {
      // If we are animating upwards, then reverse the children list.
      const directionalIndex = openingUpwards ? children.length - 1 - i : i;
      const child = children[directionalIndex];
      const animation = child.animate([{opacity: 0}, {opacity: 1}], {
        duration: ITEM_OPACITY_DURATION,
        delay: DELAY_BETWEEN_ITEMS * i,
      });

      // Make them all initially hidden and then clean up at the end of each
      // animation.
      child.classList.toggle('md-menu-hidden', true);
      animation.addEventListener('finish', () => {
        child.classList.toggle('md-menu-hidden', false);
      });

      childrenAnimations.push([child, animation]);
    }

    let resolveAnimation = (value: boolean) => {};
    const animationFinished = new Promise<boolean>((resolve) => {
      resolveAnimation = resolve;
    });

    signal.addEventListener('abort', () => {
      surfaceHeightAnimation.cancel();
      upPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        child.classList.toggle('md-menu-hidden', false);
        animation.cancel();
      });

      resolveAnimation(true);
    });

    surfaceHeightAnimation.addEventListener('finish', () => {
      surfaceEl.classList.toggle('animating', false);
      this.openCloseAnimationSignal.finish();
      resolveAnimation(false);
    });

    return await animationFinished;
  }

  /**
   * Performs the closing animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   */
  private animateClose() {
    let resolve!: (value: unknown) => void;

    // This promise blocks the surface position controller from setting
    // display: none on the surface which will interfere with this animation.
    const animationEnded = new Promise((res) => {
      resolve = res;
    });

    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;

    if (!surfaceEl || !slotEl) {
      resolve(false);
      return animationEnded;
    }

    const openDirection = this.openDirection;
    const closingDownwards = openDirection === 'UP';
    this.dispatchEvent(new Event('closing'));
    // needs to be imperative because we don't want to mix animation and Lit
    // render timing
    surfaceEl.classList.toggle('animating', true);
    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const children = this.items;
    const FULL_DURATION = 150;
    const SURFACE_OPACITY_DURATION = 50;
    // The surface fades away at the very end
    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;
    const ITEM_OPACITY_DURATION = 50;
    const ITEM_OPACITY_INITIAL_DELAY = 50;
    const END_HEIGHT_PERCENTAGE = 0.35;

    // We want to fit every child fade-out animation within the full duration of
    // the animation.
    const DELAY_BETWEEN_ITEMS =
      (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) /
      children.length;

    // The mock has the animation shrink to 35%
    const surfaceHeightAnimation = surfaceEl.animate(
      [
        {height: `${height}px`},
        {height: `${height * END_HEIGHT_PERCENTAGE}px`},
      ],
      {
        duration: FULL_DURATION,
        easing: EASING.EMPHASIZED_ACCELERATE,
      },
    );

    // When we are closing downwards, we want to make sure the last item is
    // always in view, so we need to translate it upwards the opposite direction
    // of the height animation
    const downPositionCorrectionAnimation = slotEl.animate(
      [
        {transform: ''},
        {
          transform: closingDownwards
            ? `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)`
            : '',
        },
      ],
      {duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE},
    );

    const surfaceOpacityAnimation = surfaceEl.animate(
      [{opacity: 1}, {opacity: 0}],
      {duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY},
    );

    const childrenAnimations: Array<[HTMLElement, Animation]> = [];

    for (let i = 0; i < children.length; i++) {
      // If the animation is closing upwards, then reverse the list of
      // children so that we animate in the opposite direction.
      const directionalIndex = closingDownwards ? i : children.length - 1 - i;
      const child = children[directionalIndex];
      const animation = child.animate([{opacity: 1}, {opacity: 0}], {
        duration: ITEM_OPACITY_DURATION,
        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i,
      });

      // Make sure the items stay hidden at the end of each child animation.
      // We clean this up at the end of the overall animation.
      animation.addEventListener('finish', () => {
        child.classList.toggle('md-menu-hidden', true);
      });
      childrenAnimations.push([child, animation]);
    }

    signal.addEventListener('abort', () => {
      surfaceHeightAnimation.cancel();
      downPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        animation.cancel();
        child.classList.toggle('md-menu-hidden', false);
      });
      resolve(false);
    });

    surfaceHeightAnimation.addEventListener('finish', () => {
      surfaceEl.classList.toggle('animating', false);
      childrenAnimations.forEach(([child]) => {
        child.classList.toggle('md-menu-hidden', false);
      });
      this.openCloseAnimationSignal.finish();
      this.dispatchEvent(new Event('closed'));
      resolve(true);
    });

    return animationEnded;
  }

  private handleKeydown(event: KeyboardEvent) {
    // At any key event, the pointer interaction is done so we need to clear our
    // cached pointerpath. This handles the case where the user clicks on the
    // anchor, and then hits shift+tab
    this.pointerPath = [];
    this.listController.handleKeydown(event);
  }

  private setUpGlobalEventListeners() {
    document.addEventListener('click', this.onDocumentClick, {capture: true});
    window.addEventListener('pointerdown', this.onWindowPointerdown);
    document.addEventListener('resize', this.onWindowResize, {passive: true});
    window.addEventListener('resize', this.onWindowResize, {passive: true});
  }

  private cleanUpGlobalEventListeners() {
    document.removeEventListener('click', this.onDocumentClick, {
      capture: true,
    });
    window.removeEventListener('pointerdown', this.onWindowPointerdown);
    document.removeEventListener('resize', this.onWindowResize);
    window.removeEventListener('resize', this.onWindowResize);
  }

  private readonly onWindowPointerdown = (event: PointerEvent) => {
    this.pointerPath = event.composedPath();
  };

  /**
   * We cannot listen to window click because Safari on iOS will not bubble a
   * click event on window if the item clicked is not a "clickable" item such as
   * <body>
   */
  private readonly onDocumentClick = (event: Event) => {
    if (!this.open) {
      return;
    }

    const path = event.composedPath();

    if (
      !this.stayOpenOnOutsideClick &&
      !path.includes(this) &&
      !path.includes(this.anchorElement!)
    ) {
      this.open = false;
    }
  };

  private onCloseMenu() {
    this.close();
  }

  private onDeactivateItems(event: Event) {
    event.stopPropagation();
    this.listController.onDeactivateItems();
  }

  private onRequestActivation(event: Event) {
    event.stopPropagation();
    this.listController.onRequestActivation(event);
  }

  private handleDeactivateTypeahead(event: DeactivateTypeaheadEvent) {
    // stopPropagation so that this does not deactivate any typeaheads in menus
    // nested above it e.g. md-sub-menu
    event.stopPropagation();
    this.typeaheadActive = false;
  }

  private handleActivateTypeahead(event: ActivateTypeaheadEvent) {
    // stopPropagation so that this does not activate any typeaheads in menus
    // nested above it e.g. md-sub-menu
    event.stopPropagation();
    this.typeaheadActive = true;
  }

  private handleStayOpenOnFocusout(event: Event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = true;
  }

  private handleCloseOnFocusout(event: Event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = false;
  }

  close() {
    this.open = false;
    const maybeSubmenu = this.slotItems as Array<
      HTMLElement & {close?: () => void}
    >;
    maybeSubmenu.forEach((item) => {
      item.close?.();
    });
  }

  show() {
    this.open = true;
  }

  /**
   * Activates the next item in the menu. If at the end of the menu, the first
   * item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activateNextItem() {
    return this.listController.activateNextItem() ?? null;
  }

  /**
   * Activates the previous item in the menu. If at the start of the menu, the
   * last item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activatePreviousItem() {
    return this.listController.activatePreviousItem() ?? null;
  }

  /**
   * Repositions the menu if it is open.
   *
   * Useful for the case where document or window-positioned menus have their
   * anchors moved while open.
   */
  reposition() {
    if (this.open) {
      this.menuPositionController.position();
    }
  }
}


/* ========== /internal/menuitem/_menu-item.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use 'sass:list';
@use 'sass:map';
@use 'sass:string';
// go/keep-sorted end
// go/keep-sorted start
@use '../../../focus/focus-ring';
@use '../../../icon/icon';
@use '../../../list/list-item';
@use '../../../ripple/ripple';
@use '../../../tokens';
// go/keep-sorted end

@mixin theme($tokens) {
  $supported-tokens: tokens.$md-comp-menu-item-supported-tokens;

  @each $token, $value in $tokens {
    @if list.index($supported-tokens, $token) == null {
      @error 'Token `#{$token}` is not a supported token.';
    }

    @if $value {
      --md-menu-item-#{$token}: #{$value};
    }
  }
}

@mixin styles() {
  $tokens: tokens.md-comp-menu-item-values();

  :host {
    border-radius: map.get($tokens, 'container-shape');
    display: flex;

    @include ripple.theme(
      (
        hover-color: map.get($tokens, 'hover-state-layer-color'),
        hover-opacity: map.get($tokens, 'hover-state-layer-opacity'),
        pressed-color: map.get($tokens, 'pressed-state-layer-color'),
        pressed-opacity: map.get($tokens, 'pressed-state-layer-opacity'),
      )
    );
  }

  :host([disabled]) {
    opacity: map.get($tokens, 'disabled-opacity');
    pointer-events: none;
  }

  md-focus-ring {
    z-index: 1;

    @include focus-ring.theme(
      (
        'shape': 8px,
      )
    );
  }

  a,
  button,
  li {
    // Resets. These can be removed once we're no longer use these tags
    background: none;
    border: none;
    padding: 0;
    margin: 0;
    text-align: unset;
    text-decoration: none;
  }

  .list-item {
    border-radius: inherit;
    display: flex;
    flex: 1;
    max-width: inherit;
    min-width: inherit;
    outline: none;
    // hide android tap color since we have ripple
    -webkit-tap-highlight-color: transparent;

    &:not(.disabled) {
      cursor: pointer;
    }
  }

  [slot='container'] {
    pointer-events: none;
  }

  md-ripple {
    border-radius: inherit;
  }

  md-item {
    border-radius: inherit;
    flex: 1;
    color: map.get($tokens, 'label-text-color');
    font-family: map.get($tokens, 'label-text-font');
    font-size: map.get($tokens, 'label-text-size');
    line-height: map.get($tokens, 'label-text-line-height');
    font-weight: map.get($tokens, 'label-text-weight');
    min-height: map.get($tokens, 'one-line-container-height');
    padding-top: map.get($tokens, 'top-space');
    padding-bottom: map.get($tokens, 'bottom-space');
    padding-inline-start: map.get($tokens, 'leading-space');
    padding-inline-end: map.get($tokens, 'trailing-space');
  }

  md-item[multiline] {
    min-height: map.get($tokens, 'two-line-container-height');
  }

  [slot='supporting-text'] {
    color: map.get($tokens, 'supporting-text-color');
    font-family: map.get($tokens, 'supporting-text-font');
    font-size: map.get($tokens, 'supporting-text-size');
    line-height: map.get($tokens, 'supporting-text-line-height');
    font-weight: map.get($tokens, 'supporting-text-weight');
  }

  [slot='trailing-supporting-text'] {
    color: map.get($tokens, 'trailing-supporting-text-color');
    font-family: map.get($tokens, 'trailing-supporting-text-font');
    font-size: map.get($tokens, 'trailing-supporting-text-size');
    line-height: map.get($tokens, 'trailing-supporting-text-line-height');
    font-weight: map.get($tokens, 'trailing-supporting-text-weight');
  }

  :is([slot='start'], [slot='end'])::slotted(*) {
    fill: currentColor;
  }

  [slot='start'] {
    color: map.get($tokens, 'leading-icon-color');
  }

  [slot='end'] {
    color: map.get($tokens, 'trailing-icon-color');
  }

  .list-item {
    background-color: map.get($tokens, 'container-color');
  }

  .list-item.selected {
    background-color: map.get($tokens, 'selected-container-color');
  }

  .selected:not(.disabled) ::slotted(*) {
    color: map.get($tokens, 'selected-label-text-color');
  }

  @media (forced-colors: active) {
    :host([disabled]),
    :host([disabled]) slot {
      color: GrayText;
      opacity: 1;
    }

    .list-item {
      position: relative;
    }

    .list-item.selected::before {
      content: '';
      position: absolute;
      inset: 0;
      box-sizing: border-box;
      border-radius: inherit;
      pointer-events: none;
      border: 3px double CanvasText;
    }
  }
}


/* ========== /internal/menuitem/menu-item-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './menu-item';
// go/keep-sorted end

@include menu-item.styles;


// ========== /internal/menuitem/menu-item.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import '../../../focus/md-focus-ring.js';
import '../../../labs/item/item.js';
import '../../../ripple/ripple.js';

import {html, LitElement, nothing, TemplateResult} from 'lit';
import {
  property,
  query,
  queryAssignedElements,
  queryAssignedNodes,
} from 'lit/decorators.js';
import {ClassInfo, classMap} from 'lit/directives/class-map.js';
import {literal, html as staticHtml, StaticValue} from 'lit/static-html.js';

import {ARIAMixinStrict} from '../../../internal/aria/aria.js';
import {mixinDelegatesAria} from '../../../internal/aria/delegate.js';
import {
  MenuItem,
  MenuItemController,
  type MenuItemType,
} from '../controllers/menuItemController.js';

// Separate variable needed for closure.
const menuItemBaseClass = mixinDelegatesAria(LitElement);

/**
 * @fires close-menu {CustomEvent<{initiator: SelectOption, reason: Reason, itemPath: SelectOption[]}>}
 * Closes the encapsulating menu on closable interaction. --bubbles --composed
 */
export class MenuItemEl extends menuItemBaseClass implements MenuItem {
  /** @nocollapse */
  static override shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
  };

  /**
   * Disables the item and makes it non-selectable and non-interactive.
   */
  @property({type: Boolean, reflect: true}) disabled = false;

  /**
   * Sets the behavior and role of the menu item, defaults to "menuitem".
   */
  @property() type: MenuItemType = 'menuitem';

  /**
   * Sets the underlying `HTMLAnchorElement`'s `href` resource attribute.
   */
  @property() href = '';

  /**
   * Sets the underlying `HTMLAnchorElement`'s `target` attribute when `href` is
   * set.
   */
  @property() target: '_blank' | '_parent' | '_self' | '_top' | '' = '';

  /**
   * Keeps the menu open if clicked or keyboard selected.
   */
  @property({type: Boolean, attribute: 'keep-open'}) keepOpen = false;

  /**
   * Sets the item in the selected visual state when a submenu is opened.
   */
  @property({type: Boolean}) selected = false;

  @query('.list-item') protected readonly listItemRoot!: HTMLElement | null;

  @queryAssignedElements({slot: 'headline'})
  protected readonly headlineElements!: HTMLElement[];
  @queryAssignedElements({slot: 'supporting-text'})
  protected readonly supportingTextElements!: HTMLElement[];
  @queryAssignedNodes({slot: ''})
  protected readonly defaultElements!: Node[];

  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }

  @property({attribute: 'typeahead-text'})
  set typeaheadText(text: string) {
    this.menuItemController.setTypeaheadText(text);
  }

  private readonly menuItemController = new MenuItemController(this, {
    getHeadlineElements: () => {
      return this.headlineElements;
    },
    getSupportingTextElements: () => {
      return this.supportingTextElements;
    },
    getDefaultElements: () => {
      return this.defaultElements;
    },
    getInteractiveElement: () => this.listItemRoot,
  });

  protected override render() {
    return this.renderListItem(html`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }

  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  protected renderListItem(content: unknown) {
    const isAnchor = this.type === 'link';
    let tag: StaticValue;
    switch (this.menuItemController.tagName) {
      case 'a':
        tag = literal`a`;
        break;
      case 'button':
        tag = literal`button`;
        break;
      default:
      case 'li':
        tag = literal`li`;
        break;
    }

    // TODO(b/265339866): announce "button"/"link" inside of a list item. Until
    // then all are "menuitem" roles for correct announcement.
    const target = isAnchor && !!this.target ? this.target : nothing;
    return staticHtml`
      <${tag}
        id="item"
        tabindex=${this.disabled && !isAnchor ? -1 : 0}
        role=${this.menuItemController.role}
        aria-label=${(this as ARIAMixinStrict).ariaLabel || nothing}
        aria-selected=${(this as ARIAMixinStrict).ariaSelected || nothing}
        aria-checked=${(this as ARIAMixinStrict).ariaChecked || nothing}
        aria-expanded=${(this as ARIAMixinStrict).ariaExpanded || nothing}
        aria-haspopup=${(this as ARIAMixinStrict).ariaHasPopup || nothing}
        class="list-item ${classMap(this.getRenderClasses())}"
        href=${this.href || nothing}
        target=${target}
        @click=${this.menuItemController.onClick}
        @keydown=${this.menuItemController.onKeydown}
      >${content}</${tag}>
    `;
  }

  /**
   * Handles rendering of the ripple element.
   */
  protected renderRipple(): TemplateResult | typeof nothing {
    return html` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }

  /**
   * Handles rendering of the focus ring.
   */
  protected renderFocusRing(): TemplateResult | typeof nothing {
    return html` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }

  /**
   * Classes applied to the list item root.
   */
  protected getRenderClasses(): ClassInfo {
    return {
      'disabled': this.disabled,
      'selected': this.selected,
    };
  }

  /**
   * Handles rendering the headline and supporting text.
   */
  protected renderBody() {
    return html`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }

  override focus() {
    // TODO(b/300334509): needed for some cases where delegatesFocus doesn't
    // work programmatically like in FF and select-option
    this.listItemRoot?.focus();
  }
}


/* ========== /internal/submenu/_sub-menu.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

@mixin styles {
  :host {
    position: relative;
    display: flex;
    flex-direction: column;
  }
}


/* ========== /internal/submenu/sub-menu-styles.scss ========== */
//
// Copyright 2023 Google LLC
// SPDX-License-Identifier: Apache-2.0
//

// go/keep-sorted start
@use './sub-menu';
// go/keep-sorted end

@include sub-menu.styles;


// ========== /internal/submenu/sub-menu.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {html, isServer, LitElement} from 'lit';
import {property, queryAssignedElements} from 'lit/decorators.js';

import {
  createDeactivateItemsEvent,
  createRequestActivationEvent,
  deactivateActiveItem,
  getFirstActivatableItem,
} from '../../../list/internal/list-navigation-helpers.js';
import {MenuItem} from '../controllers/menuItemController.js';
import {
  CloseMenuEvent,
  CloseReason,
  createActivateTypeaheadEvent,
  createDeactivateTypeaheadEvent,
  KeydownCloseKey,
  Menu,
  NavigableKey,
  SelectionKey,
} from '../controllers/shared.js';
import {Corner} from '../menu.js';

/**
 * @fires deactivate-items {Event} Requests the parent menu to deselect other
 * items when a submenu opens. --bubbles --composed
 * @fires request-activation {Event} Requests the parent to make the slotted item
 * focusable and focus the item. --bubbles --composed
 * @fires deactivate-typeahead {Event} Requests the parent menu to deactivate
 * the typeahead functionality when a submenu opens. --bubbles --composed
 * @fires activate-typeahead {Event} Requests the parent menu to activate the
 * typeahead functionality when a submenu closes. --bubbles --composed
 */
export class SubMenu extends LitElement {
  /**
   * The anchorCorner to set on the submenu.
   */
  @property({attribute: 'anchor-corner'})
  anchorCorner: Corner = Corner.START_END;
  /**
   * The menuCorner to set on the submenu.
   */
  @property({attribute: 'menu-corner'}) menuCorner: Corner = Corner.START_START;
  /**
   * The delay between mouseenter and submenu opening.
   */
  @property({type: Number, attribute: 'hover-open-delay'}) hoverOpenDelay = 400;
  /**
   * The delay between ponterleave and the submenu closing.
   */
  @property({type: Number, attribute: 'hover-close-delay'})
  hoverCloseDelay = 400;

  /**
   * READONLY: self-identifies as a menu item and sets its identifying attribute
   */
  @property({type: Boolean, reflect: true, attribute: 'md-sub-menu'})
  isSubMenu = true;

  get item() {
    return this.items[0] ?? null;
  }

  get menu() {
    return this.menus[0] ?? null;
  }

  @queryAssignedElements({slot: 'item', flatten: true})
  private readonly items!: MenuItem[];

  @queryAssignedElements({slot: 'menu', flatten: true})
  private readonly menus!: Menu[];

  private previousOpenTimeout = 0;
  private previousCloseTimeout = 0;

  constructor() {
    super();

    if (!isServer) {
      this.addEventListener('mouseenter', this.onMouseenter);
      this.addEventListener('mouseleave', this.onMouseleave);
    }
  }

  override render() {
    return html`
      <slot
        name="item"
        @click=${this.onClick}
        @keydown=${this.onKeydown}
        @slotchange=${this.onSlotchange}>
      </slot>
      <slot
        name="menu"
        @keydown=${this.onSubMenuKeydown}
        @close-menu=${this.onCloseSubmenu}
        @slotchange=${this.onSlotchange}>
      </slot>
    `;
  }

  protected override firstUpdated() {
    // slotchange is not fired if the contents have been SSRd
    this.onSlotchange();
  }

  /**
   * Shows the submenu.
   */
  async show() {
    const menu = this.menu;
    if (!menu || menu.open) return;

    // Ensures that we deselect items when the menu closes and reactivate
    // typeahead when the menu closes, so that we do not have dirty state of
    // `sub-menu > menu-item[selected]` when we reopen.
    //
    // This cannot happen in `close()` because the menu may close via other
    // means Additionally, this cannot happen in onCloseSubmenu because
    // `close-menu` may not be called via focusout of outside click and not
    // triggered by an item
    menu.addEventListener(
      'closed',
      () => {
        this.item.ariaExpanded = 'false';
        this.dispatchEvent(createActivateTypeaheadEvent());
        this.dispatchEvent(createDeactivateItemsEvent());
        // aria-hidden required so ChromeVox doesn't announce the closed menu
        menu.ariaHidden = 'true';
      },
      {once: true},
    );

    // Parent menu is `position: absolute` – this creates a new CSS relative
    // positioning context (similar to doing `position: relative`), so the
    // submenu's `<md-menu slot="submenu" positioning="document">` would be
    // wrong even if we change `md-sub-menu` from `position: relative` to
    // `position: static` because the submenu it would still be positioning
    // itself relative to the parent menu.
    if (menu.positioning === 'document') {
      menu.positioning = 'absolute';
    }
    menu.quick = true;
    // Submenus are in overflow when not fixed. Can remove once we have native
    // popup support
    menu.hasOverflow = true;
    menu.anchorCorner = this.anchorCorner;
    menu.menuCorner = this.menuCorner;
    menu.anchorElement = this.item;
    menu.defaultFocus = 'first-item';
    // aria-hidden management required so ChromeVox doesn't announce the closed
    // menu. Remove it here since we are about to show and focus it.
    menu.removeAttribute('aria-hidden');
    // This is required in the case where we have a leaf menu open and and the
    // user hovers a parent menu's item which is not an md-sub-menu item.
    // If this were set to true, then the menu would close and focus would be
    // lost. That means the focusout event would have a `relatedTarget` of
    // `null` since nothing in the menu would be focused anymore due to the
    // leaf menu closing. restoring focus ensures that we keep focus in the
    // submenu tree.
    menu.skipRestoreFocus = false;

    // Menu could already be opened because of mouse interaction
    const menuAlreadyOpen = menu.open;
    menu.show();
    this.item.ariaExpanded = 'true';
    this.item.ariaHasPopup = 'menu';
    if (menu.id) {
      this.item.setAttribute('aria-controls', menu.id);
    }

    // Deactivate other items. This can be the case if the user has tabbed
    // around the menu and then mouses over an md-sub-menu.
    this.dispatchEvent(createDeactivateItemsEvent());
    this.dispatchEvent(createDeactivateTypeaheadEvent());
    this.item.selected = true;

    // This is the case of mouse hovering when already opened via keyboard or
    // vice versa
    if (!menuAlreadyOpen) {
      let open = (value: unknown) => {};
      const opened = new Promise((resolve) => {
        open = resolve;
      });
      menu.addEventListener('opened', open, {once: true});
      await opened;
    }
  }

  /**
   * Closes the submenu.
   */
  async close() {
    const menu = this.menu;
    if (!menu || !menu.open) return;

    this.dispatchEvent(createActivateTypeaheadEvent());
    menu.quick = true;
    menu.close();
    this.dispatchEvent(createDeactivateItemsEvent());
    let close = (value: unknown) => {};
    const closed = new Promise((resolve) => {
      close = resolve;
    });
    menu.addEventListener('closed', close, {once: true});
    await closed;
  }

  protected onSlotchange() {
    if (!this.item) {
      return;
    }

    // TODO(b/301296618): clean up old aria values on change
    this.item.ariaExpanded = 'false';
    this.item.ariaHasPopup = 'menu';
    if (this.menu?.id) {
      this.item.setAttribute('aria-controls', this.menu.id);
    }
    this.item.keepOpen = true;

    const menu = this.menu;
    if (!menu) return;

    menu.isSubmenu = true;
    // Required for ChromeVox to not linearly navigate to the menu while closed
    menu.ariaHidden = 'true';
  }

  /**
   * Starts the default 400ms countdown to open the submenu.
   *
   * NOTE: We explicitly use mouse events and not pointer events because
   * pointer events apply to touch events. And if a user were to tap a
   * sub-menu, it would fire the "pointerenter", "pointerleave", "click" events
   * which would open the menu on click, and then set the timeout to close the
   * menu due to pointerleave.
   */
  protected onMouseenter = () => {
    clearTimeout(this.previousOpenTimeout);
    clearTimeout(this.previousCloseTimeout);
    if (this.menu?.open) return;

    // Open synchronously if delay is 0. (screenshot tests infra
    // would never resolve otherwise)
    if (!this.hoverOpenDelay) {
      this.show();
    } else {
      this.previousOpenTimeout = setTimeout(() => {
        this.show();
      }, this.hoverOpenDelay);
    }
  };

  /**
   * Starts the default 400ms countdown to close the submenu.
   *
   * NOTE: We explicitly use mouse events and not pointer events because
   * pointer events apply to touch events. And if a user were to tap a
   * sub-menu, it would fire the "pointerenter", "pointerleave", "click" events
   * which would open the menu on click, and then set the timeout to close the
   * menu due to pointerleave.
   */
  protected onMouseleave = () => {
    clearTimeout(this.previousCloseTimeout);
    clearTimeout(this.previousOpenTimeout);

    // Close synchronously if delay is 0. (screenshot tests infra
    // would never resolve otherwise)
    if (!this.hoverCloseDelay) {
      this.close();
    } else {
      this.previousCloseTimeout = setTimeout(() => {
        this.close();
      }, this.hoverCloseDelay);
    }
  };

  protected onClick() {
    this.show();
  }

  /**
   * On item keydown handles opening the submenu.
   */
  protected async onKeydown(event: KeyboardEvent) {
    const shouldOpenSubmenu = this.isSubmenuOpenKey(event.code);

    if (event.defaultPrevented) return;

    const openedWithLR =
      shouldOpenSubmenu &&
      (NavigableKey.LEFT === event.code || NavigableKey.RIGHT === event.code);

    if (event.code === SelectionKey.SPACE || openedWithLR) {
      // prevent space from scrolling and Left + Right from selecting previous /
      // next items or opening / closing parent menus. Only open the submenu.
      event.preventDefault();

      if (openedWithLR) {
        event.stopPropagation();
      }
    }

    if (!shouldOpenSubmenu) {
      return;
    }

    const submenu = this.menu;
    if (!submenu) return;

    const submenuItems = submenu.items;
    const firstActivatableItem = getFirstActivatableItem(submenuItems);

    if (firstActivatableItem) {
      await this.show();

      firstActivatableItem.tabIndex = 0;
      firstActivatableItem.focus();

      return;
    }
  }

  private onCloseSubmenu(event: CloseMenuEvent) {
    const {itemPath, reason} = event.detail;
    itemPath.push(this.item);

    this.dispatchEvent(createActivateTypeaheadEvent());
    // Escape should only close one menu not all of the menus unlike space or
    // click selection which should close all menus.
    if (
      reason.kind === CloseReason.KEYDOWN &&
      reason.key === KeydownCloseKey.ESCAPE
    ) {
      event.stopPropagation();
      this.item.dispatchEvent(createRequestActivationEvent());
      return;
    }

    this.dispatchEvent(createDeactivateItemsEvent());
  }

  private async onSubMenuKeydown(event: KeyboardEvent) {
    if (event.defaultPrevented) return;
    const {close: shouldClose, keyCode} = this.isSubmenuCloseKey(event.code);
    if (!shouldClose) return;

    // Communicate that it's handled so that we don't accidentally close every
    // parent menu. Additionally, we want to isolate things like the typeahead
    // keydowns from bubbling up to the parent menu and confounding things.
    event.preventDefault();

    if (keyCode === NavigableKey.LEFT || keyCode === NavigableKey.RIGHT) {
      // Prevent this from bubbling to parents
      event.stopPropagation();
    }

    await this.close();

    deactivateActiveItem(this.menu.items);
    this.item?.focus();
    this.item.tabIndex = 0;
    this.item.focus();
  }

  /**
   * Determines whether the given KeyboardEvent code is one that should open
   * the submenu. This is RTL-aware. By default, left, right, space, or enter.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should open the submenu.
   */
  private isSubmenuOpenKey(code: string) {
    const isRtl = getComputedStyle(this).direction === 'rtl';
    const arrowEnterKey = isRtl ? NavigableKey.LEFT : NavigableKey.RIGHT;
    switch (code) {
      case arrowEnterKey:
      case SelectionKey.SPACE:
      case SelectionKey.ENTER:
        return true;
      default:
        return false;
    }
  }

  /**
   * Determines whether the given KeyboardEvent code is one that should close
   * the submenu. This is RTL-aware. By default right, left, or escape.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should close the submenu.
   */
  private isSubmenuCloseKey(code: string) {
    const isRtl = getComputedStyle(this).direction === 'rtl';
    const arrowEnterKey = isRtl ? NavigableKey.RIGHT : NavigableKey.LEFT;
    switch (code) {
      case arrowEnterKey:
      case KeydownCloseKey.ESCAPE:
        return {close: true, keyCode: code} as const;
      default:
        return {close: false} as const;
    }
  }
}


// ========== /internal/types.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Event properties used by the adapter and foundation.
 */
export interface MDCMenuItemEventDetail {
  index: number;
}

/**
 * Event properties specific to the default component implementation.
 */
export interface MDCMenuItemComponentEventDetail
  extends MDCMenuItemEventDetail {
  item: Element;
}

// Note: CustomEvent<T> is not supported by Closure Compiler.

export interface MDCMenuItemEvent extends Event {
  readonly detail: MDCMenuItemEventDetail;
}

export interface MDCMenuItemComponentEvent extends Event {
  readonly detail: MDCMenuItemComponentEventDetail;
}


// ========== /menu-item.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {MenuItemEl} from './internal/menuitem/menu-item.js';
import {styles} from './internal/menuitem/menu-item-styles.js';

export {type MenuItem} from './internal/controllers/menuItemController.js';
export {type CloseMenuEvent} from './internal/controllers/shared.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-menu-item': MdMenuItem;
  }
}

/**
 * @summary Menus display a list of choices on a temporary surface.
 *
 * @description
 * Menu items are the selectable choices within the menu. Menu items must
 * implement the `MenuItem` interface and also have the `md-menu-item`
 * attribute. Additionally menu items are list items so they must also have the
 * `md-list-item` attribute.
 *
 * Menu items can control a menu by selectively firing the `close-menu` and
 * `deselect-items` events.
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-menu-item')
export class MdMenuItem extends MenuItemEl {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /menu.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {Menu} from './internal/menu.js';
import {styles} from './internal/menu-styles.js';

export {type ListItem} from '../list/internal/list-navigation-helpers.js';
export {type MenuItem} from './internal/controllers/menuItemController.js';
export {
  CloseReason,
  FocusState,
  type CloseMenuEvent,
  type Menu,
} from './internal/controllers/shared.js';
export {Corner} from './internal/menu.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-menu': MdMenu;
  }
}

/**
 * @summary Menus display a list of choices on a temporary surface.
 *
 * @description
 * Menus appear when users interact with a button, action, or other control.
 *
 * They can be opened from a variety of elements, most commonly icon buttons,
 * buttons, and text fields.
 *
 * md-menu listens for the `close-menu` and `deselect-items` events.
 *
 * - `close-menu` closes the menu when dispatched from a child element.
 * - `deselect-items` deselects all of its immediate menu-item children.
 *
 * @example
 * ```html
 * <div style="position:relative;">
 *   <button
 *       id="anchor"
 *       @click=${() => this.menuRef.value.show()}>
 *     Click to open menu
 *   </button>
 *   <!--
 *     `has-overflow` is required when using a submenu which overflows the
 *     menu's contents.
 *
 *     Additionally, `anchor` ingests an idref which do not pass through shadow
 *     roots. You can also set `.anchorElement` to an element reference if
 *     necessary.
 *   -->
 *   <md-menu anchor="anchor" has-overflow ${ref(menuRef)}>
 *     <md-menu-item headline="This is a headline"></md-menu-item>
 *     <md-sub-menu>
 *       <md-menu-item
 *           slot="item"
 *           headline="this is a submenu item">
 *       </md-menu-item>
 *       <md-menu slot="menu">
 *         <md-menu-item headline="This is an item inside a submenu">
 *         </md-menu-item>
 *       </md-menu>
 *     </md-sub-menu>
 *   </md-menu>
 * </div>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-menu')
export class MdMenu extends Menu {
  static override styles: CSSResultOrNative[] = [styles];
}


// ========== /menu_test.ts ==========
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// import 'jasmine'; (google3-only)
import './menu.js';
import './sub-menu.js';

import {html, render} from 'lit';

import {createTokenTests} from '../testing/tokens.js';

import {MenuItemHarness} from './harness.js';
import {MdMenu} from './menu.js';
import {MdMenuItem} from './menu-item.js';

describe('<md-menu>', () => {
  describe('.styles', () => {
    createTokenTests(MdMenu.styles);
  });

  let root: HTMLDivElement;

  beforeEach(() => {
    root = document.createElement('div');
    document.body.appendChild(root);
  });

  afterEach(() => {
    root?.remove();
  });

  it('escape on list root closes menu', async () => {
    render(
      html`
        <button>OpenMenu</button>
        <md-menu quick></md-menu>
      `,
      root,
    );

    const button = root.querySelector('button')!;
    const menu = root.querySelector('md-menu')!;
    menu.anchorElement = button;
    menu.show();

    expect(menu.open).toBeTrue();

    const escapeKeydownEvent = new KeyboardEvent('keydown', {
      key: 'Escape',
      code: 'Escape',
      bubbles: true,
      composed: true,
      cancelable: true,
    });
    menu.dispatchEvent(escapeKeydownEvent);

    await menu.updateComplete;

    expect(menu.open).toBeFalse();
    expect(escapeKeydownEvent.defaultPrevented).toBeTrue();
  });

  // Regression test for b/314706578.
  it('escape on submenu items closes menu', async () => {
    render(
      html`
        <button>OpenMenu</button>
        <md-menu quick>
          <md-sub-menu hover-open-delay="0" hover-close-delay="0">
            <md-menu-item id="submenu-item" slot="item">
              <div slot="headline">Link Item 1</div>
            </md-menu-item>
            <md-menu quick slot="menu">
              <md-menu-item slot="item">
                <div slot="headline">Submenu Item 1</div>
              </md-menu-item>
            </md-menu>
          </md-sub-menu>
        </md-menu>
      `,
      root,
    );

    const button = root.querySelector('button')!;
    const menu = root.querySelector('md-menu')!;
    const submenuItemHarness = new MenuItemHarness(
      menu.querySelector('#submenu-item')!,
    );
    menu.anchorElement = button;
    menu.show();

    expect(menu.open).toBeTrue();

    const escapeKeydownEvent = new KeyboardEvent('keydown', {
      key: 'Escape',
      code: 'Escape',
      bubbles: true,
      composed: true,
      cancelable: true,
    });
    const interactiveElement = await submenuItemHarness.getInteractiveElement();
    interactiveElement.dispatchEvent(escapeKeydownEvent);

    await menu.updateComplete;

    expect(menu.open).toBeFalse();
    expect(escapeKeydownEvent.defaultPrevented).toBeTrue();
  });
});

describe('<md-menu-item>', () => {
  describe('.styles', () => {
    createTokenTests(MdMenuItem.styles);
  });
});


// ========== /sub-menu.ts ==========
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {CSSResultOrNative} from 'lit';
import {customElement} from 'lit/decorators.js';

import {SubMenu} from './internal/submenu/sub-menu.js';
import {styles} from './internal/submenu/sub-menu-styles.js';

declare global {
  interface HTMLElementTagNameMap {
    'md-sub-menu': MdSubMenu;
  }
}

/**
 * @summary Menus display a list of choices on a temporary surface.
 *
 * @description
 * Menu items are the selectable choices within the menu. Menu items must
 * implement the `Menu` interface and also have the `md-menu`
 * attribute. Additionally menu items are list items so they must also have the
 * `md-list-item` attribute.
 *
 * Menu items can control a menu by selectively firing the `close-menu` and
 * `deselect-items` events.
 *
 * This menu item will open a sub-menu that is slotted in the `submenu` slot.
 * Additionally, the containing menu must either have `has-overflow` or
 * `positioning=fixed` set to `true` in order to display the containing menu
 * properly.
 *
 * @example
 * ```html
 * <div style="position:relative;">
 *   <button
 *       id="anchor"
 *       @click=${() => this.menuRef.value.show()}>
 *     Click to open menu
 *   </button>
 *   <!--
 *     `has-overflow` is required when using a submenu which overflows the
 *     menu's contents
 *   -->
 *   <md-menu anchor="anchor" has-overflow ${ref(menuRef)}>
 *     <md-menu-item headline="This is a headline"></md-menu-item>
 *     <md-sub-menu>
 *       <md-menu-item
 *           slot="item"
 *           headline="this is a submenu item">
 *       </md-menu-item>
 *       <md-menu slot="menu">
 *         <md-menu-item headline="This is an item inside a submenu">
 *         </md-menu-item>
 *       </md-menu>
 *     </md-sub-menu>
 *   </md-menu>
 * </div>
 * ```
 *
 * @final
 * @suppress {visibility}
 */
@customElement('md-sub-menu')
export class MdSubMenu extends SubMenu {
  static override styles: CSSResultOrNative[] = [styles];
}